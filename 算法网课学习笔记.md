# 左神新手网课

## 5.位图、位运算实现加减乘除



位图，就是拿每一位的bit来做图。假如说自己想表示的是0-31之间的数，那么做的set，就可以直接只使用一个int就能表示，比如set里面有一个1，那么这个数就是0001H,比如还有一个2，那就是0021H。1个整数是32位的，可以表示32个数，那么准备32个数，就可以表示0-1023范围内的数。

## 位图的功能

如果数字是非常的确定的，最大值很确定，就可以用位图来实现数字并且告诉存在不存在。好处就是可以极大的压缩空间。

```java
	public static class BitMap {

		private long[] bits;// 这里用到的是long，是64位的。

		public BitMap(int max) {
			bits = new long[(max + 64) >> 6]; // (max + 64) / 64,表示要准备多少个数，相当于扣边界。
		}

		public void add(int num) {
			bits[num >> 6] |= (1 << (num & 63));
		}

		public void delete(int num) {
			bits[num >> 6] &= ~(1 << (num & 63));
		}

		public boolean contains(int num) {
			return (bits[num >> 6] & (1 << (num & 63))) != 0;
		}

	}
```







# 左神的基础算法网课

# 1.算法 认识复杂度对数期二分法与异或运算

## 评估算法的优劣的核心指标是什么？

* 时间复杂度（流程决定)
* 额外空间复杂度（流程决定）
* 常数项时间（实现细节决定）





## 一个问题的最优解是什么意思？

解决一个问题的流程中，在满足时间复杂度最低的基础上，使用最少的空间的算法流程，是问题的最优解。一般都是忽略掉常数项这个因素的。在一般面试过程来说，**应该不卡常数项时间的**，如果因为这个被卡了，可以写邮件反馈一下哈哈哈。



## 什么是对数器？

1. 想要测试的方法a
2. 实现复杂度不好但是容易实现的b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a和方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确



# 2.二分法

==不一定有序才能二分，在二分的过程中，只要有排他性，就是把另一边排除掉不看就行出现，就可以做二分==

## 二分的应用场景？

1. 查找某个值
2. 找<=1的范围
3. 找>=1的范围
4. 局部最小值

​	

​	对于局部最小的这个引用情况，对于无序的arr数组，如果可以确定某个范围内，比如a[0]>a[1]，可以看出左边是向下降的趋势，a[n-2]>a[n-1]，可以看出右边是上升的趋势，**那么就可以确定arr的这个范围中一定有局部最小值**.

示例代码：

![image-20220801142250616](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801142250616-16593349723901.png)

## 技巧？

​	如果 left,right的值很大，那么按照我传统的计算方法`mid=(left+right)/2`会溢出，这个时候，可以用`mid=left+(right-left)/2`来代替，这样就比较安全了，然后，还可以使用`mid=L + ((R - L) >> 1)`这样的话，位运算比除法快的。

---



​	类似的：N * 2 可以写为==N<<1==;N * 2 + 1可以写为==((N << 1) | 1)==

---



# 3.异或运算

* ~~异或：相同为0，不同为1~~
* ~~同或：相同为1，不同为0~~
* ==异或运算就记成无进位相加！！！这么记==，比如6异或7的结果，就是0110 + 0111 = 0001



异或运算的性质：

1. 0^N == N    N^N==0
2. 异或运算满足交换律和结合律(==用无进位相加来理解==),也就是说a^b == b^a    a^b ^c = a^( b^c),**也就是说对于同一批数，不用管他们的顺序，结果是一样的。**



## 如何不用额外空间就交换两个数的值？

通过下面代码实现了，也就是说b^b=0和 0^N=N这俩的应用

 ```
 a = 2,b=3
 a = a^b
 b = a^b
 a = a^b
 ```

**注意，如果a,b是指向同一个位置的，那就不对了，所以a，b二者必须指向不同的内存。**



## 怎么把一个int类型的数，提取出最右侧的1出来？

 

比如N=00011000100，那么怎么得到ans=00000000100

则通过：

```
N&(~N+1)#原始的N与上（取反的N+1），可以自己写写试试
```

 



## 一个数组中有俩种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这两种数？

  设a,b是出现了奇数次的那两种数，那么对这个数组arr进行全部的异或得到的结果eor=a^b,a和b一定是不等的，也一定是不等0的，那么a ^ b也一定不等于0，假如说a和b的第八位是不同的，那么就可以根据上面的那个小trick来把arr中的数分为两类，一类是第八位为0的，一类是第八位不等于0的，那就这两类分别的进行异或，然后就可以得到a和b的真实的值了，太妙了。  

​	至于下面代码为什么取出最右的1来判断，因为异或的性质嘛，eor的值为1的位就是a b两个不相同的位置嘛！



![image-20220801145726314](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801145726314-16593370476162.png)





## 找到一个int数中的二进制的位数？

```
count = 0
N = 321
while N!=0:
	rightOne = N & ((~N)+1)
	count+=1
	N ^=rightOne # 注意，不要写N -=rightOne,因为N如果是负数的话，这样就错了！
```





# 2算法 链表结构、栈、队列、递归行为、哈希表

# 2.1 单向链表和双向链表最简单的练习

1. 单双链表如何反转
2. 删除给定值





# 2.2 栈和队列

可以通过双向链表或者数组的方式进行实现。



​	常见的面试题：实现一个特殊的栈，在基础功能的基础上，实现返回栈中最小元素的功能，并且getMin()函数的时间复杂度为O(1),对于这个问题，做两个栈就行了，data栈是基本的栈，min栈里面是只压当前栈顶与要压入的数中最小的，这样的话，在任何时候getMin()都是得到最小栈的栈顶就行了。还有一种实现方法，就不说了，感兴趣百度吧。。

```java
	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}
```



还有常见面试题：

1. 如何用栈结构实现队列结构（用俩栈拼队列）
2. 如何用队列结构实现栈结构（用俩队列拼栈）



## 语言已经有了API，为什么要学这种基础的？

因为在自己使用的时候会碰到需要改写的情况。





# 2.3 递归

## 递归的时间长度

对于递归子问题规模是一样的：

​	T(N) = aT(N/b) + O(N^d^),a,b,d都是常数

则那么时间复杂度为：

1. 如果log~b~a > d,那么T(N) = O(N^(log~b~a)^)
2. 如果log~b~a < d,那么T(N) = O(N^d^)
3. 如果log~b~a = d,那么T(N) = O(N^d^ * logN)





# 2.4 哈希表

* 哈希表的增、删、改、查在使用时O(1)

* set和dict就是哈希表的结构
* 放入哈希表的数据，如果是基础类型，则内部按值传递，内存占用是这个东西的大小；如果不是基础类型，那么就内部按照引用传递，内部按占用传递，内存占用是8字节。



java的有序表，treeMap，有序表底层可以由AVL树，SB树，红黑树，跳表；AVL和SB和红黑树他们的平衡性是不一样的，跳表是新的设计也，他们都可以实现有序表，他们只是实现细节不一样，只有常数项的差距。



# 3.算法归并排序与随机快排

归并排序,注意下面的那个非递归排序，有一个判断：mergeSize > N /2,这个判断是防止当arr的大小接近临界大小2^32-1的时候，如果mergeSize > N/2 那么就知道下次×2 就会越界了，所以在这里就直接break出来，防止失败。



```java
// 递归方法实现
	public static void mergeSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process(arr, 0, arr.length - 1);
	}

	// arr[L...R]范围上，变成有序的
	// L...R    N    T(N) = 2*T(N/2) + O(N)  ->
	public static void process(int[] arr, int L, int R) {
		if (L == R) { // base case
			return;
		}
		int mid = L + ((R - L) >> 1);
		process(arr, L, mid);
		process(arr, mid + 1, R);
		merge(arr, L, mid, R);
	}

	public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 要么p1越界了，要么p2越界了
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
	}

	// 非递归方法实现
	public static void mergeSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		int mergeSize = 1;// 当前有序的，左组长度
		while (mergeSize < N) { // log N
			int L = 0;
			// 0.... 
			while (L < N) {
				// L...M  左组（mergeSize）
				int M = L + mergeSize - 1;
				if (M >= N) {
					break;
				}
				//  L...M   M+1...R(mergeSize)
				int R = Math.min(M + mergeSize, N - 1);
				merge(arr, L, M, R);
				L = R + 1;
			}
			if (mergeSize > N / 2) {
				break;
			}
			mergeSize <<= 1;
		}
	}

```

## 归并排序的时间复杂度

1. 对于递归方法O（N*logN),这个就是用计算递归的那个公式去得到的。
2. 对于非递归方法也是O（N*logN)
3. 选择的方法不太好，因为浪费了很多的时间去做独立的比较行为。
4. 归并排序需要辅助数组，额外空间复杂度为O（N）



## 练习题

力扣的315类似，和[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)类似。



# 3.2 快速排序

举得一个例子是类似于荷兰国旗问题的划分，就是给一个arr数组，和一个数字num，让比num小于等于的放在arr左边，比他大的在右边，返回一个左右边界。

​	快排最好的情况是，随机选的num是现在待排序的中点位置的。坏情况就是num选的很偏。



* 时间复杂度O（nlogN),空间复杂度O(logN)





# 4-比较器与堆



## 4.1 堆



* 结构上是完全二叉树的结构，完全二叉树每一层都是满的，如果最后一层是不满的，那么也是从左到右在变满的状态。



​	假如说有一个完全二叉树：[0,1,2,3,4,5]，如果从0位置开始的话，对于节点i,他的左孩子是2*i+1,右孩子是2*i+2,父节点为(i-1)/2;

如果[-1,1,2,3,4,5],0位置弃而不用，那么对于i节点，左孩子是2 * i,右孩子是2*i+1,父节点为i / 2;**从1开始有一个好处，就是可以利用位运算来加速计算**。

* ==大根堆==:每一颗子树最大值都是自己头结点的值，比如[6,5,3,0,1]
* ==小根堆==：每一颗子树最小值都是自己头结点



### 堆排序

时间复杂度N*log(N)

```java
	// 堆排序额外空间复杂度O(1)
	public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// O(N*logN)
//		for (int i = 0; i < arr.length; i++) { // O(N)
//			heapInsert(arr, i); // O(logN)
//		}
        //上面三行是经典的，下面的三行是改进的，下面的这个改进只是让数组变为了大根堆，上面经典的是有序的。
		for (int i = arr.length - 1; i >= 0; i--) {
			heapify(arr, i, arr.length);
		}
		int heapSize = arr.length;
		swap(arr, 0, --heapSize);
		// O(N*logN)
		while (heapSize > 0) { // O(N)
			heapify(arr, 0, heapSize); // O(logN)
			swap(arr, 0, --heapSize); // O(1)
		}
	}
```

与堆相关的题：
	已知一个几乎有序的数组.几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的.请选择一个合适的排序策略,对这个数组进行排序。

​	上面这个题的解题思路：生成一个小根堆，把前k+1个 数做一个原始的小根堆，然后把这个小根堆的最小的值弹出来为arr[0]，然后小根堆中压入arr[k+1],继续弹出此时小根堆最小值arr[1]，然后一直重复



## 4.2 比较器

* 实质就是重载比较运算符
* 比较器可以很好的应用在特殊标准的排序上
* 比较器可以很好的应用中根据特殊标准排序的结构上
* 写代码变得异于简单，适合编程方式



对于一个堆已经装好数了，然后想要对立面的某一个数修改后，仍保持堆的结构，时间复杂度最好logN（如果系统默认的话，时间复杂度是NlogN的） //TODO具体来说就是自己实现的堆，包含一个dict()





# 5-trie、桶排序、排序总结

## 5.1 前缀树---可以完成前缀查询

* 单个字符串，字符从前到后的加到一课多叉树上
* 字符放在路上，节点上有专属的数据项（常见的是pass和end,pass指该节点被通过几次，end指该节点被做过几次结尾)
* 所有样本的这样添加，如果没有路就新建，如有路就复用
* 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

## 5.2 不基于比较的排序----桶排序

桶排序是一个思想，桶就是容器，可以是数组，栈，队列等等，就是一个萝卜一个坑，该排序必须与数据的样本容量强相关（最大值到最小值要很窄），计数排序也对样本本身有要求,**所以不基于比较的排序应用范围非常有限**







## 5.3 基数排序

* 非负
* 十进制数

基数排序属于桶排序思想下的。以上两个要求是经典基数排序的要求。小数也可以做，不过不好改，不好做。代码要改动很多

有一种很骚的实现的方式，时间复杂度为O(N*log_10 * N):

```
public static void radixSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		radixSort(arr, 0, arr.length - 1, maxbits(arr));
	}

	public static int maxbits(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int res = 0;
		while (max != 0) {
			res++;
			max /= 10;
		}
		return res;
	}

	// arr[l..r]排序  ,  digit
	// l..r    3 56 17 100    3
	public static void radixSort(int[] arr, int L, int R, int digit) {
		final int radix = 10;
		int i = 0, j = 0;
		// 有多少个数准备多少个辅助空间
		int[] help = new int[R - L + 1];
		for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
			// 10个空间
		    // count[0] 当前位(d位)是0的数字有多少个
			// count[1] 当前位(d位)是(0和1)的数字有多少个
			// count[2] 当前位(d位)是(0、1和2)的数字有多少个
			// count[i] 当前位(d位)是(0~i)的数字有多少个
			int[] count = new int[radix]; // count[0..9]
			for (i = L; i <= R; i++) {
				// 103  1   3
				// 209  1   9
				j = getDigit(arr[i], d);
				count[j]++;
			}
			for (i = 1; i < radix; i++) {
				count[i] = count[i] + count[i - 1];
			}
			for (i = R; i >= L; i--) {
				j = getDigit(arr[i], d);
				help[count[j] - 1] = arr[i];
				count[j]--;
			}
			for (i = L, j = 0; i <= R; i++, j++) {
				arr[i] = help[j];
			}
		}
		
		
		
		
	}

	public static int getDigit(int x, int d) {
		return ((x / ((int) Math.pow(10, d - 1))) % 10);
	}
```

## 5.4 计数排序

这个比较简单吧

```
	// only for 0~200 value
	public static void countSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}
```

## 5.5 排序算法的稳定性

* 稳定性是同样大小的样本再排序之后不会改变相对次序
* 对基础类型来说，稳定性毫无意义
* 对非基础类型来说，稳定性很有意义
* 快排，非简单选择排序，归并排序的特殊情况，堆不稳定
* 不基于比较的排序对样本数据有严格要求，不易改写
* 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
* 基于比较的排序，时间复杂度的极限是O（N*logN)
* 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
* 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并
* 归并排序的额外空间复杂度可以变为O（1），“归并排序 内存缓存法”，但是将变得不再稳定
* “原地归并排序”是垃圾帖，会让时间复杂度变成O（N^2)
* 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多
* 在整型数组中，把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变，时间复杂度做到O（N），额外空间复杂度做到O（1）这是属于0-1标准的partition，这个问题应该是很难，可以反问面试官，这就是学术上的很严格的论文。。
* 



![image-20220804093438112](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220804093438112-16595768789731.png)



  # 6. 链表问题



* 对于笔试，不必太在乎空间复杂度，一切为了时间复杂度
* 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法
* 链表面试常用的数据结构和技巧：1）使用容器（哈希表、数组等）；2）快慢指针

## 6.1 快慢指针问题

==下面是个问题的边界条件不同==





1)输入链表头节点，奇数长度返回中点，偶数长度返回上中点

```java
	public static Node midOrUpMidNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return head;
		}
		// 链表有3个点或以上
		Node slow = head.next;
		Node fast = head.next.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```

2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点

```
	public static Node midOrDownMidNode(Node head) {
		if (head == null || head.next == null) {
			return head;
		}
		Node slow = head.next;
		Node fast = head.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```



3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个

```java
	public static Node midOrUpMidPreNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		Node slow = head;
		Node fast = head.next.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```

4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

```java
	public static Node midOrDownMidPreNode(Node head) {
		if (head == null || head.next == null) {
			return null;
		}
		if (head.next.next == null) {
			return head;
		}
		Node slow = head;
		Node fast = head.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```



## 6.2 链表判断回文

==方法1，空间复杂度O(n)==

首先遍历一遍链表，然后把每个值压栈；然后再遍历一遍链表，然后把每个值从栈里弹出进行比较，如果有不相同的退出返回False。

==方法2（快慢指针，减少空间的使用,空间复杂度O(n/2)）==

通过快慢指针首先定位到栈的中间的位置，然后再开始压栈，只往栈里压入链表后半部分的数值。然后把每个值从栈里弹出进行比较，如果有不相同的退出返回False。

==方法3（快慢指针，然后逆序后半部分，空间复杂度0(1))==



```java
	// need n extra space
	public static boolean isPalindrome1(Node head) {
		Stack<Node> stack = new Stack<Node>();
		Node cur = head;
		while (cur != null) {
			stack.push(cur);
			cur = cur.next;
		}
		while (head != null) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// need n/2 extra space
	public static boolean isPalindrome2(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node right = head.next;
		Node cur = head;
		while (cur.next != null && cur.next.next != null) {
			right = right.next;
			cur = cur.next.next;
		}
		Stack<Node> stack = new Stack<Node>();
		while (right != null) {
			stack.push(right);
			right = right.next;
		}
		while (!stack.isEmpty()) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// need O(1) extra space
	public static boolean isPalindrome3(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node n1 = head;
		Node n2 = head;
		while (n2.next != null && n2.next.next != null) { // find mid node
			n1 = n1.next; // n1 -> mid
			n2 = n2.next.next; // n2 -> end
		}
		// n1 中点
		
		
		n2 = n1.next; // n2 -> right part first node
		n1.next = null; // mid.next -> null
		Node n3 = null;
		while (n2 != null) { // right part convert
			n3 = n2.next; // n3 -> save next node
			n2.next = n1; // next of right node convert
			n1 = n2; // n1 move
			n2 = n3; // n2 move
		}
		n3 = n1; // n3 -> save last node
		n2 = head;// n2 -> left first node
		boolean res = true;
		while (n1 != null && n2 != null) { // check palindrome
			if (n1.value != n2.value) {
				res = false;
				break;
			}
			n1 = n1.next; // left to mid
			n2 = n2.next; // right to mid
		}
		n1 = n3.next;
		n3.next = null;
		while (n1 != null) { // recover list
			n2 = n1.next;
			n1.next = n3;
			n3 = n1;
			n1 = n2;
		}
		return res;
	}
```

### 6.3 将单链表化为左边小于k,右边大于k,中间等于k

笔试的写法（这种写法时间复杂度O(n)，就是空间复杂度多点)：

首先把链表中的数读到一个数组中，然后对数组做partition，然后再把这个数组放到新的单链表中。

面试的写法（这种写法空间复杂度O(1)):

做6个引用，SH，ST为小于K区域的头和尾，EH，ET为等于K区域的头和尾，BH,BT为大于K区域的头和尾。

```java
public static Node listPartition2(Node head, int pivot) {
		Node sH = null; // small head
		Node sT = null; // small tail
		Node eH = null; // equal head
		Node eT = null; // equal tail
		Node mH = null; // big head
		Node mT = null; // big tail
		Node next = null; // save next node
		// every node distributed to three lists
		while (head != null) {
			next = head.next;
			head.next = null;
			if (head.value < pivot) {
				if (sH == null) {
					sH = head;
					sT = head;
				} else {
					sT.next = head;
					sT = head;
				}
			} else if (head.value == pivot) {
				if (eH == null) {
					eH = head;
					eT = head;
				} else {
					eT.next = head;
					eT = head;
				}
			} else {
				if (mH == null) {
					mH = head;
					mT = head;
				} else {
					mT.next = head;
					mT = head;
				}
			}
			head = next;
		}
		// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
		if (sT != null) { // 如果有小于区域
			sT.next = eH;
			eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
		}
		// 上面的if，不管跑了没有，et
		// all reconnect
		if (eT != null) { // 如果小于区域和等于区域，不是都没有
			eT.next = mH;
		}
		return sH != null ? sH : (eH != null ? eH : mH);
	}
```



## 6.4 [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)



==笔试方法：哈希表==

```java
public static Node copyListWithRand1(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node cur = head;
		while (cur != null) {
			map.put(cur, new Node(cur.value));
			cur = cur.next;
		}
		cur = head;
		while (cur != null) {
			// cur 老
			// map.get(cur) 新
			map.get(cur).next = map.get(cur.next);
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		}
		return map.get(head);
	}
```





==面试方法：不用哈希表,空间复杂度O(1)==



```java

public static Node copyListWithRand2(Node head) {
		if (head == null) {
			return null;
		}
		Node cur = head;
		Node next = null;
		// copy node and link to every node
		// 1 -> 2
		// 1 -> 1' -> 2
		while (cur != null) {
			// cur 老   next 老的下一个
			next = cur.next;
			cur.next = new Node(cur.value);
			cur.next.next = next;
			cur = next;
		}
		cur = head;
		Node curCopy = null;
		// set copy node rand
		// 1 -> 1' -> 2 -> 2'
		while (cur != null) {
			// cur 老
			// cur.next  新 copy
			next = cur.next.next;
			curCopy = cur.next;
			curCopy.rand = cur.rand != null ? cur.rand.next : null;
			cur = next;
		}
		// head  head.next
		Node res = head.next;
		cur = head;
		// split
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
			cur = next;
		}
		return res;
	}
```

## 6.5链表相交

==这个题和链表约瑟夫环的问题是链表的俩个噩梦==

给定两个可能有环也可能无环的单链表,头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null


【要求】

如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。



==相交只和节点的内存地址有关，和值没有关系==，首先可以判断链表有环没环，如果链表有环，返回第一个链表入环的节点，否则返回空节点。

判断第一个入环的节点：==可以用哈希表的方法，针对内存地址==；  ==使用快慢指针，则二者一定能在入环口相遇==

1. 首先判断两个链表的是否有环,loop1,loop2是否为空;
2. 如果两个链表都无环，那二者最后相交一定有公共部分,这个时候可以把链表1放在set中，然后对于链表2一个一个判断。还有另外一个方法，记录两个两个链表的长度，并且判断两个链表的最后节点end1和end2是否内存地址一样，如果不一样，就证明不相交,如果相交，则让长的链表先走len(链表1) - len(链表2),然后二者一起走就可以得到相交的节点了。
3. ==如果一个链表有环，一个链表没环，不可能相交==
4. 两个链表都有环，有三种可能1）二者入环节点是一个，在环外；2）二者入环节点一样，是相交点；3）二者入环节点不同，且在环内。对于第二种情况，直接判断loop1==loop2就行了。然后让loop1一直走，看能不能碰到loop2，如果能碰到就是情况3，不然是情况1.

```java
public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node getIntersectNode(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node loop1 = getLoopNode(head1);
		Node loop2 = getLoopNode(head2);
		if (loop1 == null && loop2 == null) {
			return noLoop(head1, head2);
		}
		if (loop1 != null && loop2 != null) {
			return bothLoop(head1, loop1, head2, loop2);
		}
		return null;
	}

	// 找到链表第一个入环节点，如果无环，返回null
	public static Node getLoopNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		// n1 慢  n2 快
		Node n1 = head.next; // n1 -> slow
		Node n2 = head.next.next; // n2 -> fast
		while (n1 != n2) {
			if (n2.next == null || n2.next.next == null) {
				return null;
			}
			n2 = n2.next.next;
			n1 = n1.next;
		}
		n2 = head; // n2 -> walk again from head
		while (n1 != n2) {
			n1 = n1.next;
			n2 = n2.next;
		}
		return n1;
	}

	// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null
	public static Node noLoop(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node cur1 = head1;
		Node cur2 = head2;
		int n = 0;
		while (cur1.next != null) {
			n++;
			cur1 = cur1.next;
		}
		while (cur2.next != null) {
			n--;
			cur2 = cur2.next;
		}
		if (cur1 != cur2) {
			return null;
		}
		// n  :  链表1长度减去链表2长度的值
		cur1 = n > 0 ? head1 : head2; // 谁长，谁的头变成cur1
		cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2
		n = Math.abs(n);
		while (n != 0) {
			n--;
			cur1 = cur1.next;
		}
		while (cur1 != cur2) {
			cur1 = cur1.next;
			cur2 = cur2.next;
		}
		return cur1;
	}

	// 两个有环链表，返回第一个相交节点，如果不想交返回null
	public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
		Node cur1 = null;
		Node cur2 = null;
		if (loop1 == loop2) {
			cur1 = head1;
			cur2 = head2;
			int n = 0;
			while (cur1 != loop1) {
				n++;
				cur1 = cur1.next;
			}
			while (cur2 != loop2) {
				n--;
				cur2 = cur2.next;
			}
			cur1 = n > 0 ? head1 : head2;
			cur2 = cur1 == head1 ? head2 : head1;
			n = Math.abs(n);
			while (n != 0) {
				n--;
				cur1 = cur1.next;
			}
			while (cur1 != cur2) {
				cur1 = cur1.next;
				cur2 = cur2.next;
			}
			return cur1;
		} else {
			cur1 = loop1.next;
			while (cur1 != loop1) {
				if (cur1 == loop2) {
					return loop1;
				}
				cur1 = cur1.next;
			}
			return null;
		}
	}
```



## 6.6 不给单链表的头结点，只给想删除的节点，能否在链表上把该节点删掉？

 	1. 覆盖掉这个点，**把后面的值一个个的复制过来这样做不可能删除最后一个节点**，只是对值进行操作，而不是内存。



==这个题要说不行，不能做到，然后说明上面方法的问题。这个题主要是问对内存的理解==



# 7-二叉树的基本算法 

## 7.1 先序、中序、后序遍历

没啥说的比较基础，不过可以学一下栈的实现方式。



## 7.2 二叉树的层序遍历

* 其实就是广度优先遍历，用队列实现
* 可以通过设置flag变量的方式，来发现某一层的结束

看代码还是比较简单:先加左再加右

```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int v) {
			value = v;
		}
	}

	public static void level(Node head) {
		if (head == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			System.out.println(cur.value);
			if (cur.left != null) {
				queue.add(cur.left);
			}
			if (cur.right != null) {
				queue.add(cur.right);
			}
		}
	}
```

### 统计二叉树的最大宽度？

要发现每一层的开始和结束，或者说只发现某一层的开始或者结束（因为二者是连着的）

```
public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}
	# 用map实现的
	public static int maxWidthUseMap(Node head) {
		if (head == null) {
			return 0;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		// key 在 哪一层，value
		HashMap<Node, Integer> levelMap = new HashMap<>();
		levelMap.put(head, 1);
		int curLevel = 1; // 当前你正在统计哪一层的宽度
		int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少
		int max = 0;
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			int curNodeLevel = levelMap.get(cur);
			if (cur.left != null) {
				levelMap.put(cur.left, curNodeLevel + 1);
				queue.add(cur.left);
			}
			if (cur.right != null) {
				levelMap.put(cur.right, curNodeLevel + 1);
				queue.add(cur.right);
			}
			if (curNodeLevel == curLevel) {
				curLevelNodes++;
			} else {
				max = Math.max(max, curLevelNodes);
				curLevel++;
				curLevelNodes = 1;
			}
		}
		max = Math.max(max, curLevelNodes);
		return max;
	}
	# 不用map
	public static int maxWidthNoMap(Node head) {
		if (head == null) {
			return 0;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		Node curEnd = head; // 当前层，最右节点是谁
		Node nextEnd = null; // 下一层，最右节点是谁
		int max = 0;
		int curLevelNodes = 0; // 当前层的节点数
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			if (cur.left != null) {
				queue.add(cur.left);
				nextEnd = cur.left;
			}
			if (cur.right != null) {
				queue.add(cur.right);
				nextEnd = cur.right;
			}
			curLevelNodes++;
			if (cur == curEnd) {
				max = Math.max(max, curLevelNodes);
				curLevelNodes = 0;
				curEnd = nextEnd;
			}
		}
		return max;
	}
```



### 二叉树的序列化和反序列化

* 通过先序，后序，中序或者按层遍历，来实现序列化，再用相应的方法进行反序列化。关键在于 **要补全空间点** 



### 打印一颗二叉树

* 可以把二叉树变成满二叉树的形式然后再进行打印。



```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}
```

## 给二叉树中的某个节点，返回该节点的后继节点



X有右树的话，那么 **他的后序节点就是他右树的左节点**，X没有右树的话，那就往上找，直到是某个节点的左孩子，如果找到了，返回这个节点就行了。这个题的树需要有一个parent属性指向他的parent

```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;
		public Node parent;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node getSuccessorNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		} else { // 无右子树
			Node parent = node.parent;
			while (parent != null && parent.right == node) { // 当前节点是其父亲节点右孩子
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

	public static Node getLeftMost(Node node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}
```



## 打印对折纸（[剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)）

```
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	// 递归过程，来到了某一个节点，
	// i是节点的层数，N一共的层数，down == true  凹    down == false 凸
	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true);
		System.out.println(down ? "凹 " : "凸 ");
		printProcess(i + 1, N, false);
	}
```



# 8-二叉树的递归套路（树形DP问题）



1.  假设以X节点为头，**假设可以向X左树和X右树**要任何信息
2. 在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（很重要）
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5. 递归函数都返回S，每一棵子树都这么要求
6. 写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息。



## 8.1给一个二叉树的头结点，判断是否为平衡二叉树



平衡树：每一棵子树和右子树的高度差不超过1，潜台词就是1）左树平衡；2）右树平衡；3）二者高度差不超过1. 

​	对于本题就是，我要往左树和右树要两个信息，一个是是否平衡，二来是高度多少

下面代码中,process2是递归套路

```
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static boolean isBalanced1(Node head) {
		boolean[] ans = new boolean[1];
		ans[0] = true;
		process1(head, ans);
		return ans[0];
	}

	public static int process1(Node head, boolean[] ans) {
		if (!ans[0] || head == null) {
			return -1;
		}
		int leftHeight = process1(head.left, ans);
		int rightHeight = process1(head.right, ans);
		if (Math.abs(leftHeight - rightHeight) > 1) {
			ans[0] = false;
		}
		return Math.max(leftHeight, rightHeight) + 1;
	}

	public static boolean isBalanced2(Node head) {
		return process2(head).isBalaced;
	}

	// 左、右要求一样，Info 信息返回的结构体
	public static class Info {
		public boolean isBalaced;
		public int height;

		public Info(boolean b, int h) {
			isBalaced = b;
			height = h;
		}
	}

	public static Info process2(Node X) {
		if (X == null) {
			return new Info(true, 0);
		}
		Info leftInfo = process2(X.left);
		Info rightInfo = process2(X.right);
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		boolean isBalanced = true;
		if (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) > 1) {
			isBalanced = false;
		}
		return new Info(isBalanced, height);
	}
```



## 给一棵二叉树的头结点head，任何两个节点之间都存在距离，返回整棵树的最大距离

1) 最大距离与X节点无关，那么X节点就是他子树上的最大距离。
2) 最大距离与X有关，那么只有一种可能性，X左树上离他最远的点到他右树的离他最远的点，就是左树的高度+1+右树上最高的点。

```
	public static class Info {
		public int maxDistance;
		public int height;

		public Info(int dis, int h) {
			maxDistance = dis;
			height = h;
		}
	}

	public static Info process(Node X) {
		if (X == null) {
			return new Info(0, 0);
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		int maxDistance = Math.max(
				Math.max(leftInfo.maxDistance, rightInfo.maxDistance),
				leftInfo.height + rightInfo.height + 1);
		return new Info(maxDistance, height);
	}
```



## 给一个二叉树的头结点head，返回这棵二叉树最大的二叉搜搜子树的头节点

一棵树里未必都是搜索二叉树，我现在要的就是最大的二叉搜索子树的，头结点。



1. 最大二叉树与X无关，那么X就是他左子树头结点或者右子树头结点最大搜索树的那个
2. 如果与X有关，那么X就是他左树或者右树，如果他满足左子树最大的小于X，右子树最小的大于X，那么就是X这个节点。



```
	// 任何子树
	public static class Info {
		public boolean isAllBST;
		public int maxSubBSTSize;
		public int min;
		public int max;

		public Info(boolean is, int size, int mi, int ma) {
			isAllBST = is;
			maxSubBSTSize = size;
			min = mi;
			max = ma;
		}
	}
	
	
	
	
	public static Info process(Node X) {
		if(X == null) {
			return null;
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		
		
		
		int min = X.value;
		int max = X.value;
		
		if(leftInfo != null) {
			min = Math.min(min, leftInfo.min);
			max = Math.max(max, leftInfo.max);
		}
		if(rightInfo != null) {
			min = Math.min(min, rightInfo.min);
			max = Math.max(max, rightInfo.max);
		}
		
		
		
		
		
		

		int maxSubBSTSize = 0;
		if(leftInfo != null) {
			maxSubBSTSize = leftInfo.maxSubBSTSize;
		}
		if(rightInfo !=null) {
			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
		}
		boolean isAllBST = false;
		
		
		if(
				// 左树整体需要是搜索二叉树
				(  leftInfo == null ? true : leftInfo.isAllBST    )
				&&
				(  rightInfo == null ? true : rightInfo.isAllBST    )
				&&
				// 左树最大值<x
				(leftInfo == null ? true : leftInfo.max < X.value)
				&&
				(rightInfo == null ? true : rightInfo.min > X.value)
				
				
				) {
			
			maxSubBSTSize = 
					(leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
					+
					(rightInfo == null ? 0 : rightInfo.maxSubBSTSize)
					+
					1;
					isAllBST = true;
			
			
		}


		
		
		return new Info(isAllBST, maxSubBSTSize, min, max);
	}
```







## 派对的最大快乐值（多叉树，先跳过了不学这个吧）

 ![image-20220805101208060](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220805101208060-16596655298321.png)



牛客有这个题。

## 判断是不是满二叉树

```java
	public static boolean isFull2(Node head) {
		if (head == null) {
			return true;
		}
		Info all = process(head);
		return (1 << all.height) - 1 == all.nodes;
	}

	public static class Info {
		public int height;
		public int nodes;

		public Info(int h, int n) {
			height = h;
			nodes = n;
		}
	}

	public static Info process(Node head) {
		if (head == null) {
			return new Info(0, 0);
		}
		Info leftInfo = process(head.left);
		Info rightInfo = process(head.right);
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		int nodes = leftInfo.nodes + rightInfo.nodes + 1;
		return new Info(height, nodes);
	}
```



## 给二叉树的头结点head，返回这棵二叉树中最大的二叉搜索子树的头结点 

1. 最大二叉搜索子树与X无关：

2. 与X有关

```
		public static Node maxSubBSTHead2(Node head) {
		if (head == null) {
			return null;
		}
		return process(head).maxSubBSTHead;
	}
	// 每一棵子树
	public static class Info {
		public Node maxSubBSTHead; // 这个变量指向最大的搜素二叉树的值，直接返回它就行了
		public int maxSubBSTSize;
		public int min;
		public int max;

		public Info(Node h, int size, int mi, int ma) {
			maxSubBSTHead = h;
			maxSubBSTSize = size;
			min = mi;
			max = ma;
		}
	}

	public static Info process(Node X) {
		if (X == null) {
			return null;
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		int min = X.value;
		int max = X.value;
		Node maxSubBSTHead = null;
		int maxSubBSTSize = 0;
		if (leftInfo != null) {
			min = Math.min(min, leftInfo.min);
			max = Math.max(max, leftInfo.max);
			maxSubBSTHead = leftInfo.maxSubBSTHead;
			maxSubBSTSize = leftInfo.maxSubBSTSize;
		}
		if (rightInfo != null) {
			min = Math.min(min, rightInfo.min);
			max = Math.max(max, rightInfo.max);
			if (rightInfo.maxSubBSTSize > maxSubBSTSize) {
				maxSubBSTHead = rightInfo.maxSubBSTHead;
				maxSubBSTSize = rightInfo.maxSubBSTSize;
			}
		}
		if ((leftInfo == null ? true : (leftInfo.maxSubBSTHead == X.left && leftInfo.max < X.value))
				&& (rightInfo == null ? true : (rightInfo.maxSubBSTHead == X.right && rightInfo.min > X.value))) {
			maxSubBSTHead = X;
			maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
					+ (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1;
		}
		return new Info(maxSubBSTHead, maxSubBSTSize, min, max);
	}
```



## 给一个二叉树的头结点head，返回这棵树是否为完全二叉树

1. 宽度优先遍历的时候，判断任何结点如果有右孩子而无左孩子，那他一定不是完全二叉树。否则继续判断
2. 一旦遇到左右孩子不双全，后续遇到的所有结点必须是叶结点。

对于递归的实现方式：

1. 第一种情况，满二叉树，没有缺口
2. 第二种情况，有缺口，缺口在左树上左叶，这种情况左树的高度比右树的高度大1个，在都是完全二叉树的前提下。
3. 第三种情况，有缺口，左树占满了，右树没，这种情况左树是满的，比右树高度高1个。
4. 第四种情况，有缺口，在右树上。两个树一样高

下图的2,3,4表示第二，三，四种情况缺失的位置（比如第三种情况，那么他前面的2是已经有了，3,4没）

![image-20220805144752830](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220805144752830-16596820737101.png)



```java
	
// 方法1，宽度优先遍历
public static boolean isCBT1(Node head) {
		if (head == null) {
			return true;
		}
		LinkedList<Node> queue = new LinkedList<>();
		// 是否遇到过左右两个孩子不双全的节点
		boolean leaf = false;
		Node l = null;
		Node r = null;
		queue.add(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			l = head.left;
			r = head.right;
			if (
			// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点
			(leaf && (l != null || r != null)) || (l == null && r != null)

			) {
				return false;
			}
			if (l != null) {
				queue.add(l);
			}
			if (r != null) {
				queue.add(r);
			}
			if (l == null || r == null) {
				leaf = true;
			}
		}
		return true;
	}

====================================================================================
    			方法2
=== ================================================================================
// 对每一棵子树，是否是满二叉树、是否是完全二叉树、高度
	public static class Info {
		public boolean isFull;
		public boolean isCBT;
		public int height;

		public Info(boolean full, boolean cbt, int h) {
			isFull = full;
			isCBT = cbt;
			height = h;
		}
	}

	public static Info process(Node X) {
		if (X == null) {
			return new Info(true, true, 0);
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		
		
		
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		
		
		boolean isFull = leftInfo.isFull 
				&& 
				rightInfo.isFull 
				&& leftInfo.height == rightInfo.height;
		
		
		boolean isCBT = false;
		if (isFull) {
			   = true;
		} else { // 以x为头整棵树，不满
			if (leftInfo.isCBT && rightInfo.isCBT) {
				
				//条件2
				if (leftInfo.isCBT 
						&& rightInfo.isFull 
						&& leftInfo.height == rightInfo.height + 1) {
					isCBT = true;
				}
                //条件3
				if (leftInfo.isFull 
						&& 
						rightInfo.isFull 
						&& leftInfo.height == rightInfo.height + 1) {
					isCBT = true;
				}
                //条件4
				if (leftInfo.isFull 
						&& rightInfo.isCBT && leftInfo.height == rightInfo.height) {
					isCBT = true;
				}
				
				
			}
		}
		return new Info(isFull, isCBT, height);
	}
```



## 给一个二叉树的头结点head，和另外两个节点a和b，返回a和b的最低公共祖先（难）

方法1，就是哈希表的方法，首先遍历一遍做一个map，然后对于节点a往上跳，得到a的全部祖先，然后b往上跳，并比较是不是在a的全部祖先里面，如果是的话就跳出就行了。

```java
	public static Node lowestAncestor1(Node head, Node o1, Node o2) {
		if (head == null) {
			return null;
		}
		// key的父节点是value
		HashMap<Node, Node> parentMap = new HashMap<>();
		parentMap.put(head, null);
		fillParentMap(head, parentMap);
		HashSet<Node> o1Set = new HashSet<>();
		Node cur = o1;
		o1Set.add(cur);
		while (parentMap.get(cur) != null) {
			cur = parentMap.get(cur);
			o1Set.add(cur);
		}
		cur = o2;
		while (!o1Set.contains(cur)) {
			cur = parentMap.get(cur);
		}
		return cur;
	}

	public static void fillParentMap(Node head, HashMap<Node, Node> parentMap) {
		if (head.left != null) {
			parentMap.put(head.left, head);
			fillParentMap(head.left, parentMap);
		}
		if (head.right != null) {
			parentMap.put(head.right, head);
			fillParentMap(head.right, parentMap);
		}
	}
```



方法2，用递归的方式去做。

有几种情况：

1. a,b都不在X头结点的数上
2. a,b只有一个在X头结点的树上
3. a,b都在x为头的树上
   1. 左右各一个
   2. 都在左
   3. 都在右树
   4. x是a,b在左树，x是b，a在右树。。。

```
public static Node lowestAncestor2(Node head, Node o1, Node o2) {
		return process(head, o1, o2).ans;
	}

	// 任何子树，返回三个信息
	public static class Info {
		public Node ans; // 交汇点
		public boolean findO1;//发现没发现过o1
		public boolean findO2;//发现没发现过o2

		public Info(Node a, boolean f1, boolean f2) {
			ans = a;
			findO1 = f1;
			findO2 = f2;
		}
	}

	public static Info process(Node X, Node o1, Node o2) {
		if (X == null) {
			return new Info(null, false, false);
		}
		Info leftInfo = process(X.left, o1, o2);
		Info rightInfo = process(X.right, o1, o2);
		boolean findO1 = X == o1 || leftInfo.findO1 || rightInfo.findO1;
		boolean findO2 = X == o2 || leftInfo.findO2 || rightInfo.findO2;
		// 	O1和O2最初的交汇点在哪？
		// 1) 在左树上已经提前交汇了
		// 2) 在右树上已经提前交汇了
		// 3) 没有在左树或者右树上提前交汇，O1  O2 全了
		// 4) 
		Node ans = null;
		if (leftInfo.ans != null) {
			ans = leftInfo.ans;
		}
		if (rightInfo.ans != null) {
			ans = rightInfo.ans;
		}
		if (ans == null) {
			if (findO1 && findO2) {
				ans = X;
			}
		}
		return new Info(ans, findO1, findO2);
	}
```



# 9-贪心算法(有点拼智商。。哈哈)

==小根堆，大根堆，排序是贪心常见的策略==

求解过程：

1. 分析业务。
2. 根据业务逻辑找到不同的贪心策略。
3. 对于**能举出反例的策略**直接跳过，不能举出反例的策略要证明有效性，这个往往是特别困难的，要求数学能力很高且不具有统一的技巧性。
4. 贪心算法的解题套路：实现一个不依靠贪心策略的解法X，可以用最暴力的尝试。
5. ==一般解题，首先按照暴力得到一个解法，然后再通过对数器来尝试，自己哪个解法更加好一些==。

贪心的地位：

* 在笔试中出现贪心的概率很高，60%,70%，面试中出现的比重低于20%；因为笔试是为了考察，一般过两道就会进入面试阶段。面试是为了区分。所以对于贪心这种要么会，要么不会的题，一般面试不会考，没法区分。



## 9.1 给定一个由字符串组成的数组strs，把所有的字符串拼接起来，并返回所有可能中字典序最小的结果

字典序：如果两个字符串长度一样，那就每一位进行比较；否则把字符串短的那个，后面补一个0类似的，进行比较.比如ac < b；先比高位，再比低位。java的compareTo方法就是在比较字典序。

解题方法：排序的传递性。我需要保证，我排好序后，任意一个序列中前面的a和序列后面的b进行拼接，小于后面的b拼接前面的a。

下面代码里，方法1是全排列，方法2 是贪心的方法。

```java
	public static String lowestString1(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		ArrayList<String> all = new ArrayList<>();
		HashSet<Integer> use = new HashSet<>();
		process(strs, use, "", all);
		String lowest = all.get(0);
		for (int i = 1; i < all.size(); i++) {
			if (all.get(i).compareTo(lowest) < 0) {
				lowest = all.get(i);
			}
		}
		return lowest;
	}

	// strs里放着所有的字符串
	// 已经使用过的字符串的下标，在use里登记了，不要再使用了
	// 之前使用过的字符串，拼接成了-> path
	// 用all收集所有可能的拼接结果
	public static void process(String[] strs, 
			HashSet<Integer> use, 
			String path, 
			ArrayList<String> all) {
		if (use.size() == strs.length) {
			all.add(path);
		} else {
			for (int i = 0; i < strs.length; i++) {
				if (!use.contains(i)) {
					use.add(i);
					process(strs, use, path + strs[i], all);
					use.remove(i);
				}
			}
		}
	}

	public static class MyComparator implements Comparator<String> {
		@Override
		public int compare(String a, String b) {
			return (a + b).compareTo(b + a);
		}
	}

	public static String lowestString2(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		Arrays.sort(strs, new MyComparator());
		String res = "";
		for (int i = 0; i < strs.length; i++) {
			res += strs[i];
		}
		return res;
	}
```



## 9.3 [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)

```java
	public static class Program {
		public int start;
		public int end;

		public Program(int start, int end) {
			this.start = start;
			this.end = end;
		}
	}

	public static int bestArrange1(Program[] programs) {
		if (programs == null || programs.length == 0) {
			return 0;
		}
		return process(programs, 0, 0);
	}

	// 还剩什么会议都放在programs里
	// done 之前已经安排了多少会议，数量
	// timeLine目前来到的时间点是什么
	
	// 目前来到timeLine的时间点，已经安排了done多的会议，剩下的会议programs可以自由安排
	// 返回能安排的最多会议数量
	public static int process(Program[] programs, int done, int timeLine) {
		if (programs.length == 0) {
			return done;
		}
		// 还有会议可以选择
		int max = done;
		// 当前安排的会议是什么会，每一个都枚举
		for (int i = 0; i < programs.length; i++) {
			if (programs[i].start >= timeLine) {
				Program[] next = copyButExcept(programs, i);
				max = Math.max(max, process(next, done + 1, programs[i].end));
			}
		}
		return max;
	}
	//下面这个函数是把第i号会议剔除，表示这个会议被安排了。
	public static Program[] copyButExcept(Program[] programs, int i) {
		Program[] ans = new Program[programs.length - 1];
		int index = 0;
		for (int k = 0; k < programs.length; k++) {
			if (k != i) {
				ans[index++] = programs[k];
			}
		}
		return ans;
	}
//下面的方法是贪心的方法。
	public static int bestArrange2(Program[] programs) {
		Arrays.sort(programs, new ProgramComparator());
		int timeLine = 0;
		int result = 0;
		for (int i = 0; i < programs.length; i++) {
			if (timeLine <= programs[i].start) {
				result++;
				timeLine = programs[i].end;
			}
		}
		return result;
	}

	public static class ProgramComparator implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o1.end - o2.end;
		}

	}
```



## 放灯



给定一个字符串str，只由×'和∵'两种字符构成。‘×'表示墙，不能放灯，也不需要点亮
"∵'表示居民点，可以放灯，需要点亮
如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

```java
	//暴力解
	public static int minLight1(String road) {
		if (road == null || road.length() == 0) {
			return 0;
		}
		return process(road.toCharArray(), 0, new HashSet<>());
	}

	// str[index....]位置，自由选择放灯还是不放灯
	// str[0..index-1]位置呢？已经做完决定了，那些放了灯的位置，存在lights里
	// 要求选出能照亮所有.的方案，并且在这些有效的方案中，返回最少需要几个灯
	public static int process(char[] str, int index, HashSet<Integer> lights) {
		if (index == str.length) { // 结束的时候
            // for循环验证方案
			for (int i = 0; i < str.length; i++) {
				if (str[i] != 'X') { // 当前位置是点的话
					if (!lights.contains(i - 1) 
							&& !lights.contains(i) 
							&& !lights.contains(i + 1)) {
						return Integer.MAX_VALUE;//表示是无效解。
					}
				}
			}
			return lights.size();//否则就是有效的解.
		} else { // str还没结束
			// i   X  .
			int no = process(str, index + 1, lights);//no的意思是彻底没有把i位置放灯，返回后续的好的结果。
			int yes = Integer.MAX_VALUE;
			if (str[index] == '.') {
				lights.add(index);//只有当前位置是点，才可以放灯
				yes = process(str, index + 1, lights);
				lights.remove(index);//恢复现场
			}
			return Math.min(no, yes);
		}
	}
	//贪心解
	// i位置不会被之前的状态影响；
	// 
	public static int minLight2(String road) {
		char[] str = road.toCharArray();
		int index = 0;
		int light = 0;
		while (index < str.length) {
			if (str[index] == 'X') {
                //如果当前位置是X,那么不用做决定。
				index++;
			} else { // i -> .
                //i 位置是点，那么不管是'.X.','.XX','...'等情况，当前都需要放灯。
				light++;
				if (index + 1 == str.length) {
					break;
				} else {
					if (str[index + 1] == 'X') {'.X'
						index = index + 2;
					} else {'..'
						index = index + 3;
					}
				}
			}
		}
		return light;
	}
```

## 9.2分金条花费最少的铜板

—块金条切成两半，是需要花费和长度数值一样的铜板的。

比如长度为20的金条，不管怎么切，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板?

例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。

如果先把长度60的金条分成10和50，花费60;再把长度50的金条分成20和30，花费50;—共花费110铜板。但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20，花费30;—共花费90铜板。输入一个数组，返回分割的最小代价。

```java
	public static int lessMoney1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		return process(arr, 0);
	}

	public static int process(int[] arr, int pre) {
		if (arr.length == 1) {
			return pre;
		}
		int ans = Integer.MAX_VALUE;
		for (int i = 0; i < arr.length; i++) {
			for (int j = i + 1; j < arr.length; j++) {
				ans = Math.min(ans, process(copyAndMergeTwo(arr, i, j), pre + arr[i] + arr[j]));
			}
		}
		return ans;
	}

	public static int[] copyAndMergeTwo(int[] arr, int i, int j) {
		int[] ans = new int[arr.length - 1];
		int ansi = 0;
		for (int arri = 0; arri < arr.length; arri++) {
			if (arri != i && arri != j) {
				ans[ansi++] = arr[arri];
			}
		}
		ans[ansi] = arr[i] + arr[j];
		return ans;
	}

	public static int lessMoney2(int[] arr) {
        //小根堆弹出两个然后合成一个，给他扔回去。然后此时所有的叶结点的和就是结果，其实就是哈夫曼树。
		PriorityQueue<Integer> pQ = new PriorityQueue<>();
		for (int i = 0; i < arr.length; i++) {
			pQ.add(arr[i]);
		}
		int sum = 0;
		int cur = 0;
		while (pQ.size() > 1) {
			cur = pQ.poll() + pQ.poll();
			sum += cur;
			pQ.add(cur);
		}
		return sum;
	}
```

## 9.3[502. IPO](https://leetcode.cn/problems/ipo/)

输入:正数数组costs、正数数组profits、正数K、正数M
costs[i]表示i号项目的花费
profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)°K表示你只能串行的最多做k个项目
M表示你初始的资金
说明:每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。输出:你最后获得的最大钱数。

==解题思路，根据花费建立小根堆（锁定的花费），然后再建立一个大根堆（解锁的项目），按照利润排序。==根据小根堆中当前资金可以覆盖的项目弹出，放到大根堆中。

```java
	public static int findMaximizedCapital(int K, int W, int[] Profits, int[] Capital) {
		PriorityQueue<Program> minCostQ = new PriorityQueue<>(new MinCostComparator());
		PriorityQueue<Program> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
		for (int i = 0; i < Profits.length; i++) {
			minCostQ.add(new Program(Profits[i], Capital[i]));
		}
		for (int i = 0; i < K; i++) {
            //while循环是解锁过程.
			while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
				maxProfitQ.add(minCostQ.poll());
			}
			if (maxProfitQ.isEmpty()) {
                //发现无项目可做了现在。
				return W;
			}
			W += maxProfitQ.poll().p;
		}
		return W;
	}

	public static class Program {
		public int p;
		public int c;

		public Program(int p, int c) {
			this.p = p;
			this.c = c;
		}
	}

	public static class MinCostComparator implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o1.c - o2.c;
		}

	}

	public static class MaxProfitComparator implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o2.p - o1.p;
		}

	}
```





# 10 并查集



1. 有若干个样本a、b、c、d...类型假设是V
2. 在并查集中一开始认为每个样本都在单独的集合里
3. 用户可以在任何时候调用如下两个方法：
   1. bool isSameSet(V x,V y):查询样本x和样本y是否属于一个集合
   2. union(V x,V y):把x和y各自所在的集合的所有样本合并成一个集合
4. isSameSet和union方法的代价越低越好。（时间复杂度是O(1)）



isSameSet通过向上查的方式来找到他们样本对应的头；union方法则通过把小集合的代表大挂到大集合的代表点上。

```java
public static class Node<V> {
		V value;

		public Node(V v) {
			value = v;
		}
	}

	public static class UnionSet<V> {
		public HashMap<V, Node<V>> nodes;
		public HashMap<Node<V>, Node<V>> parents;
		public HashMap<Node<V>, Integer> sizeMap;

		public UnionSet(List<V> values) {
			for (V cur : values) {
				Node<V> node = new Node<>(cur);
				nodes.put(cur, node);
				parents.put(node, node);
				sizeMap.put(node, 1);//初始化的过程时，每个点的代表点都是自己。
			}
		}

		// 从点cur开始，一直往上找，找到不能再往上的代表点，返回
		public Node<V> findFather(Node<V> cur) {
			Stack<Node<V>> path = new Stack<>(); //记下沿途所有的节点
			while (cur != parents.get(cur)) {
				path.push(cur);
				cur = parents.get(cur);
			}
			// cur头节点
			while (!path.isEmpty()) {//把沿途所有节点的父变为最高的父。
                //这里是相当于做了一个优化，因为不这么优化的话，可能会让树变得很深，这样会导致时间复杂度高，这里的优化把
                //深的变为了扁平的一个结构。
				parents.put(path.pop(), cur);
			}
			return cur;
		}

		public boolean isSameSet(V a, V b) {
			if (!nodes.containsKey(a) || !nodes.containsKey(b)) {
				return false;
			}
			return findFather(nodes.get(a)) == findFather(nodes.get(b));
		}

		public void union(V a, V b) {
			if (!nodes.containsKey(a) || !nodes.containsKey(b)) {
				return;
			}
			Node<V> aHead = findFather(nodes.get(a));
			Node<V> bHead = findFather(nodes.get(b));
			if (aHead != bHead) {
				int aSetSize = sizeMap.get(aHead);
				int bSetSize = sizeMap.get(bHead);
				Node<V> big = aSetSize >= bSetSize ? aHead : bHead;
				Node<V> small = big == aHead ? bHead : aHead;
				parents.put(small, big);
				sizeMap.put(big, aSetSize + bSetSize);
				sizeMap.remove(small);
			}
		}
	}
```







## 10.1合并用户

```java
	public static class Node<V> {
		V value;

		public Node(V v) {
			value = v;
		}
	}

	public static class UnionSet<V> {
		public HashMap<V, Node<V>> nodes;
		public HashMap<Node<V>, Node<V>> parents;
		public HashMap<Node<V>, Integer> sizeMap;

		public UnionSet(List<V> values) {
			for (V cur : values) {
				Node<V> node = new Node<>(cur);
				nodes.put(cur, node);
				parents.put(node, node);
				sizeMap.put(node, 1);
			}
		}

		// 从点cur开始，一直往上找，找到不能再往上的代表点，返回
		public Node<V> findFather(Node<V> cur) {
			Stack<Node<V>> path = new Stack<>();
			while (cur != parents.get(cur)) {
				path.push(cur);
				cur = parents.get(cur);
			}
			// cur头节点
			while (!path.isEmpty()) {
				parents.put(path.pop(), cur);
			}
			return cur;
		}

		public boolean isSameSet(V a, V b) {
			if (!nodes.containsKey(a) || !nodes.containsKey(b)) {
				return false;
			}
			return findFather(nodes.get(a)) == findFather(nodes.get(b));
		}

		public void union(V a, V b) {
			if (!nodes.containsKey(a) || !nodes.containsKey(b)) {
				return;
			}
			Node<V> aHead = findFather(nodes.get(a));
			Node<V> bHead = findFather(nodes.get(b));
			if (aHead != bHead) {
				int aSetSize = sizeMap.get(aHead);
				int bSetSize = sizeMap.get(bHead);
				Node<V> big = aSetSize >= bSetSize ? aHead : bHead;
				Node<V> small = big == aHead ? bHead : aHead;
				parents.put(small, big);
				sizeMap.put(big, aSetSize + bSetSize);
				sizeMap.remove(small);
			}
		}
		
		
		public int getSetNum() {
			return sizeMap.size();
		}
		
	}

	public static class User {
		public String a;
		public String b;
		public String c;

		public User(String a, String b, String c) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

	}

	// (1,10,13) (2,10,37) (400,500,37)
	// 如果两个user，a字段一样、或者b字段一样、或者c字段一样，就认为是一个人
	// 请合并users，返回合并之后的用户数量
	public static int mergeUsers(List<User> users) {
		UnionSet<User> unionFind = new UnionSet<>(users);
		HashMap<String, User> mapA = new HashMap<>();
		HashMap<String, User> mapB = new HashMap<>();
		HashMap<String, User> mapC = new HashMap<>();
		for(User user : users) {
			if(mapA.containsKey(user.a)) {
				unionFind.union(user, mapA.get(user.a));
			}else {
				mapA.put(user.a, user);
			}
			if(mapB.containsKey(user.b)) {
				unionFind.union(user, mapB.get(user.b));
			}else {
				mapB.put(user.b, user);
			}
			if(mapC.containsKey(user.c)) {
				unionFind.union(user, mapC.get(user.c));
			}else {
				mapC.put(user.c, user);
			}
		}
		// 向并查集询问，合并之后，还有多少个集合？
		return unionFind.getSetNum();
	}
```





## 并查集的应用

* 解决两大块区域的合并问题
* 常用在图等领域中



# 10 图（笔试中数据结构比较复杂）

图不难，最难的在于不要把所有算法在图的数据结构上来一遍，因为图的表达形式有很多种，不止邻接表，邻接矩阵。

==可以通过写一个接口转换类，不管这个题是给的什么样的数据结构，我都给他转换为自己常用的一种结构的形式==

```
package class10;

import java.util.ArrayList;

// 点结构的描述  A  0
public class Node {
	public int value;
	public int in;
	public int out;
	public ArrayList<Node> nexts;
	public ArrayList<Edge> edges;

	public Node(int value) {
		this.value = value;
		in = 0; // 入度
		out = 0;//出度
		nexts = new ArrayList<>();//直接邻居,由该点出发能到的点。out是nexts的size
		edges = new ArrayList<>();//边
	}
}

```



下面的是边，有向图的：

```
package class10;

public class Edge {
	public int weight;
	public Node from;
	public Node to;

	public Edge(int weight, Node from, Node to) {
		this.weight = weight;
		this.from = from;
		this.to = to;
	}

}

```

图就更简单了，就是点集和边集

```
public class Graph {
	public HashMap<Integer, Node> nodes;
	public HashSet<Edge> edges;
	
	public Graph() {
		nodes = new HashMap<>();
		edges = new HashSet<>();
	}
}
```



对于输入为[权重，from节点上面的值，to节点上面的值]生成图的代码为：

```
public class GraphGenerator {

	// matrix 所有的边
	// N*3 的矩阵
	// [weight, from节点上面的值，to节点上面的值]
	public static Graph createGraph(Integer[][] matrix) {
		Graph graph = new Graph();
		for (int i = 0; i < matrix.length; i++) { 
			// matrix[0][0], matrix[0][1]  matrix[0][2]
			Integer weight = matrix[i][0];
			Integer from = matrix[i][1];
			Integer to = matrix[i][2];
			if (!graph.nodes.containsKey(from)) {
				graph.nodes.put(from, new Node(from));
			}
			if (!graph.nodes.containsKey(to)) {
				graph.nodes.put(to, new Node(to));
			}
			Node fromNode = graph.nodes.get(from);
			Node toNode = graph.nodes.get(to);
			Edge newEdge = new Edge(weight, fromNode, toNode);
			fromNode.nexts.add(toNode);
			fromNode.out++;
			toNode.in++;
			fromNode.edges.add(newEdge);
			graph.edges.add(newEdge);
		}
		return graph;
	}

}

```

==相同的，也可以对上面的代码稍微进行修改，来把邻接矩阵，邻接表该为自己的图==

图的面试题如何搞定
图的算法都不算难，只不过coding的代价比较高
1)先用自己最熟练的方式,实现图结构的表达
2)在自己熟悉的结构上，实现所有常用的图算法作为模板
3）把面试题提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可



## 图的宽度优先遍历和深度优先遍历

### 宽度优先遍历

1. 利用队列实现
2. 从源节点开始依次按照宽度进队列，然后弹出
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
4. 直到队列变空



==与二叉树的BFS不同，这里虽然也用队列，但一定要用set，因为图可能有环==1

```java
public class Code02_BFS {

	// 从node出发，进行宽度优先遍历
	public static void bfs(Node node) {
		if (node == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		HashSet<Node> set = new HashSet<>();
		queue.add(node);
		set.add(node);
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			System.out.println(cur.value);
			for (Node next : cur.nexts) {
				if (!set.contains(next)) {
					set.add(next);
					queue.add(next);
				}
			}
		}
	}

}
```









### 深度优先遍历

1. 利用栈实现
2. 从源节点开始把节点按照深度放入栈中，然后弹出
3. 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
4. 直到栈变空

==栈里存放的是当前遍历的这个路径==

```java
public class Code02_DFS {

	public static void dfs(Node node) {
		if (node == null) {
			return;
		}
		Stack<Node> stack = new Stack<>();
		HashSet<Node> set = new HashSet<>();
		stack.add(node);
		set.add(node);
		System.out.println(node.value);
		while (!stack.isEmpty()) {
			Node cur = stack.pop();
			for (Node next : cur.nexts) {
				if (!set.contains(next)) {
					stack.push(cur);
					stack.push(next);
					set.add(next);
					System.out.println(next.value);
					break;
				}
			}
		}
	}

}
```

## 拓扑排序



1. 在图中找到所有入度为0的点输出
2. 把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始
3. 图的所有点都被删除后，依次输出的顺序就是拓扑排序
4. 要求:==有向图且其中没有环,所以说无向图肯定也不行==
5. 应用:事件安排、编译顺序

```

public class Code03_TopologySort {

	// directed graph and no loop
	public static List<Node> sortedTopology(Graph graph) {
		// key：某一个node
		// value：剩余的入度
		HashMap<Node, Integer> inMap = new HashMap<>();
		// 剩余入度为0的点，才能进这个队列
		Queue<Node> zeroInQueue = new LinkedList<>();
		
		
		for (Node node : graph.nodes.values()) {
			inMap.put(node, node.in);
			if (node.in == 0) {
				zeroInQueue.add(node);
			}
		}
		// 拓扑排序的结果，依次加入result
		List<Node> result = new ArrayList<>();
		while (!zeroInQueue.isEmpty()) {
			Node cur = zeroInQueue.poll();
			result.add(cur);
			for (Node next : cur.nexts) {
				inMap.put(next, inMap.get(next) - 1);
				if (inMap.get(next) == 0) {
					zeroInQueue.add(next);
				}
			}
		}
		return result;
	}
}
```

## 最小生成树算法之Kruskal

不破坏连通性下，哪种方案使权值和最小。



1. 总是从权值最小的边开始考虑，依次考察权值依次变大的边（先对边根据权值从小到大排序）

2. 当前的边要么进入最小生成树的集合，要么丢弃

3. 如果当前的边进入最小生成树的集合中不会形成环，就要当前边

4. 如果当前的边进入最小生成树的集合中会形成环，就不要当前边

5. 考察完所有边之后，最小生成树的集合也得到了

 **并查集做这个题很好的。**

```java
//undirected graph only
public class Code04_Kruskal {

	// Union-Find Set
	public static class UnionFind {
		// key 某一个节点， value key节点往上的节点
		private HashMap<Node, Node> fatherMap;
		// key 某一个集合的代表节点, value key所在集合的节点个数
		private HashMap<Node, Integer> sizeMap;

		public UnionFind() {
			fatherMap = new HashMap<Node, Node>();
			sizeMap = new HashMap<Node, Integer>();
		}
		
		public void makeSets(Collection<Node> nodes) {
			fatherMap.clear();
			sizeMap.clear();
			for (Node node : nodes) {
				fatherMap.put(node, node);
				sizeMap.put(node, 1);
			}
		}

		private Node findFather(Node n) {
			Stack<Node> path = new Stack<>();
			while(n != fatherMap.get(n)) {
				path.add(n);
				n = fatherMap.get(n);
			}
			while(!path.isEmpty()) {
				fatherMap.put(path.pop(), n);
			}
			return n;
		}

		public boolean isSameSet(Node a, Node b) {
			return findFather(a) == findFather(b);
		}

		public void union(Node a, Node b) {
			if (a == null || b == null) {
				return;
			}
			Node aDai = findFather(a);
			Node bDai = findFather(b);
			if (aDai != bDai) {
				int aSetSize = sizeMap.get(aDai);
				int bSetSize = sizeMap.get(bDai);
				if (aSetSize <= bSetSize) {
					fatherMap.put(aDai, bDai);
					sizeMap.put(bDai, aSetSize + bSetSize);
					sizeMap.remove(aDai);
				} else {
					fatherMap.put(bDai, aDai);
					sizeMap.put(aDai, aSetSize + bSetSize);
					sizeMap.remove(bDai);
				}
			}
		}
	}
	

	public static class EdgeComparator implements Comparator<Edge> {

		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}

	}

	public static Set<Edge> kruskalMST(Graph graph) {
		UnionFind unionFind = new UnionFind();
		unionFind.makeSets(graph.nodes.values());
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
		for (Edge edge : graph.edges) { // M 条边
			priorityQueue.add(edge);  // O(logM)
		}
		Set<Edge> result = new HashSet<>();
		while (!priorityQueue.isEmpty()) { // M 条边
			Edge edge = priorityQueue.poll(); // O(logM)
			if (!unionFind.isSameSet(edge.from, edge.to)) { // O(1)
				result.add(edge);
				unionFind.union(edge.from, edge.to);
			}
		}
		return result;
	}
}

```

## 最小生成树算法之Prim

这个是生成无向图的最小生成树,P算法不需要并查集，只需要正常的一个set就够了，因为他是一个一个进的，不是K算法的那种两个集合的合并。

```
// undirected graph only
public class Code05_Prim {

	public static class EdgeComparator implements Comparator<Edge> {

		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}

	}

	public static Set<Edge> primMST(Graph graph) {
		// 解锁的边进入小根堆
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());

		
		HashSet<Node> nodeSet = new HashSet<>();// 哪些点被解锁出来了，在set里面，就说明被锁了。
		Set<Edge> result = new HashSet<>(); // 依次挑选的的边在result里
		for (Node node : graph.nodes.values()) { // 随便挑了一个点,for循环其实没什么必要，但是有关键的一点，就是可以防止森林的出现。
			// node 是开始点
			if (!nodeSet.contains(node)) {
				nodeSet.add(node);
				for (Edge edge : node.edges) { // 由一个点，解锁所有相连的边
					priorityQueue.add(edge);
				}
				while (!priorityQueue.isEmpty()) {
					Edge edge = priorityQueue.poll(); // 弹出解锁的边中，最小的边
					Node toNode = edge.to; // 可能的一个新的点
					if (!nodeSet.contains(toNode)) { // 不含有的时候，就是新的点
						nodeSet.add(toNode);
						result.add(edge);
						for (Edge nextEdge : toNode.edges) {
							priorityQueue.add(nextEdge);
						}
					}
				}
			}
			// break;
		}
		return result;
	}

	// 请保证graph是连通图
	// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路
	// 返回值是最小连通图的路径之和
	public static int prim(int[][] graph) {
		int size = graph.length;
		int[] distances = new int[size];
		boolean[] visit = new boolean[size];
		visit[0] = true;
		for (int i = 0; i < size; i++) {
			distances[i] = graph[0][i];
		}
		int sum = 0;
		for (int i = 1; i < size; i++) {
			int minPath = Integer.MAX_VALUE;
			int minIndex = -1;
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] < minPath) {
					minPath = distances[j];
					minIndex = j;
				}
			}
			if (minIndex == -1) {
				return sum;
			}
			visit[minIndex] = true;
			sum += minPath;
			for (int j = 0; j < size; j++) {
				if (!visit[j] && distances[j] > graph[minIndex][j]) {
					distances[j] = graph[minIndex][j];
				}
			}
		}
		return sum;
	}

	public static void main(String[] args) {
		System.out.println("hello world!");
	}

}

```

## 迪杰斯特拉算法

迪杰斯特拉算法有个要求，不能有负数的边。改进的迪杰斯特拉算法通过使用堆进行了优化，但是要自己实现堆。。

```java
// no negative weight
public class Code06_Dijkstra {

	public static HashMap<Node, Integer> dijkstra1(Node from) {
		// 从head出发到所有点的最小距离
		// key : 从head出发到达key
		// value : 从head出发到达key的最小距离
		// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷
		HashMap<Node, Integer> distanceMap = new HashMap<>();
		distanceMap.put(from, 0);
		// 已经求过距离的节点，存在selectedNodes中，以后再也不碰
		HashSet<Node> selectedNodes = new HashSet<>();
		// from 0
		Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		while (minNode != null) {
			int distance = distanceMap.get(minNode);
			for (Edge edge : minNode.edges) {
				Node toNode = edge.to;
				if (!distanceMap.containsKey(toNode)) {
					distanceMap.put(toNode, distance + edge.weight);
				} else {
					distanceMap.put(edge.to, 
							Math.min(distanceMap.get(toNode), distance + edge.weight));
				}
			}
			selectedNodes.add(minNode);
			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		}
		return distanceMap;
	}

	public static Node getMinDistanceAndUnselectedNode(
			HashMap<Node, Integer> distanceMap, 
			HashSet<Node> touchedNodes) {
		Node minNode = null;
		int minDistance = Integer.MAX_VALUE;
		for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
			Node node = entry.getKey();
			int distance = entry.getValue();
			if (!touchedNodes.contains(node) && distance < minDistance) {
				minNode = node;
				minDistance = distance;
			}
		}
		return minNode;
	}

	public static class NodeRecord {
		public Node node;
		public int distance;

		public NodeRecord(Node node, int distance) {
			this.node = node;
			this.distance = distance;
		}
	}

	public static class NodeHeap {
		private Node[] nodes; // 实际的堆结构
		// key 某一个node， value 上面堆中的位置
		private HashMap<Node, Integer> heapIndexMap;// 维护加锁的过程吧。
		// key 某一个节点， value 从源节点出发到该节点的目前最小距离
		private HashMap<Node, Integer> distanceMap;
		private int size; // 堆上有多少个点

		public NodeHeap(int size) {
			nodes = new Node[size];
			heapIndexMap = new HashMap<>();
			distanceMap = new HashMap<>();
			size = 0;
		}

		public boolean isEmpty() {
			return size == 0;
		}

		// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
		// 判断要不要更新，如果需要的话，就更新
		public void addOrUpdateOrIgnore(Node node, int distance) {
			if (inHeap(node)) {
				distanceMap.put(node, Math.min(distanceMap.get(node), distance));
				insertHeapify(node, heapIndexMap.get(node));
			}
			if (!isEntered(node)) {
				nodes[size] = node;
				heapIndexMap.put(node, size);
				distanceMap.put(node, distance);
				insertHeapify(node, size++);
			}
		}

		public NodeRecord pop() {
			NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
			swap(0, size - 1);
			heapIndexMap.put(nodes[size - 1], -1);
			distanceMap.remove(nodes[size - 1]);
			// free C++同学还要把原本堆顶节点析构，对java同学不必
			nodes[size - 1] = null;
			heapify(0, --size);
			return nodeRecord;
		}

		private void insertHeapify(Node node, int index) {
			while (distanceMap.get(nodes[index]) 
					< distanceMap.get(nodes[(index - 1) / 2])) {
				swap(index, (index - 1) / 2);
				index = (index - 1) / 2;
			}
		}

		private void heapify(int index, int size) {
			int left = index * 2 + 1;
			while (left < size) {
				int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
						? left + 1
						: left;
				smallest = distanceMap.get(nodes[smallest]) 
						< distanceMap.get(nodes[index]) ? smallest : index;
				if (smallest == index) {
					break;
				}
				swap(smallest, index);
				index = smallest;
				left = index * 2 + 1;
			}
		}

		private boolean isEntered(Node node) {
			return heapIndexMap.containsKey(node);
		}

		private boolean inHeap(Node node) {
			return isEntered(node) && heapIndexMap.get(node) != -1;
		}

		private void swap(int index1, int index2) {
			heapIndexMap.put(nodes[index1], index2);
			heapIndexMap.put(nodes[index2], index1);
			Node tmp = nodes[index1];
			nodes[index1] = nodes[index2];
			nodes[index2] = tmp;
		}
	}

	// 改进后的dijkstra算法
	// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
	public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
		NodeHeap nodeHeap = new NodeHeap(size);
		nodeHeap.addOrUpdateOrIgnore(head, 0);
		HashMap<Node, Integer> result = new HashMap<>();
		while (!nodeHeap.isEmpty()) {
			NodeRecord record = nodeHeap.pop();
			Node cur = record.node;
			int distance = record.distance;
			for (Edge edge : cur.edges) {
				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
			}
			result.put(cur, distance);
		}
		return result;
	}

}
```

# 11.暴力递归(你想怎么试，就能怎么写)

暴力递归就是尝试

* 把问题转换为规模缩小了的同类问题的子问题
* 有明确的不需要继续进行递归的条件（base case)
* 有当得到了子问题的结果之后的决策过程
* 不记录每一个子问题的解





## 汉诺塔问题





```java
	public static void hanoi2(int n) {
		if (n > 0) {
			func(n, "left", "right", "mid");
		}
	}

	// 1~i 圆盘 目标是from -> to， other是另外一个
	public static void func(int N, String from, String to, String other) {
		if (N == 1) { // base
			System.out.println("Move 1 from " + from + " to " + to);
		} else {
			func(N - 1, from, other, to);
			System.out.println("Move " + N + " from " + from + " to " + to);
			func(N - 1, other, to, from);
		}
```

非递归的解法：

```
	public static class Record {
		public boolean finish1;
		public int base;
		public String from;
		public String to;
		public String other;

		public Record(boolean f1, int b, String f, String t, String o) {
			finish1 = false;
			base = b;
			from = f;
			to = t;
			other = o;
		}
	}

	public static void hanoi3(int N) {
		if (N < 1) {
			return;
		}
		Stack<Record> stack = new Stack<>();
		stack.add(new Record(false, N, "left", "right", "mid"));
		while (!stack.isEmpty()) {
			Record cur = stack.pop();
			if (cur.base == 1) {
				System.out.println("Move 1 from " + cur.from + " to " + cur.to);
				if (!stack.isEmpty()) {
					stack.peek().finish1 = true;
				}
			} else {
				if (!cur.finish1) {
					stack.push(cur);
					stack.push(new Record(false, cur.base - 1, cur.from, cur.other, cur.to));
				} else {
					System.out.println("Move " + cur.base + " from " + cur.from + " to " + cur.to);
					stack.push(new Record(false, cur.base - 1, cur.other, cur.to, cur.from));
				}
			}
		}
	}   
```

## 给一个栈，请逆序栈，不能申请额外的数组结构，只能使用递归函数，如何实现？



```
	public static void reverse(Stack<Integer> stack) {
		if (stack.isEmpty()) {
			return;
		}
		int i = f(stack);
		reverse(stack);
		stack.push(i);
	}

	public static int f(Stack<Integer> stack) {
		int result = stack.pop();
		if (stack.isEmpty()) {
			return result;
		} else {
			int last = f(stack);
			stack.push(result);
			return last;
		}
	}
```

## 打印一个字符串的全部子序列

* 子串：必须是连续的一段，对于"abcd",那么，“ab","bc","cd"..这些是子串
* 子序列：保证不改变相对次序不乱，但是不要求连续。对于"abcd",那么,"acd","bd"这些也是子序列。



为了打印子序列，需要得到全部的路径，做一个二叉树，左边可能是要这个字符，右边是不要这个字符，然后展开。。比如下图

![image-20220810133433049](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220810133433049-16601096749051.png)

代码如下：

process2的代码是在得到全部子序列的基础上，做了一个去重的操作，得到不出现重复字面值的子序列。

```java
	public static List<String> subs(String s) {
		char[] str = s.toCharArray();
		String path = "";
		List<String> ans = new ArrayList<>();
		process1(str, 0, ans, path);
		return ans;
	}

	// str固定，不变
	// index此时来到的位置, 要  or 不要
	// 如果index来到了str中的终止位置，把沿途路径所形成的答案，放入ans中
	// 之前做出的选择，就是path
	public static void process1(char[] str, int index, List<String> ans, String path) {
		if (index == str.length) {
			ans.add(path);
			return;
		}
		String no = path;
		process1(str, index + 1, ans, no);
		String yes = path + String.valueOf(str[index]);
		process1(str, index + 1, ans, yes);
	}

	public static List<String> subsNoRepeat(String s) {
		char[] str = s.toCharArray();
		String path = "";
		HashSet<String> set = new HashSet<>();
		process2(str, 0, set, path);
		List<String> ans = new ArrayList<>();
		for (String cur : set) {
			ans.add(cur);
		}
		return ans;
	}

	// str  index  set
	public static void process2(char[] str, int index,
			HashSet<String> set, String path) {
		if (index == str.length) {
			set.add(path);
			return;
		}
		String no = path;
		process2(str, index + 1, set, no);
		String yes = path + String.valueOf(str[index]);
		process2(str, index + 1, set, yes);
	}
```

## 打印字符串的全部排列

前面有过类似这个题（ctrl+F搜索全排列);process1是比较经典的方法。process2是不出现重复排列的版本，这里讲了一个叫做分支限界的东西，分支限界在走某个支路的时候，他就通过机制知道这个路没有必要再走一遍，所以就不走，和上面的那个子序列去重复的比，快很多（因为那个是先得到全部的可能然后筛选，这个是直接就不走不符合要求的）。

```
	public static ArrayList<String> permutation(String str) {
		ArrayList<String> res = new ArrayList<>();
		if (str == null || str.length() == 0) {
			return res;
		}
		char[] chs = str.toCharArray();
		process(chs, 0, res);
		return res;
	}

	// str[0..i-1]已经做好决定的
	// str[i...]都有机会来到i位置
	// i终止位置，str当前的样子，就是一种结果 -> ans
	public static void process(char[] str, int i, ArrayList<String> ans) {
		if (i == str.length) {
			ans.add(String.valueOf(str));
		}
		// 如果i没有终止，i...  都可以来到i位置
		for (int j = i; j < str.length; j++) { // j  i后面所有的字符都有机会
			swap(str, i, j);
			process(str, i + 1, ans);
			swap(str, i, j);//恢复现场.
		}
	}
	

	public static ArrayList<String> permutationNoRepeat(String str) {
		ArrayList<String> res = new ArrayList<>();
		if (str == null || str.length() == 0) {
			return res;
		}
		char[] chs = str.toCharArray();
		process2(chs, 0, res);
		return res;
	}

	// str[0..i-1]已经做好决定的
	// str[i...]都有机会来到i位置
	// i终止位置，str当前的样子，就是一种结果 -> ans
	public static void process2(char[] str, int i, ArrayList<String> res) {
		if (i == str.length) {
			res.add(String.valueOf(str));
			return;
		}
		boolean[] visit = new boolean[26]; // visit[0 1 .. 25],visit[i]表示第i位的字符是否使用过
		for (int j = i; j < str.length; j++) {
			// str[j] = 'a'   -> 0   visit[0] -> 'a'
			
			// str[j] = 'z'   -> 25   visit[25] -> 'z'
			if (!visit[str[j] - 'a']) {
				
				visit[str[j] - 'a'] = true;
				swap(str, i, j);
				process2(str, i + 1, res);
				swap(str, i, j);
				
			}
		}
	}

	public static void swap(char[] chs, int i, int j) {
		char tmp = chs[i];
		chs[i] = chs[j];
		chs[j] = tmp;
	}
```

## 从左往右的尝试模型1

规定1和A对应、2和B对应、3和C对应…
那么一个数字字符串比如“111”就可以转化为：
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果

process是递归做的

```
	public static int number(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		return process(str.toCharArray(), 0);
	}

	// str[0...i-1]已经转化完了，固定了
	// i之前的位置，如何转化已经做过决定了, 不用再关心
	// i... 有多少种转化的结果
	public static int process(char[] str, int i) {
		if (i == str.length) { // base case
			return 1;//返回1表示空字符串，或者说是找到了一种有效的转换是0到1转换完的部分，到终止位置是收集了这个答案。
		}
		if (str[i] == '0') {//0字符没有转换的方式，所以后面没法转换了，就返回了0,也就是说，虽然可以转换"10",但是不会出现"0"的情况，那就说明上面的转换的方法给我留了一个'0',这个路是错的，就返回上去，其实有分支限界的思想。
			return 0;
		}
		if (str[i] == '1') {
			int res = process(str, i + 1);
			if (i + 1 < str.length) {
				res += process(str, i + 2);
			}
			return res;
		}
		if (str[i] == '2') {
			int res = process(str, i + 1);
			if (i + 1 < str.length && (str[i + 1] >= '0' && str[i + 1] <= '6')) {
				res += process(str, i + 2); // (i和i+1)作为单独的部分，后续有多少种方法
			}
			return res;
		}
		// str[i] == '3' ~ ‘9’，这种情况下，就不会出现需要i和i+1拼出来的数字来做的情况，因为字母只有26个嘛。
		return process(str, i + 1);
	}
	

```

## 从左往右尝试模型2（最经典的背包问题）

给定两个长度都为N的数组weights和values,weights[j和valueslj分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？



下面代码是两种方法，方法2是最经典的解法。

```
	public static int getMaxValue(int[] w, int[] v, int bag) {
		return process(w, v, 0, 0, bag);
	}

	// 不变 ： w[]  v[]  bag
	// index... 最大价值
	// 0..index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW
	// 如果返回-1，认为没有方案
	// 如果不返回-1，认为返回的值是真实价值
	public static int process(int[] w, int[] v, int index, int alreadyW, int bag) {
		if (alreadyW > bag) {
			return -1;
		}
		// 重量没超
		if (index == w.length) {
			return 0;
		}
		int p1 = process(w, v, index + 1, alreadyW, bag);// 没有选择当前的货物
		int p2next = process(w, v, index + 1, alreadyW + w[index], bag);// 选择了当前的货物
		int p2 = -1;
		if (p2next != -1) {
			// 如果在要当前货物的前提下，后面的反感是可行的。
			p2 = v[index] + p2next;
		}
		return Math.max(p1, p2);

	}

	public static int maxValue(int[] w, int[] v, int bag) {
		return process(w, v, 0, bag);
	}

	// 只剩下rest的空间了，
	// index...货物自由选择，但是剩余空间不要小于0
	// 返回 index...货物能够获得的最大价值
	public static int process2(int[] w, int[] v, int index, int rest) {
		if (rest < 0) { // base case 1
			return -1;
		}
		// rest >=0
		if (index == w.length) { // base case 2
			return 0;
		}
		// 有货也有空间
		int p1 = process(w, v, index + 1, rest);//没有选择当前的货物。
		int p2 = -1;
		int p2Next = process(w, v, index + 1, rest - w[index]);//选择了当前的货物。
		if(p2Next!=-1) {
			p2 = v[index] + p2Next;
		}
		return Math.max(p1, p2);
	}
```

## 范围上尝试的模型

给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。

看代码挺简单的。

```
	public static int win1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		return Math.max(
				f(arr, 0, arr.length - 1),
				s(arr, 0, arr.length - 1)
				);
	}

	// L....R
	// F  S  L+1..R
	         // L..R-1
	public static int f(int[] arr, int L, int R) {
		if (L == R) {
			return arr[L];
		}
		
		return Math.max(
				arr[L] + s(arr, L + 1, R),
				arr[R] + s(arr, L, R - 1)
				);
	}

	// arr[L..R]
	public static int s(int[] arr, int L, int R) {
		if (L == R) {
			return 0;
		}
		/
		return Math.min(
				f(arr, L + 1, R), // arr[i]
				f(arr, L, R - 1)  // arr[j]
				);
	}
```

## N皇后问题

N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列,也不在同一条斜线上给定一个整数n,返回n皇后的摆法有多少种。n=1,返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行,返回0。n=8，返回92。

num2是优化后的方法。它只优化了常数项，就是把加减乘除优化为了位运算来做。

```
	public static int num1(int n) {
		if (n < 1) {
			return 0;
		}
		// record[0] ?  record[1]  ?  record[2]
		int[] record = new int[n]; // record[i] -> i行的皇后，放在了第几列
		return process1(0, record, n);
	}

	// 潜台词：record[0..i-1],0到i-1行的皇后，任何两个皇后一定都不共行、不共列，不共斜线，已经满足了要求
	// 目前来到了第i行
	// record[0..i-1]表示之前的行，放了的皇后位置
	// n代表整体一共有多少行  0~n-1行
	// 返回值是，摆完所有的皇后，合理的摆法有多少种
	//目前在i行上放。
	public static int process1(int i, int[] record, int n) {
		if (i == n) { // 终止行
			return 1;
		}
		// 没有到终止位置，还有皇后要摆
		int res = 0;
		for (int j = 0; j < n; j++) { // 当前行在i行，尝试i行所有的列  -> j
			// 当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，
			// 如果是，认为有效
			// 如果不是，认为无效
			if (isValid(record, i, j)) {
				record[i] = j;
				res += process1(i + 1, record, n);
			}
		}
		return res;
	}

	// record[0..i-1]你需要看，record[i...]不需要看
	// 返回i行皇后，放在了j列，是否有效
	public static boolean isValid(int[] record, int i, int j) {
		for (int k = 0; k < i; k++) { // 之前的某个k行的皇后	
			// k, record[k]   i, j
			if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
				return false;
			}
		}
		return true;
	}

	// 请不要超过32皇后问题
	public static int num2(int n) {
		if (n < 1 || n > 32) {
			return 0;
		}
		// 如果你是13皇后问题，limit 最右13个1，其他都是0
		int limit = n == 32 ? -1 : (1 << n) - 1;
		return process2(limit, 0, 0, 0);
	}

	// limit 划定了问题的规模 -> 固定
	//如果在i位放皇后，那么i位置1. 
	// colLim 列的限制，1的位置不能放皇后，0的位置可以
	// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以
	// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以
	public static int process2(
			int limit, 
			int colLim, 
			int leftDiaLim,
			int rightDiaLim) {
		if (colLim == limit) { // base case
			return 1;
		}
		// 所有可以放皇后的位置，都在pos上
		// colLim | leftDiaLim | rightDiaLim   -> 总限制
		// ~ (colLim | leftDiaLim | rightDiaLim) -> 左侧的一坨0干扰，右侧每个1，可尝试
		int pos = limit & ( ~(colLim | leftDiaLim | rightDiaLim) );//把最左侧的1给截掉。
		int mostRightOne = 0;
		int res = 0;
		while (pos != 0) {
			// 其取出pos中，最右侧的1来，剩下位置都是0
			mostRightOne = pos & (~pos + 1);
			pos = pos - mostRightOne;
			res += process2(limit, 
					colLim | mostRightOne,
					(leftDiaLim | mostRightOne) << 1,
					(rightDiaLim | mostRightOne) >>> 1);
		}
		return res;
	}
```



# 动态规划

首先讲了几个模拟的问题，在有鳄鱼的过河，偶数个鳄鱼能过，计数个不能过；海盗分金币；村里寄信。



```java

```



