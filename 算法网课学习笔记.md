# 左神的基础算法网课

## 1.算法 认识复杂度对数期二分法与异或运算

### 评估算法的优劣的核心指标是什么？

* 时间复杂度（流程决定)
* 额外空间复杂度（流程决定）
* 常数项时间（实现细节决定）





### 一个问题的最优解是什么意思？

解决一个问题的流程中，在满足时间复杂度最低的基础上，使用最少的空间的算法流程，是问题的最优解。一般都是忽略掉常数项这个因素的。在一般面试过程来说，**应该不卡常数项时间的**，如果因为这个被卡了，可以写邮件反馈一下哈哈哈。



### 什么是对数器？

1. 想要测试的方法a
2. 实现复杂度不好但是容易实现的b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a和方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确



## 2.二分法

==不一定有序才能二分，在二分的过程中，只要有排他性，就是把另一边排除掉不看就行出现，就可以做二分==

### 二分的应用场景？

1. 查找某个值
2. 找<=1的范围
3. 找>=1的范围
4. 局部最小值

​	

​	对于局部最小的这个引用情况，对于无序的arr数组，如果可以确定某个范围内，比如a[0]>a[1]，可以看出左边是向下降的趋势，a[n-2]>a[n-1]，可以看出右边是上升的趋势，**那么就可以确定arr的这个范围中一定有局部最小值**.

示例代码：

![image-20220801142250616](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801142250616-16593349723901.png)

### 技巧？

​	如果 left,right的值很大，那么按照我传统的计算方法`mid=(left+right)/2`会溢出，这个时候，可以用`mid=left+(right-left)/2`来代替，这样就比较安全了，然后，还可以使用`mid=L + ((R - L) >> 1)`这样的话，位运算比除法快的。

---



​	类似的：N * 2 可以写为==N<<1==;N * 2 + 1可以写为==((N << 1) | 1)==

---



## 3.异或运算

* ~~异或：相同为0，不同为1~~
* ~~同或：相同为1，不同为0~~
* ==异或运算就记成无进位相加！！！这么记==，比如6异或7的结果，就是0110 + 0111 = 0001



异或运算的性质：

1. 0^N == N    N^N==0
2. 异或运算满足交换律和结合律(==用无进位相加来理解==),也就是说a^b == b^a    a^b ^c = a^( b^c),**也就是说对于同一批数，不用管他们的顺序，结果是一样的。**



### 如何不用额外空间就交换两个数的值？

通过下面代码实现了，也就是说b^b=0和 0^N=N这俩的应用

 ```
 a = 2,b=3
 a = a^b
 b = a^b
 a = a^b
 ```

**注意，如果a,b是指向同一个位置的，那就不对了，所以a，b二者必须指向不同的内存。**



### 怎么把一个int类型的数，提取出最右侧的1出来？

 

比如N=00011000100，那么怎么得到ans=00000000100

则通过：

```
N&(~N+1)#原始的N与上（取反的N+1），可以自己写写试试
```

 



### 一个数组中有俩种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这两种数？

  设a,b是出现了奇数次的那两种数，那么对这个数组arr进行全部的异或得到的结果eor=a^b,a和b一定是不等的，也一定是不等0的，那么a ^ b也一定不等于0，假如说a和b的第八位是不同的，那么就可以根据上面的那个小trick来把arr中的数分为两类，一类是第八位为0的，一类是第八位不等于0的，那就这两类分别的进行异或，然后就可以得到a和b的真实的值了，太妙了。  

​	至于下面代码为什么取出最右的1来判断，因为异或的性质嘛，eor的值为1的位就是a b两个不相同的位置嘛！



![image-20220801145726314](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801145726314-16593370476162.png)





### 找到一个int数中的二进制的位数？

```
count = 0
N = 321
while N!=0:
	rightOne = N & ((~N)+1)
	count+=1
	N ^=rightOne # 注意，不要写N -=rightOne,因为N如果是负数的话，这样就错了！
```





## 2算法 链表结构、栈、队列、递归行为、哈希表

## 2.1 单向链表和双向链表最简单的练习

1. 单双链表如何反转
2. 删除给定值





## 2.2 栈和队列

可以通过双向链表或者数组的方式进行实现。



​	常见的面试题：实现一个特殊的栈，在基础功能的基础上，实现返回栈中最小元素的功能，并且getMin()函数的时间复杂度为O(1),对于这个问题，做两个栈就行了，data栈是基本的栈，min栈里面是只压当前栈顶与要压入的数中最小的，这样的话，在任何时候getMin()都是得到最小栈的栈顶就行了。还有一种实现方法，就不说了，感兴趣百度吧。。

```java
	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}
```



还有常见面试题：

1. 如何用栈结构实现队列结构（用俩栈拼队列）
2. 如何用队列结构实现栈结构（用俩队列拼栈）



### 语言已经有了API，为什么要学这种基础的？

因为在自己使用的时候会碰到需要改写的情况。





## 2.3 递归

### 递归的时间长度

对于递归子问题规模是一样的：

​	T(N) = aT(N/b) + O(N^d^),a,b,d都是常数

则那么时间复杂度为：

1. 如果log~b~a > d,那么T(N) = O(N^(log~b~a)^)
2. 如果log~b~a < d,那么T(N) = O(N^d^)
3. 如果log~b~a = d,那么T(N) = O(N^d^ * logN)





## 2.4 哈希表

* 哈希表的增、删、改、查在使用时O(1)

* set和dict就是哈希表的结构
* 放入哈希表的数据，如果是基础类型，则内部按值传递，内存占用是这个东西的大小；如果不是基础类型，那么就内部按照引用传递，内部按占用传递，内存占用是8字节。



java的有序表，treeMap，有序表底层可以由AVL树，SB树，红黑树，跳表；AVL和SB和红黑树他们的平衡性是不一样的，跳表是新的设计也，他们都可以实现有序表，他们只是实现细节不一样，只有常数项的差距。



## 3.算法归并排序与随机快排

归并排序,注意下面的那个非递归排序，有一个判断：mergeSize > N /2,这个判断是防止当arr的大小接近临界大小2^32-1的时候，如果mergeSize > N/2 那么就知道下次×2 就会越界了，所以在这里就直接break出来，防止失败。



```java
// 递归方法实现
	public static void mergeSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process(arr, 0, arr.length - 1);
	}

	// arr[L...R]范围上，变成有序的
	// L...R    N    T(N) = 2*T(N/2) + O(N)  ->
	public static void process(int[] arr, int L, int R) {
		if (L == R) { // base case
			return;
		}
		int mid = L + ((R - L) >> 1);
		process(arr, L, mid);
		process(arr, mid + 1, R);
		merge(arr, L, mid, R);
	}

	public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 要么p1越界了，要么p2越界了
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
	}

	// 非递归方法实现
	public static void mergeSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		int mergeSize = 1;// 当前有序的，左组长度
		while (mergeSize < N) { // log N
			int L = 0;
			// 0.... 
			while (L < N) {
				// L...M  左组（mergeSize）
				int M = L + mergeSize - 1;
				if (M >= N) {
					break;
				}
				//  L...M   M+1...R(mergeSize)
				int R = Math.min(M + mergeSize, N - 1);
				merge(arr, L, M, R);
				L = R + 1;
			}
			if (mergeSize > N / 2) {
				break;
			}
			mergeSize <<= 1;
		}
	}

```

### 归并排序的时间复杂度

1. 对于递归方法O（N*logN),这个就是用计算递归的那个公式去得到的。
2. 对于非递归方法也是O（N*logN)
3. 选择的方法不太好，因为浪费了很多的时间去做独立的比较行为。
4. 归并排序需要辅助数组，额外空间复杂度为O（N）



### 练习题

力扣的315类似，和[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)类似。



## 3.2 快速排序

举得一个例子是类似于荷兰国旗问题的划分，就是给一个arr数组，和一个数字num，让比num小于等于的放在arr左边，比他大的在右边，返回一个左右边界。

​	快排最好的情况是，随机选的num是现在待排序的中点位置的。坏情况就是num选的很偏。



* 时间复杂度O（nlogN),空间复杂度O(logN)





## 4-比较器与堆



### 4.1 堆



* 结构上是完全二叉树的结构，完全二叉树每一层都是满的，如果最后一层是不满的，那么也是从左到右在变满的状态。



​	假如说有一个完全二叉树：[0,1,2,3,4,5]，如果从0位置开始的话，对于节点i,他的左孩子是2*i+1,右孩子是2*i+2,父节点为(i-1)/2;

如果[-1,1,2,3,4,5],0位置弃而不用，那么对于i节点，左孩子是2 * i,右孩子是2*i+1,父节点为i / 2;**从1开始有一个好处，就是可以利用位运算来加速计算**。

* ==大根堆==:每一颗子树最大值都是自己头结点的值，比如[6,5,3,0,1]
* ==小根堆==：每一颗子树最小值都是自己头结点



#### 堆排序

时间复杂度N*log(N)

```java
	// 堆排序额外空间复杂度O(1)
	public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// O(N*logN)
//		for (int i = 0; i < arr.length; i++) { // O(N)
//			heapInsert(arr, i); // O(logN)
//		}
        //上面三行是经典的，下面的三行是改进的，下面的这个改进只是让数组变为了大根堆，上面经典的是有序的。
		for (int i = arr.length - 1; i >= 0; i--) {
			heapify(arr, i, arr.length);
		}
		int heapSize = arr.length;
		swap(arr, 0, --heapSize);
		// O(N*logN)
		while (heapSize > 0) { // O(N)
			heapify(arr, 0, heapSize); // O(logN)
			swap(arr, 0, --heapSize); // O(1)
		}
	}
```

与堆相关的题：
	已知一个几乎有序的数组.几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的.请选择一个合适的排序策略,对这个数组进行排序。

​	上面这个题的解题思路：生成一个小根堆，把前k+1个 数做一个原始的小根堆，然后把这个小根堆的最小的值弹出来为arr[0]，然后小根堆中压入arr[k+1],继续弹出此时小根堆最小值arr[1]，然后一直重复



### 4.2 比较器

* 实质就是重载比较运算符
* 比较器可以很好的应用在特殊标准的排序上
* 比较器可以很好的应用中根据特殊标准排序的结构上
* 写代码变得异于简单，适合编程方式



对于一个堆已经装好数了，然后想要对立面的某一个数修改后，仍保持堆的结构，时间复杂度最好logN（如果系统默认的话，时间复杂度是NlogN的） //TODO具体来说就是自己实现的堆，包含一个dict()





## 5-trie、桶排序、排序总结

### 5.1 前缀树---可以完成前缀查询

* 单个字符串，字符从前到后的加到一课多叉树上
* 字符放在路上，节点上有专属的数据项（常见的是pass和end,pass指该节点被通过几次，end指该节点被做过几次结尾)
* 所有样本的这样添加，如果没有路就新建，如有路就复用
* 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

### 5.2 不基于比较的排序----桶排序

桶排序是一个思想，桶就是容器，可以是数组，栈，队列等等，就是一个萝卜一个坑，该排序必须与数据的样本容量强相关（最大值到最小值要很窄），计数排序也对样本本身有要求,**所以不基于比较的排序应用范围非常有限**







### 5.3 基数排序

* 非负
* 十进制数

基数排序属于桶排序思想下的。以上两个要求是经典基数排序的要求。小数也可以做，不过不好改，不好做。代码要改动很多

有一种很骚的实现的方式，时间复杂度为O(N*log_10 * N):

```
public static void radixSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		radixSort(arr, 0, arr.length - 1, maxbits(arr));
	}

	public static int maxbits(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int res = 0;
		while (max != 0) {
			res++;
			max /= 10;
		}
		return res;
	}

	// arr[l..r]排序  ,  digit
	// l..r    3 56 17 100    3
	public static void radixSort(int[] arr, int L, int R, int digit) {
		final int radix = 10;
		int i = 0, j = 0;
		// 有多少个数准备多少个辅助空间
		int[] help = new int[R - L + 1];
		for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
			// 10个空间
		    // count[0] 当前位(d位)是0的数字有多少个
			// count[1] 当前位(d位)是(0和1)的数字有多少个
			// count[2] 当前位(d位)是(0、1和2)的数字有多少个
			// count[i] 当前位(d位)是(0~i)的数字有多少个
			int[] count = new int[radix]; // count[0..9]
			for (i = L; i <= R; i++) {
				// 103  1   3
				// 209  1   9
				j = getDigit(arr[i], d);
				count[j]++;
			}
			for (i = 1; i < radix; i++) {
				count[i] = count[i] + count[i - 1];
			}
			for (i = R; i >= L; i--) {
				j = getDigit(arr[i], d);
				help[count[j] - 1] = arr[i];
				count[j]--;
			}
			for (i = L, j = 0; i <= R; i++, j++) {
				arr[i] = help[j];
			}
		}
		
		
		
		
	}

	public static int getDigit(int x, int d) {
		return ((x / ((int) Math.pow(10, d - 1))) % 10);
	}
```

### 5.4 计数排序

这个比较简单吧

```
	// only for 0~200 value
	public static void countSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}
```

### 5.5 排序算法的稳定性

* 稳定性是同样大小的样本再排序之后不会改变相对次序
* 对基础类型来说，稳定性毫无意义
* 对非基础类型来说，稳定性很有意义
* 快排，非简单选择排序，归并排序的特殊情况，堆不稳定
* 不基于比较的排序对样本数据有严格要求，不易改写
* 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
* 基于比较的排序，时间复杂度的极限是O（N*logN)
* 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
* 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并
* 归并排序的额外空间复杂度可以变为O（1），“归并排序 内存缓存法”，但是将变得不再稳定
* “原地归并排序”是垃圾帖，会让时间复杂度变成O（N^2)
* 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多
* 在整型数组中，把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变，时间复杂度做到O（N），额外空间复杂度做到O（1）这是属于0-1标准的partition，这个问题应该是很难，可以反问面试官，这就是学术上的很严格的论文。。
* 



![image-20220804093438112](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220804093438112-16595768789731.png)



  



## 11 暴力递归

### 11.1并查集

* issameset 和 union是并查集主要实现的两个方法，并且这俩方法的时间复杂度是O(1)