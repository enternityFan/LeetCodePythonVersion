# 左神的基础算法网课

# 1.算法 认识复杂度对数期二分法与异或运算

## 评估算法的优劣的核心指标是什么？

* 时间复杂度（流程决定)
* 额外空间复杂度（流程决定）
* 常数项时间（实现细节决定）





## 一个问题的最优解是什么意思？

解决一个问题的流程中，在满足时间复杂度最低的基础上，使用最少的空间的算法流程，是问题的最优解。一般都是忽略掉常数项这个因素的。在一般面试过程来说，**应该不卡常数项时间的**，如果因为这个被卡了，可以写邮件反馈一下哈哈哈。



## 什么是对数器？

1. 想要测试的方法a
2. 实现复杂度不好但是容易实现的b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a和方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确



# 2.二分法

==不一定有序才能二分，在二分的过程中，只要有排他性，就是把另一边排除掉不看就行出现，就可以做二分==

## 二分的应用场景？

1. 查找某个值
2. 找<=1的范围
3. 找>=1的范围
4. 局部最小值

​	

​	对于局部最小的这个引用情况，对于无序的arr数组，如果可以确定某个范围内，比如a[0]>a[1]，可以看出左边是向下降的趋势，a[n-2]>a[n-1]，可以看出右边是上升的趋势，**那么就可以确定arr的这个范围中一定有局部最小值**.

示例代码：

![image-20220801142250616](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801142250616-16593349723901.png)

## 技巧？

​	如果 left,right的值很大，那么按照我传统的计算方法`mid=(left+right)/2`会溢出，这个时候，可以用`mid=left+(right-left)/2`来代替，这样就比较安全了，然后，还可以使用`mid=L + ((R - L) >> 1)`这样的话，位运算比除法快的。

---



​	类似的：N * 2 可以写为==N<<1==;N * 2 + 1可以写为==((N << 1) | 1)==

---



# 3.异或运算

* ~~异或：相同为0，不同为1~~
* ~~同或：相同为1，不同为0~~
* ==异或运算就记成无进位相加！！！这么记==，比如6异或7的结果，就是0110 + 0111 = 0001



异或运算的性质：

1. 0^N == N    N^N==0
2. 异或运算满足交换律和结合律(==用无进位相加来理解==),也就是说a^b == b^a    a^b ^c = a^( b^c),**也就是说对于同一批数，不用管他们的顺序，结果是一样的。**



## 如何不用额外空间就交换两个数的值？

通过下面代码实现了，也就是说b^b=0和 0^N=N这俩的应用

 ```
 a = 2,b=3
 a = a^b
 b = a^b
 a = a^b
 ```

**注意，如果a,b是指向同一个位置的，那就不对了，所以a，b二者必须指向不同的内存。**



## 怎么把一个int类型的数，提取出最右侧的1出来？

 

比如N=00011000100，那么怎么得到ans=00000000100

则通过：

```
N&(~N+1)#原始的N与上（取反的N+1），可以自己写写试试
```

 



## 一个数组中有俩种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这两种数？

  设a,b是出现了奇数次的那两种数，那么对这个数组arr进行全部的异或得到的结果eor=a^b,a和b一定是不等的，也一定是不等0的，那么a ^ b也一定不等于0，假如说a和b的第八位是不同的，那么就可以根据上面的那个小trick来把arr中的数分为两类，一类是第八位为0的，一类是第八位不等于0的，那就这两类分别的进行异或，然后就可以得到a和b的真实的值了，太妙了。  

​	至于下面代码为什么取出最右的1来判断，因为异或的性质嘛，eor的值为1的位就是a b两个不相同的位置嘛！



![image-20220801145726314](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220801145726314-16593370476162.png)





## 找到一个int数中的二进制的位数？

```
count = 0
N = 321
while N!=0:
	rightOne = N & ((~N)+1)
	count+=1
	N ^=rightOne # 注意，不要写N -=rightOne,因为N如果是负数的话，这样就错了！
```





# 2算法 链表结构、栈、队列、递归行为、哈希表

# 2.1 单向链表和双向链表最简单的练习

1. 单双链表如何反转
2. 删除给定值





# 2.2 栈和队列

可以通过双向链表或者数组的方式进行实现。



​	常见的面试题：实现一个特殊的栈，在基础功能的基础上，实现返回栈中最小元素的功能，并且getMin()函数的时间复杂度为O(1),对于这个问题，做两个栈就行了，data栈是基本的栈，min栈里面是只压当前栈顶与要压入的数中最小的，这样的话，在任何时候getMin()都是得到最小栈的栈顶就行了。还有一种实现方法，就不说了，感兴趣百度吧。。

```java
	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}
```



还有常见面试题：

1. 如何用栈结构实现队列结构（用俩栈拼队列）
2. 如何用队列结构实现栈结构（用俩队列拼栈）



## 语言已经有了API，为什么要学这种基础的？

因为在自己使用的时候会碰到需要改写的情况。





# 2.3 递归

## 递归的时间长度

对于递归子问题规模是一样的：

​	T(N) = aT(N/b) + O(N^d^),a,b,d都是常数

则那么时间复杂度为：

1. 如果log~b~a > d,那么T(N) = O(N^(log~b~a)^)
2. 如果log~b~a < d,那么T(N) = O(N^d^)
3. 如果log~b~a = d,那么T(N) = O(N^d^ * logN)





# 2.4 哈希表

* 哈希表的增、删、改、查在使用时O(1)

* set和dict就是哈希表的结构
* 放入哈希表的数据，如果是基础类型，则内部按值传递，内存占用是这个东西的大小；如果不是基础类型，那么就内部按照引用传递，内部按占用传递，内存占用是8字节。



java的有序表，treeMap，有序表底层可以由AVL树，SB树，红黑树，跳表；AVL和SB和红黑树他们的平衡性是不一样的，跳表是新的设计也，他们都可以实现有序表，他们只是实现细节不一样，只有常数项的差距。



# 3.算法归并排序与随机快排

归并排序,注意下面的那个非递归排序，有一个判断：mergeSize > N /2,这个判断是防止当arr的大小接近临界大小2^32-1的时候，如果mergeSize > N/2 那么就知道下次×2 就会越界了，所以在这里就直接break出来，防止失败。



```java
// 递归方法实现
	public static void mergeSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process(arr, 0, arr.length - 1);
	}

	// arr[L...R]范围上，变成有序的
	// L...R    N    T(N) = 2*T(N/2) + O(N)  ->
	public static void process(int[] arr, int L, int R) {
		if (L == R) { // base case
			return;
		}
		int mid = L + ((R - L) >> 1);
		process(arr, L, mid);
		process(arr, mid + 1, R);
		merge(arr, L, mid, R);
	}

	public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 要么p1越界了，要么p2越界了
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
	}

	// 非递归方法实现
	public static void mergeSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		int mergeSize = 1;// 当前有序的，左组长度
		while (mergeSize < N) { // log N
			int L = 0;
			// 0.... 
			while (L < N) {
				// L...M  左组（mergeSize）
				int M = L + mergeSize - 1;
				if (M >= N) {
					break;
				}
				//  L...M   M+1...R(mergeSize)
				int R = Math.min(M + mergeSize, N - 1);
				merge(arr, L, M, R);
				L = R + 1;
			}
			if (mergeSize > N / 2) {
				break;
			}
			mergeSize <<= 1;
		}
	}

```

## 归并排序的时间复杂度

1. 对于递归方法O（N*logN),这个就是用计算递归的那个公式去得到的。
2. 对于非递归方法也是O（N*logN)
3. 选择的方法不太好，因为浪费了很多的时间去做独立的比较行为。
4. 归并排序需要辅助数组，额外空间复杂度为O（N）



## 练习题

力扣的315类似，和[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)类似。



# 3.2 快速排序

举得一个例子是类似于荷兰国旗问题的划分，就是给一个arr数组，和一个数字num，让比num小于等于的放在arr左边，比他大的在右边，返回一个左右边界。

​	快排最好的情况是，随机选的num是现在待排序的中点位置的。坏情况就是num选的很偏。



* 时间复杂度O（nlogN),空间复杂度O(logN)





# 4-比较器与堆



## 4.1 堆



* 结构上是完全二叉树的结构，完全二叉树每一层都是满的，如果最后一层是不满的，那么也是从左到右在变满的状态。



​	假如说有一个完全二叉树：[0,1,2,3,4,5]，如果从0位置开始的话，对于节点i,他的左孩子是2*i+1,右孩子是2*i+2,父节点为(i-1)/2;

如果[-1,1,2,3,4,5],0位置弃而不用，那么对于i节点，左孩子是2 * i,右孩子是2*i+1,父节点为i / 2;**从1开始有一个好处，就是可以利用位运算来加速计算**。

* ==大根堆==:每一颗子树最大值都是自己头结点的值，比如[6,5,3,0,1]
* ==小根堆==：每一颗子树最小值都是自己头结点



### 堆排序

时间复杂度N*log(N)

```java
	// 堆排序额外空间复杂度O(1)
	public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// O(N*logN)
//		for (int i = 0; i < arr.length; i++) { // O(N)
//			heapInsert(arr, i); // O(logN)
//		}
        //上面三行是经典的，下面的三行是改进的，下面的这个改进只是让数组变为了大根堆，上面经典的是有序的。
		for (int i = arr.length - 1; i >= 0; i--) {
			heapify(arr, i, arr.length);
		}
		int heapSize = arr.length;
		swap(arr, 0, --heapSize);
		// O(N*logN)
		while (heapSize > 0) { // O(N)
			heapify(arr, 0, heapSize); // O(logN)
			swap(arr, 0, --heapSize); // O(1)
		}
	}
```

与堆相关的题：
	已知一个几乎有序的数组.几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的.请选择一个合适的排序策略,对这个数组进行排序。

​	上面这个题的解题思路：生成一个小根堆，把前k+1个 数做一个原始的小根堆，然后把这个小根堆的最小的值弹出来为arr[0]，然后小根堆中压入arr[k+1],继续弹出此时小根堆最小值arr[1]，然后一直重复



## 4.2 比较器

* 实质就是重载比较运算符
* 比较器可以很好的应用在特殊标准的排序上
* 比较器可以很好的应用中根据特殊标准排序的结构上
* 写代码变得异于简单，适合编程方式



对于一个堆已经装好数了，然后想要对立面的某一个数修改后，仍保持堆的结构，时间复杂度最好logN（如果系统默认的话，时间复杂度是NlogN的） //TODO具体来说就是自己实现的堆，包含一个dict()





# 5-trie、桶排序、排序总结

## 5.1 前缀树---可以完成前缀查询

* 单个字符串，字符从前到后的加到一课多叉树上
* 字符放在路上，节点上有专属的数据项（常见的是pass和end,pass指该节点被通过几次，end指该节点被做过几次结尾)
* 所有样本的这样添加，如果没有路就新建，如有路就复用
* 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1

## 5.2 不基于比较的排序----桶排序

桶排序是一个思想，桶就是容器，可以是数组，栈，队列等等，就是一个萝卜一个坑，该排序必须与数据的样本容量强相关（最大值到最小值要很窄），计数排序也对样本本身有要求,**所以不基于比较的排序应用范围非常有限**







## 5.3 基数排序

* 非负
* 十进制数

基数排序属于桶排序思想下的。以上两个要求是经典基数排序的要求。小数也可以做，不过不好改，不好做。代码要改动很多

有一种很骚的实现的方式，时间复杂度为O(N*log_10 * N):

```
public static void radixSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		radixSort(arr, 0, arr.length - 1, maxbits(arr));
	}

	public static int maxbits(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int res = 0;
		while (max != 0) {
			res++;
			max /= 10;
		}
		return res;
	}

	// arr[l..r]排序  ,  digit
	// l..r    3 56 17 100    3
	public static void radixSort(int[] arr, int L, int R, int digit) {
		final int radix = 10;
		int i = 0, j = 0;
		// 有多少个数准备多少个辅助空间
		int[] help = new int[R - L + 1];
		for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
			// 10个空间
		    // count[0] 当前位(d位)是0的数字有多少个
			// count[1] 当前位(d位)是(0和1)的数字有多少个
			// count[2] 当前位(d位)是(0、1和2)的数字有多少个
			// count[i] 当前位(d位)是(0~i)的数字有多少个
			int[] count = new int[radix]; // count[0..9]
			for (i = L; i <= R; i++) {
				// 103  1   3
				// 209  1   9
				j = getDigit(arr[i], d);
				count[j]++;
			}
			for (i = 1; i < radix; i++) {
				count[i] = count[i] + count[i - 1];
			}
			for (i = R; i >= L; i--) {
				j = getDigit(arr[i], d);
				help[count[j] - 1] = arr[i];
				count[j]--;
			}
			for (i = L, j = 0; i <= R; i++, j++) {
				arr[i] = help[j];
			}
		}
		
		
		
		
	}

	public static int getDigit(int x, int d) {
		return ((x / ((int) Math.pow(10, d - 1))) % 10);
	}
```

## 5.4 计数排序

这个比较简单吧

```
	// only for 0~200 value
	public static void countSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}
```

## 5.5 排序算法的稳定性

* 稳定性是同样大小的样本再排序之后不会改变相对次序
* 对基础类型来说，稳定性毫无意义
* 对非基础类型来说，稳定性很有意义
* 快排，非简单选择排序，归并排序的特殊情况，堆不稳定
* 不基于比较的排序对样本数据有严格要求，不易改写
* 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
* 基于比较的排序，时间复杂度的极限是O（N*logN)
* 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
* 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并
* 归并排序的额外空间复杂度可以变为O（1），“归并排序 内存缓存法”，但是将变得不再稳定
* “原地归并排序”是垃圾帖，会让时间复杂度变成O（N^2)
* 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多
* 在整型数组中，把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变，时间复杂度做到O（N），额外空间复杂度做到O（1）这是属于0-1标准的partition，这个问题应该是很难，可以反问面试官，这就是学术上的很严格的论文。。
* 



![image-20220804093438112](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220804093438112-16595768789731.png)



  # 6. 链表问题



* 对于笔试，不必太在乎空间复杂度，一切为了时间复杂度
* 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法
* 链表面试常用的数据结构和技巧：1）使用容器（哈希表、数组等）；2）快慢指针

## 6.1 快慢指针问题

==下面是个问题的边界条件不同==





1)输入链表头节点，奇数长度返回中点，偶数长度返回上中点

```java
	public static Node midOrUpMidNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return head;
		}
		// 链表有3个点或以上
		Node slow = head.next;
		Node fast = head.next.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```

2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点

```
	public static Node midOrDownMidNode(Node head) {
		if (head == null || head.next == null) {
			return head;
		}
		Node slow = head.next;
		Node fast = head.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```



3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个

```java
	public static Node midOrUpMidPreNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		Node slow = head;
		Node fast = head.next.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```

4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

```java
	public static Node midOrDownMidPreNode(Node head) {
		if (head == null || head.next == null) {
			return null;
		}
		if (head.next.next == null) {
			return head;
		}
		Node slow = head;
		Node fast = head.next;
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}
```



## 6.2 链表判断回文

==方法1，空间复杂度O(n)==

首先遍历一遍链表，然后把每个值压栈；然后再遍历一遍链表，然后把每个值从栈里弹出进行比较，如果有不相同的退出返回False。

==方法2（快慢指针，减少空间的使用,空间复杂度O(n/2)）==

通过快慢指针首先定位到栈的中间的位置，然后再开始压栈，只往栈里压入链表后半部分的数值。然后把每个值从栈里弹出进行比较，如果有不相同的退出返回False。

==方法3（快慢指针，然后逆序后半部分，空间复杂度0(1))==



```java
	// need n extra space
	public static boolean isPalindrome1(Node head) {
		Stack<Node> stack = new Stack<Node>();
		Node cur = head;
		while (cur != null) {
			stack.push(cur);
			cur = cur.next;
		}
		while (head != null) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// need n/2 extra space
	public static boolean isPalindrome2(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node right = head.next;
		Node cur = head;
		while (cur.next != null && cur.next.next != null) {
			right = right.next;
			cur = cur.next.next;
		}
		Stack<Node> stack = new Stack<Node>();
		while (right != null) {
			stack.push(right);
			right = right.next;
		}
		while (!stack.isEmpty()) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// need O(1) extra space
	public static boolean isPalindrome3(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		Node n1 = head;
		Node n2 = head;
		while (n2.next != null && n2.next.next != null) { // find mid node
			n1 = n1.next; // n1 -> mid
			n2 = n2.next.next; // n2 -> end
		}
		// n1 中点
		
		
		n2 = n1.next; // n2 -> right part first node
		n1.next = null; // mid.next -> null
		Node n3 = null;
		while (n2 != null) { // right part convert
			n3 = n2.next; // n3 -> save next node
			n2.next = n1; // next of right node convert
			n1 = n2; // n1 move
			n2 = n3; // n2 move
		}
		n3 = n1; // n3 -> save last node
		n2 = head;// n2 -> left first node
		boolean res = true;
		while (n1 != null && n2 != null) { // check palindrome
			if (n1.value != n2.value) {
				res = false;
				break;
			}
			n1 = n1.next; // left to mid
			n2 = n2.next; // right to mid
		}
		n1 = n3.next;
		n3.next = null;
		while (n1 != null) { // recover list
			n2 = n1.next;
			n1.next = n3;
			n3 = n1;
			n1 = n2;
		}
		return res;
	}
```

### 6.3 将单链表化为左边小于k,右边大于k,中间等于k

笔试的写法（这种写法时间复杂度O(n)，就是空间复杂度多点)：

首先把链表中的数读到一个数组中，然后对数组做partition，然后再把这个数组放到新的单链表中。

面试的写法（这种写法空间复杂度O(1)):

做6个引用，SH，ST为小于K区域的头和尾，EH，ET为等于K区域的头和尾，BH,BT为大于K区域的头和尾。

```java
public static Node listPartition2(Node head, int pivot) {
		Node sH = null; // small head
		Node sT = null; // small tail
		Node eH = null; // equal head
		Node eT = null; // equal tail
		Node mH = null; // big head
		Node mT = null; // big tail
		Node next = null; // save next node
		// every node distributed to three lists
		while (head != null) {
			next = head.next;
			head.next = null;
			if (head.value < pivot) {
				if (sH == null) {
					sH = head;
					sT = head;
				} else {
					sT.next = head;
					sT = head;
				}
			} else if (head.value == pivot) {
				if (eH == null) {
					eH = head;
					eT = head;
				} else {
					eT.next = head;
					eT = head;
				}
			} else {
				if (mH == null) {
					mH = head;
					mT = head;
				} else {
					mT.next = head;
					mT = head;
				}
			}
			head = next;
		}
		// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
		if (sT != null) { // 如果有小于区域
			sT.next = eH;
			eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
		}
		// 上面的if，不管跑了没有，et
		// all reconnect
		if (eT != null) { // 如果小于区域和等于区域，不是都没有
			eT.next = mH;
		}
		return sH != null ? sH : (eH != null ? eH : mH);
	}
```



## 6.4 [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)



==笔试方法：哈希表==

```java
public static Node copyListWithRand1(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node cur = head;
		while (cur != null) {
			map.put(cur, new Node(cur.value));
			cur = cur.next;
		}
		cur = head;
		while (cur != null) {
			// cur 老
			// map.get(cur) 新
			map.get(cur).next = map.get(cur.next);
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		}
		return map.get(head);
	}
```





==面试方法：不用哈希表,空间复杂度O(1)==



```java

public static Node copyListWithRand2(Node head) {
		if (head == null) {
			return null;
		}
		Node cur = head;
		Node next = null;
		// copy node and link to every node
		// 1 -> 2
		// 1 -> 1' -> 2
		while (cur != null) {
			// cur 老   next 老的下一个
			next = cur.next;
			cur.next = new Node(cur.value);
			cur.next.next = next;
			cur = next;
		}
		cur = head;
		Node curCopy = null;
		// set copy node rand
		// 1 -> 1' -> 2 -> 2'
		while (cur != null) {
			// cur 老
			// cur.next  新 copy
			next = cur.next.next;
			curCopy = cur.next;
			curCopy.rand = cur.rand != null ? cur.rand.next : null;
			cur = next;
		}
		// head  head.next
		Node res = head.next;
		cur = head;
		// split
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
			cur = next;
		}
		return res;
	}
```

## 6.5链表相交

==这个题和链表约瑟夫环的问题是链表的俩个噩梦==

给定两个可能有环也可能无环的单链表,头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null


【要求】

如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。



==相交只和节点的内存地址有关，和值没有关系==，首先可以判断链表有环没环，如果链表有环，返回第一个链表入环的节点，否则返回空节点。

判断第一个入环的节点：==可以用哈希表的方法，针对内存地址==；  ==使用快慢指针，则二者一定能在入环口相遇==

1. 首先判断两个链表的是否有环,loop1,loop2是否为空;
2. 如果两个链表都无环，那二者最后相交一定有公共部分,这个时候可以把链表1放在set中，然后对于链表2一个一个判断。还有另外一个方法，记录两个两个链表的长度，并且判断两个链表的最后节点end1和end2是否内存地址一样，如果不一样，就证明不相交,如果相交，则让长的链表先走len(链表1) - len(链表2),然后二者一起走就可以得到相交的节点了。
3. ==如果一个链表有环，一个链表没环，不可能相交==
4. 两个链表都有环，有三种可能1）二者入环节点是一个，在环外；2）二者入环节点一样，是相交点；3）二者入环节点不同，且在环内。对于第二种情况，直接判断loop1==loop2就行了。然后让loop1一直走，看能不能碰到loop2，如果能碰到就是情况3，不然是情况1.

```java
public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node getIntersectNode(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node loop1 = getLoopNode(head1);
		Node loop2 = getLoopNode(head2);
		if (loop1 == null && loop2 == null) {
			return noLoop(head1, head2);
		}
		if (loop1 != null && loop2 != null) {
			return bothLoop(head1, loop1, head2, loop2);
		}
		return null;
	}

	// 找到链表第一个入环节点，如果无环，返回null
	public static Node getLoopNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		// n1 慢  n2 快
		Node n1 = head.next; // n1 -> slow
		Node n2 = head.next.next; // n2 -> fast
		while (n1 != n2) {
			if (n2.next == null || n2.next.next == null) {
				return null;
			}
			n2 = n2.next.next;
			n1 = n1.next;
		}
		n2 = head; // n2 -> walk again from head
		while (n1 != n2) {
			n1 = n1.next;
			n2 = n2.next;
		}
		return n1;
	}

	// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null
	public static Node noLoop(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node cur1 = head1;
		Node cur2 = head2;
		int n = 0;
		while (cur1.next != null) {
			n++;
			cur1 = cur1.next;
		}
		while (cur2.next != null) {
			n--;
			cur2 = cur2.next;
		}
		if (cur1 != cur2) {
			return null;
		}
		// n  :  链表1长度减去链表2长度的值
		cur1 = n > 0 ? head1 : head2; // 谁长，谁的头变成cur1
		cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2
		n = Math.abs(n);
		while (n != 0) {
			n--;
			cur1 = cur1.next;
		}
		while (cur1 != cur2) {
			cur1 = cur1.next;
			cur2 = cur2.next;
		}
		return cur1;
	}

	// 两个有环链表，返回第一个相交节点，如果不想交返回null
	public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
		Node cur1 = null;
		Node cur2 = null;
		if (loop1 == loop2) {
			cur1 = head1;
			cur2 = head2;
			int n = 0;
			while (cur1 != loop1) {
				n++;
				cur1 = cur1.next;
			}
			while (cur2 != loop2) {
				n--;
				cur2 = cur2.next;
			}
			cur1 = n > 0 ? head1 : head2;
			cur2 = cur1 == head1 ? head2 : head1;
			n = Math.abs(n);
			while (n != 0) {
				n--;
				cur1 = cur1.next;
			}
			while (cur1 != cur2) {
				cur1 = cur1.next;
				cur2 = cur2.next;
			}
			return cur1;
		} else {
			cur1 = loop1.next;
			while (cur1 != loop1) {
				if (cur1 == loop2) {
					return loop1;
				}
				cur1 = cur1.next;
			}
			return null;
		}
	}
```



## 6.6 不给单链表的头结点，只给想删除的节点，能否在链表上把该节点删掉？

 	1. 覆盖掉这个点，**把后面的值一个个的复制过来这样做不可能删除最后一个节点**，只是对值进行操作，而不是内存。



==这个题要说不行，不能做到，然后说明上面方法的问题。这个题主要是问对内存的理解==



# 7-二叉树的基本算法 

## 7.1 先序、中序、后序遍历

没啥说的比较基础，不过可以学一下栈的实现方式。



## 7.2 二叉树的层序遍历

* 其实就是广度优先遍历，用队列实现
* 可以通过设置flag变量的方式，来发现某一层的结束

看代码还是比较简单:先加左再加右

```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int v) {
			value = v;
		}
	}

	public static void level(Node head) {
		if (head == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			System.out.println(cur.value);
			if (cur.left != null) {
				queue.add(cur.left);
			}
			if (cur.right != null) {
				queue.add(cur.right);
			}
		}
	}
```

### 统计二叉树的最大宽度？

要发现每一层的开始和结束，或者说只发现某一层的开始或者结束（因为二者是连着的）

```
public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}
	# 用map实现的
	public static int maxWidthUseMap(Node head) {
		if (head == null) {
			return 0;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		// key 在 哪一层，value
		HashMap<Node, Integer> levelMap = new HashMap<>();
		levelMap.put(head, 1);
		int curLevel = 1; // 当前你正在统计哪一层的宽度
		int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少
		int max = 0;
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			int curNodeLevel = levelMap.get(cur);
			if (cur.left != null) {
				levelMap.put(cur.left, curNodeLevel + 1);
				queue.add(cur.left);
			}
			if (cur.right != null) {
				levelMap.put(cur.right, curNodeLevel + 1);
				queue.add(cur.right);
			}
			if (curNodeLevel == curLevel) {
				curLevelNodes++;
			} else {
				max = Math.max(max, curLevelNodes);
				curLevel++;
				curLevelNodes = 1;
			}
		}
		max = Math.max(max, curLevelNodes);
		return max;
	}
	# 不用map
	public static int maxWidthNoMap(Node head) {
		if (head == null) {
			return 0;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(head);
		Node curEnd = head; // 当前层，最右节点是谁
		Node nextEnd = null; // 下一层，最右节点是谁
		int max = 0;
		int curLevelNodes = 0; // 当前层的节点数
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			if (cur.left != null) {
				queue.add(cur.left);
				nextEnd = cur.left;
			}
			if (cur.right != null) {
				queue.add(cur.right);
				nextEnd = cur.right;
			}
			curLevelNodes++;
			if (cur == curEnd) {
				max = Math.max(max, curLevelNodes);
				curLevelNodes = 0;
				curEnd = nextEnd;
			}
		}
		return max;
	}
```



### 二叉树的序列化和反序列化

* 通过先序，后序，中序或者按层遍历，来实现序列化，再用相应的方法进行反序列化。关键在于 **要补全空间点** 



### 打印一颗二叉树

* 可以把二叉树变成满二叉树的形式然后再进行打印。



```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}
```

## 给二叉树中的某个节点，返回该节点的后继节点



X有右树的话，那么 **他的后序节点就是他右树的左节点**，X没有右树的话，那就往上找，直到是某个节点的左孩子，如果找到了，返回这个节点就行了。这个题的树需要有一个parent属性指向他的parent

```java
	public static class Node {
		public int value;
		public Node left;
		public Node right;
		public Node parent;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node getSuccessorNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		} else { // 无右子树
			Node parent = node.parent;
			while (parent != null && parent.right == node) { // 当前节点是其父亲节点右孩子
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

	public static Node getLeftMost(Node node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}
```



## 打印对折纸（[剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)）

```
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	// 递归过程，来到了某一个节点，
	// i是节点的层数，N一共的层数，down == true  凹    down == false 凸
	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true);
		System.out.println(down ? "凹 " : "凸 ");
		printProcess(i + 1, N, false);
	}
```



# 8-二叉树的递归套路（树形DP问题）



1.  假设以X节点为头，**假设可以向X左树和X右树**要任何信息
2. 在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（很重要）
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5. 递归函数都返回S，每一棵子树都这么要求
6. 写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息。



## 8.1给一个二叉树的头结点，判断是否为平衡二叉树



平衡树：每一棵子树和右子树的高度差不超过1，潜台词就是1）左树平衡；2）右树平衡；3）二者高度差不超过1. 

​	对于本题就是，我要往左树和右树要两个信息，一个是是否平衡，二来是高度多少

下面代码中,process2是递归套路

```
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static boolean isBalanced1(Node head) {
		boolean[] ans = new boolean[1];
		ans[0] = true;
		process1(head, ans);
		return ans[0];
	}

	public static int process1(Node head, boolean[] ans) {
		if (!ans[0] || head == null) {
			return -1;
		}
		int leftHeight = process1(head.left, ans);
		int rightHeight = process1(head.right, ans);
		if (Math.abs(leftHeight - rightHeight) > 1) {
			ans[0] = false;
		}
		return Math.max(leftHeight, rightHeight) + 1;
	}

	public static boolean isBalanced2(Node head) {
		return process2(head).isBalaced;
	}

	// 左、右要求一样，Info 信息返回的结构体
	public static class Info {
		public boolean isBalaced;
		public int height;

		public Info(boolean b, int h) {
			isBalaced = b;
			height = h;
		}
	}

	public static Info process2(Node X) {
		if (X == null) {
			return new Info(true, 0);
		}
		Info leftInfo = process2(X.left);
		Info rightInfo = process2(X.right);
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		boolean isBalanced = true;
		if (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) > 1) {
			isBalanced = false;
		}
		return new Info(isBalanced, height);
	}
```



## 给一棵二叉树的头结点head，任何两个节点之间都存在距离，返回整棵树的最大距离

1) 最大距离与X节点无关，那么X节点就是他子树上的最大距离。
2) 最大距离与X有关，那么只有一种可能性，X左树上离他最远的点到他右树的离他最远的点，就是左树的高度+1+右树上最高的点。

```
	public static class Info {
		public int maxDistance;
		public int height;

		public Info(int dis, int h) {
			maxDistance = dis;
			height = h;
		}
	}

	public static Info process(Node X) {
		if (X == null) {
			return new Info(0, 0);
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		int maxDistance = Math.max(
				Math.max(leftInfo.maxDistance, rightInfo.maxDistance),
				leftInfo.height + rightInfo.height + 1);
		return new Info(maxDistance, height);
	}
```



## 给一个二叉树的头结点head，返回这棵二叉树最大的二叉搜搜子树的头节点

一棵树里未必都是搜索二叉树，我现在要的就是最大的二叉搜索子树的，头结点。



1. 最大二叉树与X无关，那么X就是他左子树头结点或者右子树头结点最大搜索树的那个
2. 如果与X有关，那么X就是他左树或者右树，如果他满足左子树最大的小于X，右子树最小的大于X，那么就是X这个节点。



```
	// 任何子树
	public static class Info {
		public boolean isAllBST;
		public int maxSubBSTSize;
		public int min;
		public int max;

		public Info(boolean is, int size, int mi, int ma) {
			isAllBST = is;
			maxSubBSTSize = size;
			min = mi;
			max = ma;
		}
	}
	
	
	
	
	public static Info process(Node X) {
		if(X == null) {
			return null;
		}
		Info leftInfo = process(X.left);
		Info rightInfo = process(X.right);
		
		
		
		int min = X.value;
		int max = X.value;
		
		if(leftInfo != null) {
			min = Math.min(min, leftInfo.min);
			max = Math.max(max, leftInfo.max);
		}
		if(rightInfo != null) {
			min = Math.min(min, rightInfo.min);
			max = Math.max(max, rightInfo.max);
		}
		
		
		
		
		
		

		int maxSubBSTSize = 0;
		if(leftInfo != null) {
			maxSubBSTSize = leftInfo.maxSubBSTSize;
		}
		if(rightInfo !=null) {
			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);
		}
		boolean isAllBST = false;
		
		
		if(
				// 左树整体需要是搜索二叉树
				(  leftInfo == null ? true : leftInfo.isAllBST    )
				&&
				(  rightInfo == null ? true : rightInfo.isAllBST    )
				&&
				// 左树最大值<x
				(leftInfo == null ? true : leftInfo.max < X.value)
				&&
				(rightInfo == null ? true : rightInfo.min > X.value)
				
				
				) {
			
			maxSubBSTSize = 
					(leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
					+
					(rightInfo == null ? 0 : rightInfo.maxSubBSTSize)
					+
					1;
					isAllBST = true;
			
			
		}


		
		
		return new Info(isAllBST, maxSubBSTSize, min, max);
	}
```







## 派对的最大快乐值（多叉树）

 ![image-20220805101208060](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记.assets\image-20220805101208060-16596655298321.png)



牛客有这个题。















# 11 暴力递归

## 11.1并查集

* issameset 和 union是并查集主要实现的两个方法，并且这俩方法的时间复杂度是O(1)





