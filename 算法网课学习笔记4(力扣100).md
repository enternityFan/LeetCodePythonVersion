以下都是leetcode的题



# 20230201力扣高频视频1

## 1. 两数之和



利用哈希表来做，遍历数组，当到达i位置的时候，查看是否target-arr[i]的值已经在哈希表中出现过，如果出现过，那么就返回就行了.哈希表的key是arr[i],value是i



## 2. 两数相加

​	这个题是不能用最朴素的思想，去把每个链表给他变为他所代表的数的。因为计算机里long类型长度是有限的。

​	这个题如果在笔试遇到，首先遍历一遍两个链表分别生成两个个数组，把每一个数都给放到这个数组里。然后可能还需要一个布尔类型去表示是不是要进位。这个思路就是简单点好做，不过他会有引入额外的空间吧，如果在面试中遇到的话，那就用链表去进行相加，这是面试官更像看到的。

​	这个题就是从头到尾的去加就行了，没啥说的。





## 3. 无重复字符的最长子串

​	看到子串，子序列，的话，经典的解法就是以i位置结尾的情况下，答案是什么。然后求所有可能的结尾就行了。



## 4. 寻找两个正序数组的中位数

这个题是训练营第四期第四节的第二题，找K个最大的数的一个变换。





# 20230201力扣高频视频2

## 5. 最长回文子串
这个就是Manacher的，就跳过了。



## 7.整数反转

这个题就是都给**转换为负数进行考虑，因为负数表示的范围大，就这个操作还是很常见的。**然后注意一下溢出的情况就行，还是比较简单的。比如说-2 **31这个数，取一个绝对值变成正数就表示不出来的，但是正数里面的所有范围都是可以被负数表示的。



## 8. 字符串转换整数 (atoi)

这个题和上面的题类似，不过要考虑的边界条件还是要多一点的。这个题差评很多的，学不到什么东西，就是边界条件恶心人。

​	不过这个题的思路很有意思的，==首先需要检查过滤的所有的非法的情况，然后才进行算法的设计==这个思路是好的。自己在设计代码的时候应该要注意。





## 10. 正则表达式匹配

这个还是动态规划里面比较难的问题的。详细看代码注释，有dp版本和递归版本还有记忆化搜索的版本，除了dp版本能通过，后面两个都通不了，不过只有最后一个测试样例有问题。

20230104 38经典面试二十二的题目1，是比较类似的。













## 11. 盛最多水的容器

遍历一遍就行了,左右两侧一起移动，哪边小结算哪一册。
这种求解思路不去想每个杆的最优解，而是让答案尽可能的大




## 12. 整数转罗马数字

这个题因为已经明说了数字的范围不会超过4000，所以可以做映射表来做。



## 13. 罗马数字转整数



跳过了吧，很简单



# 20230201力扣高频视频3



## 14. 最长公共前缀


思路很简单，把第一个字符串拿出来，然后遍历其他的每一个字符串，遍历到不一样就break



## 15. 三数之和



首先两数之和我们是能弄出来的。然后在两数之和的基础上就可以把这个三数之和的题给弄出来了。

​	想说两数之和，首先对数组进行排序，然后有一个LR指针，如果[L]+[R]大于k，那就R--，如果小于k，那就L++，如果相等，那就看一下L是不是等于L-1，如果不等那就收集答案。如果[L],[R]相等那L,R就随便往右动，或者R往左动都行的。

​	对于三元组的问题，K=0的时候是一种特殊情况，假设是有序的，那么遍历每一个arr[i],对于i位置，去找arr[i+1....end]位置的和为K-arr[i]的所有二数之和。如果i+1位置和i位置的值一样，那就直接跳过就行了。

​	代码中给出了正反两个解题的思路。其实区别不大。

​	==如果在面试中有一个O(N*logN)的方法和一个O(N)的方法，那O(N)的比`O（N*logN)的好`,如果还能再优化，那就是O(logN);但是如果是笔试的方法，那做对就行。==

​	一般来说，笔试中N=10^5次方，就是不卡常数，但是`N^2`的方法还是过不了。通过`10^8`次方，猜技巧是很重要的。





## 17. 电话号码的字母组合



这个题真简单，就是回溯的思想。。我只是一直懒得做这个电话的表格吧看来。。ennnn



## 19. 删除链表的倒数第 N 个结点

这个题其实没什么难的，主要是coding的调整。然后要考虑一下，可能会有换头节点的情况。

​	代码只扫描一遍，大逻辑就是，假如让我删除倒数第n个节点，那么在扫描的过程中当扫到第n个节点的时候，就做一个指针指向第一个节点，然后继续向下扫描这两个指针，当当前扫描到最后时，那么那个新加入的指针他就正好是倒数第n个节点了。但是上面只是在说一个大逻辑，但是其实我们应该要的是删掉节点的前一个节点，也就是当前扫描到最后的时候，新加入的指针正好是导数第n+1的节点。



## 20. 有效的括号

用个栈就行了。



## 21. 合并两个有序链表

跳了。



## 22. 括号生成

一个简单的回溯的题

​	这个题如果改为，只要合法数量的值，而不是合法的组合，那这个题就是卡特兰数的题。





















