以下都是leetcode的题



# 20230201力扣高频视频1

## 1. 两数之和



利用哈希表来做，遍历数组，当到达i位置的时候，查看是否target-arr[i]的值已经在哈希表中出现过，如果出现过，那么就返回就行了.哈希表的key是arr[i],value是i



## 2. 两数相加

​	这个题是不能用最朴素的思想，去把每个链表给他变为他所代表的数的。因为计算机里long类型长度是有限的。

​	这个题如果在笔试遇到，首先遍历一遍两个链表分别生成两个个数组，把每一个数都给放到这个数组里。然后可能还需要一个布尔类型去表示是不是要进位。这个思路就是简单点好做，不过他会有引入额外的空间吧，如果在面试中遇到的话，那就用链表去进行相加，这是面试官更像看到的。

​	这个题就是从头到尾的去加就行了，没啥说的。





## 3. 无重复字符的最长子串

​	看到子串，子序列，的话，经典的解法就是以i位置结尾的情况下，答案是什么。然后求所有可能的结尾就行了。



## 4. 寻找两个正序数组的中位数

这个题是训练营第四期第四节的第二题，找K个最大的数的一个变换。





# 20230201力扣高频视频2

## 5. 最长回文子串

这个就是Manacher的，就跳过了。



## 7.整数反转

这个题就是都给**转换为负数进行考虑，因为负数表示的范围大，就这个操作还是很常见的。**然后注意一下溢出的情况就行，还是比较简单的。比如说-2 **31这个数，取一个绝对值变成正数就表示不出来的，但是正数里面的所有范围都是可以被负数表示的。



## 8. 字符串转换整数 (atoi)

这个题和上面的题类似，不过要考虑的边界条件还是要多一点的。这个题差评很多的，学不到什么东西，就是边界条件恶心人。

​	不过这个题的思路很有意思的，==首先需要检查过滤的所有的非法的情况，然后才进行算法的设计==这个思路是好的。自己在设计代码的时候应该要注意。





## 10. 正则表达式匹配

这个还是动态规划里面比较难的问题的。详细看代码注释，有dp版本和递归版本还有记忆化搜索的版本，除了dp版本能通过，后面两个都通不了，不过只有最后一个测试样例有问题。

20230104 38经典面试二十二的题目1，是比较类似的。













## 11. 盛最多水的容器

遍历一遍就行了,左右两侧一起移动，哪边小结算哪一册。
这种求解思路不去想每个杆的最优解，而是让答案尽可能的大




## 12. 整数转罗马数字

这个题因为已经明说了数字的范围不会超过4000，所以可以做映射表来做。



## 13. 罗马数字转整数



跳过了吧，很简单



# 20230201力扣高频视频3



## 14. 最长公共前缀


思路很简单，把第一个字符串拿出来，然后遍历其他的每一个字符串，遍历到不一样就break



## 15. 三数之和



首先两数之和我们是能弄出来的。然后在两数之和的基础上就可以把这个三数之和的题给弄出来了。

​	想说两数之和，首先对数组进行排序，然后有一个LR指针，如果[L]+[R]大于k，那就R--，如果小于k，那就L++，如果相等，那就看一下L是不是等于L-1，如果不等那就收集答案。如果[L],[R]相等那L,R就随便往右动，或者R往左动都行的。

​	对于三元组的问题，K=0的时候是一种特殊情况，假设是有序的，那么遍历每一个arr[i],对于i位置，去找arr[i+1....end]位置的和为K-arr[i]的所有二数之和。如果i+1位置和i位置的值一样，那就直接跳过就行了。

​	代码中给出了正反两个解题的思路。其实区别不大。

​	==如果在面试中有一个O(N*logN)的方法和一个O(N)的方法，那O(N)的比`O（N*logN)的好`,如果还能再优化，那就是O(logN);但是如果是笔试的方法，那做对就行。==

​	一般来说，笔试中N=10^5次方，就是不卡常数，但是`N^2`的方法还是过不了。通过`10^8`次方，猜技巧是很重要的。





## 17. 电话号码的字母组合



这个题真简单，就是回溯的思想。。我只是一直懒得做这个电话的表格吧看来。。ennnn



## 19. 删除链表的倒数第 N 个结点

这个题其实没什么难的，主要是coding的调整。然后要考虑一下，可能会有换头节点的情况。

​	代码只扫描一遍，大逻辑就是，假如让我删除倒数第n个节点，那么在扫描的过程中当扫到第n个节点的时候，就做一个指针指向第一个节点，然后继续向下扫描这两个指针，当当前扫描到最后时，那么那个新加入的指针他就正好是倒数第n个节点了。但是上面只是在说一个大逻辑，但是其实我们应该要的是删掉节点的前一个节点，也就是当前扫描到最后的时候，新加入的指针正好是导数第n+1的节点。



## 20. 有效的括号

用个栈就行了。



## 21. 合并两个有序链表

跳了。



## 22. 括号生成

一个简单的回溯的题。如果还可以加左括号，那就加。如果还可以加右括号，那就加右。

​	这个题如果改为，只要合法数量的值，而不是合法的组合，那这个题就是卡特兰数的题。





## 23. 合并K个升序链表

```
小根堆。首先让头结点都放小根堆，然后弹出最小的，把这个头结点的下一个结点再放到小根堆里面，然后再弹出来。。。就是这个思路
```

​	这个题很简单的，不过也有意思，好好看看代码，主要是用了一个idx来区分，这个idx是该节点所在头结点的在数组的位置。



注意，为了让节点可以比较大小，这里就压入了(node.val,idx),加idx是因为我遇到了下面的报错，就是有相同的数，这里用idx区分了。

在写这个题的时候，遇到了一个错误：TypeError: '<' not supported between instances of 'ListNode' and 'ListNode'

这个错误的一个解决方法就是：

In the event that two or more of the lists have the same `val`, this code will error out since the `queue` module will compare the second element in the priority queue which is a `ListNode` object (and this is not a comparable type).

 

To solve for this issue, I have stored `(node.val, list_idx, node)` to account for this edge case.





# 20230202力扣高频视频4

## 26. 删除有序数组中的重复项



其实也就是一个快慢指针的东西吧。



## 28. 找出字符串中第一个匹配项的下标

KMP算法，跳过了。直接复习就行。



## 29. 两数相除

这个题emm老左的课弄的更吊一点不实现算数运算的东西。

​	这个题的代码，老左讲的很全的，加减乘除的位运算计算方法都给了。

这个题现在面试考的不多的。

==注意这个代码的加法我没用老左的，因为他是java平台的，我python平台用发现有问题，就参考的下面的[这个博客](https://blog.csdn.net/ustbbsy/article/details/82344003?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167530738016782427478040%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167530738016782427478040&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-82344003-null-null.142^v72^insert_chatgpt,201^v4^add_ask&utm_term=python%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%B4%9F%E6%95%B0%E5%8A%A0%E6%B3%95&spm=1018.2226.3001.4187)

==这个题代码有问题，建议不参考老左的了。学习思路就行==



## 33. 搜索旋转排序数组

有序数组找数，肯定是二分的。这个题考条件分类。就是假如说要找LR范围的数，M是中点，==如果[L],[M],[R]不都相等，那就一定能二分==，这是一个有意思的结论。这个题只要记住这个黄色的结论就行了，也不用背。







## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

这个题就是两个二分，很简单的。



## [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

这个题很简单，就是做一个简单的验证就行了。。





## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)



如果是让自己填数独的话，那就是深度优先，可以暴力尝试嘛，就每个格子都填每种可能，然后最后再验证行不行。所以这个题是要考察剪枝条件能不能写清楚的。然后需要注意的就是深度优先要清理现场的问题。





# 20230202力扣高频视频5



## 38. 外观数列

就是一个递归的。跳过。这个题的踩是赞的10倍







## 41. 缺失的第一个正数

这个题就是直接讲O(n)的时间复杂度和O(1)的空间复杂度去做了。



## 42. 接雨水

很经典了。只考虑i位置的水最多的，就是`[i] = max{0,min{max左-i,max右-i}}`



## 44. 通配符匹配

这个题和第十题很类似。这个的代码也写了很多的版本的，很好的题。1是暴力递归，2是dp，3是斜率优化的dp

























