以下都是leetcode的题



# 20230201力扣高频视频1

## 1. 两数之和



利用哈希表来做，遍历数组，当到达i位置的时候，查看是否target-arr[i]的值已经在哈希表中出现过，如果出现过，那么就返回就行了.哈希表的key是arr[i],value是i



## 2. 两数相加

​	这个题是不能用最朴素的思想，去把每个链表给他变为他所代表的数的。因为计算机里long类型长度是有限的。

​	这个题如果在笔试遇到，首先遍历一遍两个链表分别生成两个个数组，把每一个数都给放到这个数组里。然后可能还需要一个布尔类型去表示是不是要进位。这个思路就是简单点好做，不过他会有引入额外的空间吧，如果在面试中遇到的话，那就用链表去进行相加，这是面试官更像看到的。

​	这个题就是从头到尾的去加就行了，没啥说的。





## 3. 无重复字符的最长子串

​	看到子串，子序列，的话，经典的解法就是以i位置结尾的情况下，答案是什么。然后求所有可能的结尾就行了。



## 4. 寻找两个正序数组的中位数

这个题是训练营第四期第四节的第二题，找K个最大的数的一个变换。





# 20230201力扣高频视频2

## 5. 最长回文子串

这个就是Manacher的，就跳过了。



## 7.整数反转

这个题就是都给**转换为负数进行考虑，因为负数表示的范围大，就这个操作还是很常见的。**然后注意一下溢出的情况就行，还是比较简单的。比如说-2 **31这个数，取一个绝对值变成正数就表示不出来的，但是正数里面的所有范围都是可以被负数表示的。



## 8. 字符串转换整数 (atoi)

这个题和上面的题类似，不过要考虑的边界条件还是要多一点的。这个题差评很多的，学不到什么东西，就是边界条件恶心人。

​	不过这个题的思路很有意思的，==首先需要检查过滤的所有的非法的情况，然后才进行算法的设计==这个思路是好的。自己在设计代码的时候应该要注意。





## 10. 正则表达式匹配

这个还是动态规划里面比较难的问题的。详细看代码注释，有dp版本和递归版本还有记忆化搜索的版本，除了dp版本能通过，后面两个都通不了，不过只有最后一个测试样例有问题。

20230104 38经典面试二十二的题目1，是比较类似的。













## 11. 盛最多水的容器

遍历一遍就行了,左右两侧一起移动，哪边小结算哪一册。
这种求解思路不去想每个杆的最优解，而是让答案尽可能的大




## 12. 整数转罗马数字

这个题因为已经明说了数字的范围不会超过4000，所以可以做映射表来做。



## 13. 罗马数字转整数



跳过了吧，很简单



# 20230201力扣高频视频3



## 14. 最长公共前缀


思路很简单，把第一个字符串拿出来，然后遍历其他的每一个字符串，遍历到不一样就break



## 15. 三数之和



首先两数之和我们是能弄出来的。然后在两数之和的基础上就可以把这个三数之和的题给弄出来了。

​	想说两数之和，首先对数组进行排序，然后有一个LR指针，如果[L]+[R]大于k，那就R--，如果小于k，那就L++，如果相等，那就看一下L是不是等于L-1，如果不等那就收集答案。如果[L],[R]相等那L,R就随便往右动，或者R往左动都行的。

​	对于三元组的问题，K=0的时候是一种特殊情况，假设是有序的，那么遍历每一个arr[i],对于i位置，去找arr[i+1....end]位置的和为K-arr[i]的所有二数之和。如果i+1位置和i位置的值一样，那就直接跳过就行了。

​	代码中给出了正反两个解题的思路。其实区别不大。

​	==如果在面试中有一个O(N*logN)的方法和一个O(N)的方法，那O(N)的比`O（N*logN)的好`,如果还能再优化，那就是O(logN);但是如果是笔试的方法，那做对就行。==

​	一般来说，笔试中N=10^5次方，就是不卡常数，但是`N^2`的方法还是过不了。通过`10^8`次方，猜技巧是很重要的。





## 17. 电话号码的字母组合



这个题真简单，就是回溯的思想。。我只是一直懒得做这个电话的表格吧看来。。ennnn



## 19. 删除链表的倒数第 N 个结点

这个题其实没什么难的，主要是coding的调整。然后要考虑一下，可能会有换头节点的情况。

​	代码只扫描一遍，大逻辑就是，假如让我删除倒数第n个节点，那么在扫描的过程中当扫到第n个节点的时候，就做一个指针指向第一个节点，然后继续向下扫描这两个指针，当当前扫描到最后时，那么那个新加入的指针他就正好是倒数第n个节点了。但是上面只是在说一个大逻辑，但是其实我们应该要的是删掉节点的前一个节点，也就是当前扫描到最后的时候，新加入的指针正好是导数第n+1的节点。



## 20. 有效的括号

用个栈就行了。



## 21. 合并两个有序链表

跳了。



## 22. 括号生成

一个简单的回溯的题。如果还可以加左括号，那就加。如果还可以加右括号，那就加右。

​	这个题如果改为，只要合法数量的值，而不是合法的组合，那这个题就是卡特兰数的题。





## 23. 合并K个升序链表

```
小根堆。首先让头结点都放小根堆，然后弹出最小的，把这个头结点的下一个结点再放到小根堆里面，然后再弹出来。。。就是这个思路
```

​	这个题很简单的，不过也有意思，好好看看代码，主要是用了一个idx来区分，这个idx是该节点所在头结点的在数组的位置。



注意，为了让节点可以比较大小，这里就压入了(node.val,idx),加idx是因为我遇到了下面的报错，就是有相同的数，这里用idx区分了。

在写这个题的时候，遇到了一个错误：TypeError: '<' not supported between instances of 'ListNode' and 'ListNode'

这个错误的一个解决方法就是：

In the event that two or more of the lists have the same `val`, this code will error out since the `queue` module will compare the second element in the priority queue which is a `ListNode` object (and this is not a comparable type).

 

To solve for this issue, I have stored `(node.val, list_idx, node)` to account for this edge case.





# 20230202力扣高频视频4

## 26. 删除有序数组中的重复项



其实也就是一个快慢指针的东西吧。



## 28. 找出字符串中第一个匹配项的下标

KMP算法，跳过了。直接复习就行。



## 29. 两数相除

这个题emm老左的课弄的更吊一点不实现算数运算的东西。

​	这个题的代码，老左讲的很全的，加减乘除的位运算计算方法都给了。

这个题现在面试考的不多的。

==注意这个代码的加法我没用老左的，因为他是java平台的，我python平台用发现有问题，就参考的下面的[这个博客](https://blog.csdn.net/ustbbsy/article/details/82344003?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167530738016782427478040%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167530738016782427478040&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-82344003-null-null.142^v72^insert_chatgpt,201^v4^add_ask&utm_term=python%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%B4%9F%E6%95%B0%E5%8A%A0%E6%B3%95&spm=1018.2226.3001.4187)

==这个题代码有问题，建议不参考老左的了。学习思路就行==



## 33. 搜索旋转排序数组

有序数组找数，肯定是二分的。这个题考条件分类。就是假如说要找LR范围的数，M是中点，==如果[L],[M],[R]不都相等，那就一定能二分==，这是一个有意思的结论。这个题只要记住这个黄色的结论就行了，也不用背。







## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

这个题就是两个二分，很简单的。



## [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

这个题很简单，就是做一个简单的验证就行了。。





## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)



如果是让自己填数独的话，那就是深度优先，可以暴力尝试嘛，就每个格子都填每种可能，然后最后再验证行不行。所以这个题是要考察剪枝条件能不能写清楚的。然后需要注意的就是深度优先要清理现场的问题。





# 20230202力扣高频视频5



## 38. 外观数列

就是一个递归的。跳过。这个题的踩是赞的10倍







## 41. 缺失的第一个正数

这个题就是直接讲O(n)的时间复杂度和O(1)的空间复杂度去做了。



## 42. 接雨水

很经典了。只考虑i位置的水最多的，就是`[i] = max{0,min{max左-i,max右-i}}`



## 44. 通配符匹配

这个题和第十题很类似。这个的代码也写了很多的版本的，很好的题。1是暴力递归，2是dp，3是斜率优化的dp



# 20230202力扣高频视频6



## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

看代码，没啥说的。



## 45跳跃游戏II



看代码，没啥说的。



拓展：JumpGameIIFollowUpOn：给一个数组arr，给一个start和end，arr[i]意思是i只能去i-arr[i]或者i+arr[i]的地方如果崩不到就返回-1，问start到end至少多少步。这个题没听。这个题讲了1个多小时，还是很有意思的。不过我都快进了。





## [46. 全排列](https://leetcode.cn/problems/permutations/)

这个也没啥说的，很经典的回溯题。



# 20230203力扣高频视频7

## [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

就是找到右上节点和左下节点，然后画框就行。



这个也做过几次了，跳过。



## 687. 最长同值路径

非常典型的二叉树递归套路，可以多写写。



## 49. 字母异位词分组



```
把str1和str2排序，如果一样，那就说明他们是。
可以建立一个map,key是字符串排完序后的，value是一个列表，是排完序都是这个的。
```

原来这么简单。。草



## 50. Pow(x, n)

类似斐波那次数列的，快速幂的一个题，也很有意思的吧。这个题.py脚本里面的代码，其实严格来说是错的，虽然能通过力扣，下面的才是对的。

![image-20230203110637137](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203110637137-16753935988928.png)



## 54. 螺旋矩阵

下图是矩形的几种情况:

![image-20230203100015689](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203100015689-16753896174552.png)





# 20230203力扣高频视频8



## add有效的带分数形式



这是一个原创的题。

![image-20230203101825096](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203101825096.png)



首先可以想一个硬解的方法，随机排列0到九，然后随机向这个排列的结果中添加加号和除号，如果得到的表达式是有效的，那么就是对的一个答案，这个可能性也好算，首先算一下9!等于36W左右，然后放加号和除号可以知道有16中可能性，那么36W*16也就几百万，所以硬算也是可以的。

这个题考的就是优化，因为卡的有点紧，代码写的不太好就过不了，稍微好点就过了。

​	然后对于插入加减号的时候这里用整数而不是字符串会方便很多的，因为可以通过取模的方式得到9位数字排列的很多种可能性。可以做一个map，那么只有第一次调用的时候花时间，之后就不太花时间了。



![image-20230203103959948](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203103959948-16753920008154.png)





![image-20230203104009417](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203104009417-16753920109365.png)



![image-20230203104045243](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203104045243-16753920463767.png)



![image-20230203104033622](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203104033622-16753920348636.png)





如果加号位置在i，那么除号的位置只能从i/2开始，不然除不出来整数。





## 53. 最大子数组和

简单





## 62. 不同路径

这个题就是数学，也不用dp，就是排列组合的内容；不过这个题也不容易，不好实现组合

==不过下面这个做法还是别学了吧，不如dp==

![image-20230203112043156](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记4(力扣100).assets\image-20230203112043156-16753944442449.png)



# 20230203力扣高频视频9

## 56. 合并区间

先根据开始的位置进行排序，然后就遍历更新s,e这样。。这个题没啥算法，有点考验coding吧。





## 66. 加一

 没啥说的，看代码吧





## 69. x 的平方根

这个题就是二分法。看代码吧。



## 70. 爬楼梯

过了



## 73. 矩阵置零

这个题的难度在不能边变边改，这样不知道那个0是原始的0还是啥。

​	做一个行map，做一个列map，那么如果`arr[i][j]=0`,那么就把行map的i标记要变0，列map的j标记要变0.然后可以再优化，不用map，首先弄两个变量来记录一下，0行0列要不要变0，然后把0行0列就给解放出来了，来记录其他的行列要不要变。再绝一点，还可以只用1个变量，一个bool类型的，这个就不说了。。





## 75. 颜色分类

荷兰国旗的问题。看代码吧。



## 76. 最小覆盖子串

这个题实际上只有中等难度。







# 20230203力扣高频视频10

## 78. 子集

这玩意就是收集所有的子序列。



## 79. 单词搜索

标准的回溯，这个题很有意思的地方在于通过把`a[i][j]=0`来保证路径不走回头路,这就是增加现场 。

​	这个题是不需要改动态规划的，因为他的可变参数太多了。递归是一定能改为动态规划的，但是就是需要不需要改的一个问题。比如这个题就是改的话很复杂。



## 84.柱状图中最大的矩形

这个题不是完全的单调栈的实现的思路。这个题的一个简单的思路，就是[i]位置的高度知道了，然后去找他左右两边最大的高度，然后分别计算一下矩形，得到最大的，就是这个点的答案。这个题能用O(N)来拿下。



## 88. 合并两个有序数组

恶心人的题，很简单



## 91. 解码方法

经典的递归改动态规划的。



## 94. 二叉树的中序遍历

有关树的遍历的问题，morris遍历空间复杂度O(1),时间复杂度O(N)，那其实挺好的。

这个题用Morris遍历。



## 98. 验证二叉搜索树

很简单，中序遍历验证一下，那么也可以用morris遍历来做。



## 101. 对称二叉树

二叉树的递归套路,这个题很有意思的，虽然是简单题。并且有一个隐含的条件，那就是轴对称的树，不会出现只有一个孩子的，如果它存在只有一个孩子的，那肯定不会是对称的二叉树。



## 102. 二叉树的层序遍历

层序遍历用双端队列实现的。



## 103.二叉树的锯齿形层序遍历.

这个细节在代码里面有写注释的。然后可以发现这个代码里面有很多重复的代码块，其实是可以优化的，有兴趣可以自己去看看。



## 104. 二叉树的最大深度

简单看代码吧。





## 105. 从前序与中序遍历序列构造二叉树



这个题看代码就行，另外要注意！==要加一个限制，就是没有重复值==



## 108. 将有序数组转换为二叉搜索树




平衡的关键在于，中点做头,其实也很简单这个题。

## 116. 填充每个节点的下一个右侧节点指针

这个题只会在面试上出现，不然笔试出现的花，那就直接弄个队列，怎么快怎么来。



