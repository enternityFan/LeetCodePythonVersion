# 题型

训练营第二期class2的三个问题，是累加和数组三连问题。



# 1.覆盖问题（训练营3期第1节）



给定一系列x轴的点坐标，例如 1，3，7，8，9，11这些坐标升序放在数组中，
现在给一根绳子，长度为4，问绳子最多能覆盖的点数有多少，
例如绳子放前面只能覆盖两个点，1,3，如果放后面能覆盖4个点。



求解方法：1.二分法（N*logN),2.滑动窗口法(N)



# 2.括号有效配对问题

![image-20221116191818810](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116191818810-16685975003191.png)

对于问题1，可以用栈，但是没必要，只用一个变量cnt就行，遇到左括号就让cnt++，遇到右括号，就让cnt--，然后有两个原则：1）若过程中cnt<0那就直接返回false,2)遍历结束后看cnt是否等于0，若不是的话返回false.

对于问题2，用两个变量，一个cnt,一个need，当左括号就cnt++,右括号就cnt--,如果cnt==-1的话，那就说明右括号比左括号多1个，那就need++,然后从新把cnt恢复为0，最后返回cnt+next



# 3.最长的括号有效子串的长度（力扣32题）



![image-20221116192835645](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116192835645-16685981169632.png)假如子串必须以i位置的字符结尾，它最长的有效括号子串多长，那么以0,1,2,...n-1结尾都有一个答案，那么最终答案就是上面的n个答案种最大的。

​	dp就是构造辅助数组，看在求解i位置的答案时，是否i-1位置的答案有没有帮助。如果i位置是左括号，那么dp[i]=0,因为不会以左括号结尾，同时dp[0]==0。

```
	public static int maxLength(String s) {
		if (s == null || s.length() < 2) {
			return 0;
		}
		char[] str = s.toCharArray();
		int[] dp = new int[str.length];
		int pre = 0;
		int ans = 0;
		// dp[0] = 0;因为以0位置结尾肯定不会有效啊。
		for (int i = 1; i < str.length; i++) {
			if (str[i] == ')') {
				pre = i - dp[i - 1] - 1; // 与str[i]配对的左括号的位置 pre
				if (pre >= 0 && str[pre] == '(') {
					dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0);
				}
			}
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}
```



# 3.2有效括号最大嵌套层数



这个题给的就是有效的括号字符串。很简单，遇到左括号cnt++,右括号cnt---,cnt到达的最大值，就是嵌套的最大层数

```
	public static boolean isValid(char[] str) {
		if (str == null || str.length == 0) {
			return false;
		}
		int status = 0;
		for (int i = 0; i < str.length; i++) {
			if (str[i] != ')' && str[i] != '(') {
				return false;
			}
			if (str[i] == ')' && --status < 0) {
				return false;
			}
			if (str[i] == '(') {
				status++;
			}
		}
		return status == 0;
	}

	public static int deep(String s) {
		char[] str = s.toCharArray();
		if (!isValid(str)) {
			return 0;
		}
		int count = 0;
		int max = 0;
		for (int i = 0; i < str.length; i++) {
			if (str[i] == '(') {
				max = Math.max(max, ++count);
			} else {
				count--;
			}
		}
		return max;
	}
```







# 4.红和绿（爱奇艺笔试）





![image-20221116195859801](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116195859801-16685999407953.png)

枚举分界线。

**可以利用预处理数组的技巧来做**，准备一个辅助数字L，记录0到i位置上有几个G，再准备一个辅助数组R，记录从i到n-1的位置有几个R，然后直接在L，R数组中拿值就可以知道分界线的最好位置。

```
	// RGRGR -> RRRGG
	public static int minPaint(String s) {
		if (s == null || s.length() < 2) {
			return 0;
		}
		char[] str = s.toCharArray();
		int N = str.length;
		int rAll = 0;
		for (int i = 0; i < N; i++) {
			rAll += str[i] == 'R' ? 1 : 0;
		}
		int ans = rAll; // 如果数组所有的范围，都是右侧范围，都变成G 
		int left = 0;
		for (int i = 0; i < N - 1; i++) { // 0..i 左侧 n-1..N-1
			left += str[i] == 'G' ? 1 : 0;
			rAll -= str[i] == 'R' ? 1 : 0;
			ans = Math.min(ans, left + rAll);
		}
		// 0...N-1 左全部 右无，就和12行代码对称的，这个情况还没考虑。
		ans = Math.min(ans, left + (str[N - 1] == 'G' ? 1 : 0));
		return ans;
	}
```



# 5.边框全为1的最大正方形

![image-20221116201513049](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116201513049-16686009154274.png)

力扣\1139. 最大的以 1 为边界的正方形



​	对于一个NxN的矩形，其中长方形的数量是O(N^ 4),正方形的数量是O（N^ 3)   ,正方形这个就是，左上角点的选取概率是O(N^ 2),那么右下角的点是O(N),N是边长，为了维持正方形嘛，但是长方形的话右下角也是N^ 2 的选择的概率。

​	对于这个大流程，就是三个for循环，for row, for col, for边长，来找正方形。如果不优化的话，里面还有一个for是看边长上的点是否为1，那么这就是一个4阶的，但是这个最里面的for是可以从O（N）优化为O（1）的。

​	**可以用预处理数组来做**，r[i] [j]是(i,j)右边有多少个连续的1，d[i] [j]是(i,j)下面有多少个连续的 1.





# 6.构造数据

力扣\1968. 构造元素不等于两相邻元素平均值的数组有点类似，但很不一样的还是。

![image-20221116204839164](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116204839164-16686029207435.png)

如果有a+c !=2*b,那么可以把a,b,c转换为对应的奇数，即(2*a-1)+(2*c-1) !=2*(2*b-1),同样的也可以给替换为偶数，也是会满足这个公式的。那么如果长度为M，只需要长度为如果M是偶数，需要M//2,否则是(M+1)//2,通过分治法来实现。

​	这个题有点黑。



# 7.二叉树三种最大路径和 



剑指 Offer II 050. 向下的路径节点之和是2）的情况

![image-20221116210451900](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116210451900-16686038942956.png)

对于2,3题就是两种情况，1）与x有关，2）与x无关。x就是当前路径。前者有4中情况：1）x自己，2）x左边，3）x右边，4）x左右



# 8.有序矩阵找值

面试题 10.09. 排序矩阵查找是这个题；然后这个题没讲，不过看源码还挺简单的。从右上角或者左下角走都可以找到最好的答案。





# 9.机器打包问题

这个题硬记，是个很诡异的贪心，我就先跳过这个题吧。



# 10.左右子数组的最大差值

给定一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。



思路流程：**求数组中的最大值，然后减去0位置和i-1位置较小的那个一数。**；因为不管全局的max被分配到左部分还是右部分，最后的结果都是max减去左部分或者右部分的最大值。而右部分或者左部分一定或囊括0或者n-1位置





        //当最大值包含在左侧时，需要找到右侧相对较小的最大值，而右侧一定会包含arr[arr.length - 1]
        // 当右侧最后一个数为右侧最大值时，右侧怎么变化，左右两侧最大值差值也是 max - arr[arr.length - 1]
        // 当右侧最后一个数不是右侧最大值时，那么左右两个的最大差值会变小，是不会取到的
        // 同理，最大值包含在右侧，只需要找左侧相对较小的最大值，而arr[0]是一定包含的



# 11.装水问题

\42. 接雨水



![image-20221118085127928](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221118085127928-16687326891081.png)

解题思路：求第i位置上面有多少个水，为了知道i位置上面有多少个水，需要知道i位置的左侧和右侧的最大值，然后得到这两个值的最小值，再减去i位置的高度，就是这个位置能装的水。
$$
max(min(左max,右max),0)
$$
​	可以首先使用预处理数组，来把问题从N ** 2 优化到N，**当然这不是最优的。。最优的都不需要这玩意**





# 12.二维接雨水

\407. 接雨水 II

​	解题思路，首先做一个对象，存放num,row,col，表示这个num是row,col位置的数，然后做一个小根堆，把外围的数据给放到小根堆里面，然后用一个flag[ rows ][ cols \]大小标记数组，如果i,j位置的数进入了小根堆，那么就标记为True.

1. 把边沿每个数放入heap
2. heap中弹出堆顶
3. max - num > 0，那么把水量加到一个water的变量上，如果<0就不累加，然后把num所在的上下左右放到小根堆里面。（注意要查询flag,如果上下左右哪个进过小根堆了，就不要进）
4. 然后看看num是否更新max。





# 第四节6、搜索二叉树转换为有序的双向链表

剑指 Offer 36. 二叉搜索树与双向链表





# 第四节7、子矩阵的最大累加和

给定一个整形矩阵，返回子矩阵的最大累加和

力扣面试题 17.24. 最大子矩阵  类似

# 第五节2、编辑距离问题

力扣72. 编辑距离





# 第六节1、最大子数组异或和问题

一个数组的异或和是指数组中所有的数异或在一起的结果给定一个数组arr，求最大子数组异或和。







# 20221215 25经典面试九

## 题目四有序数组累加和前K个

![image-20221215115542539](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215115542539-16710765443911.png)

复杂度：O（n*logk)，利用大根堆实现的一个题。

```java
package class06;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class Code04_TopKSumCrossTwoArrays {

	// 放入大根堆中的结构
	public static class Node {
		public int index1;// arr1中的位置
		public int index2;// arr2中的位置
		public int sum;// arr1[index1] + arr2[index2]的值

		public Node(int i1, int i2, int s) {
			index1 = i1;
			index2 = i2;
			sum = s;
		}
	}

	// 生成大根堆的比较器
	public static class MaxHeapComp implements Comparator<Node> {
		@Override
		public int compare(Node o1, Node o2) {
			return o2.sum - o1.sum;
		}
	}

	public static int[] topKSum(int[] arr1, int[] arr2, int topK) {
		if (arr1 == null || arr2 == null || topK < 1) {
			return null;
		}
		// arr1 50  arr2 20   1000   topk 100万
		topK = Math.min(topK, arr1.length * arr2.length);

		int[] res = new int[topK];
		int resIndex = 0;

		PriorityQueue<Node> maxHeap = new PriorityQueue<>(new MaxHeapComp());

		// set[i][j] == false, arr1[i]  arr2[j] 之前，没进过
		// set[i][j] == true;  arr1[i]  arr2[j] 之前，进过
		boolean[][] set = new boolean[arr1.length][arr2.length];
		int i1 = arr1.length - 1;
		int i2 = arr2.length - 1;
		maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
		set[i1][i2] = true;
		while (resIndex != topK) {
			Node curNode = maxHeap.poll();
			res[resIndex++] = curNode.sum;
			i1 = curNode.index1;
			i2 = curNode.index2;
			if (i1 - 1 >= 0 && !set[i1 - 1][i2]) {
				set[i1 - 1][i2] = true;
				maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
			}
			if (i2 - 1 >= 0 && !set[i1][i2 - 1]) {
				set[i1][i2 - 1] = true;
				maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
			}
		}
		return res;
	}

	// For test, this method is inefficient but absolutely right
	public static int[] topKSumTest(int[] arr1, int[] arr2, int topK) {
		int[] all = new int[arr1.length * arr2.length];
		int index = 0;
		for (int i = 0; i != arr1.length; i++) {
			for (int j = 0; j != arr2.length; j++) {
				all[index++] = arr1[i] + arr2[j];
			}
		}
		Arrays.sort(all);
		int[] res = new int[Math.min(topK, all.length)];
		index = all.length - 1;
		for (int i = 0; i != res.length; i++) {
			res[i] = all[index--];
		}
		return res;
	}

	public static int[] generateRandomSortArray(int len) {
		int[] res = new int[len];
		for (int i = 0; i != res.length; i++) {
			res[i] = (int) (Math.random() * 50000) + 1;
		}
		Arrays.sort(res);
		return res;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static boolean isEqual(int[] arr1, int[] arr2) {
		if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i != arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		int a1Len = 5000;
		int a2Len = 4000;
		int k = 20000000;
		int[] arr1 = generateRandomSortArray(a1Len);
		int[] arr2 = generateRandomSortArray(a2Len);
		long start = System.currentTimeMillis();
		int[] res = topKSum(arr1, arr2, k);
		long end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		start = System.currentTimeMillis();
		int[] absolutelyRight = topKSumTest(arr1, arr2, k);
		end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		System.out.println(isEqual(res, absolutelyRight));

	}

}

```

## 题目五切分n分累加和相等

![image-20221215125450443](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215125450443-16710800912862.png)

算法复杂度：O(n)

这个题听讲解感觉还是很简单的重要的是思路，和敢式。

做一个map去记录位置i的前缀和，然后枚举第一刀，然后得到结果。

```

	public static boolean canSplits2(int[] arr) {
		if (arr == null || arr.length < 7) {
			return false;
		}
		// key 某一个累加和， value出现的位置
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		int sum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			map.put(sum, i);
			sum += arr[i];
		}
		int lsum = arr[0]; // 第一刀左侧的累加和
		for (int s1 = 1; s1 < arr.length - 5; s1++) { // s1是第一刀的位置
			int checkSum = lsum * 2 + arr[s1]; // 100 x 100   100*2 + x
			if (map.containsKey(checkSum)) {
				int s2 = map.get(checkSum); // j -> y
				checkSum += lsum + arr[s2];
				if (map.containsKey(checkSum)) { // 100 * 3 + x + y
					int s3 = map.get(checkSum); // k -> z
					if (checkSum + arr[s3] + lsum == sum) {
						return true;
					}
				}
			}
			lsum += arr[s1];
		}
		return false;
	}



```



## 题目六 交错组成



![image-20221215130305530](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215130305530-16710805866803.png)

这是一个动态规划的题，每个格子只依赖于其左侧和上侧的格子，并且需要用$str3[i][j]$进行判断

```
	public static boolean isCross1(String s1, String s2, String ai) {
		if (s1 == null || s2 == null || ai == null) {
			return false;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		char[] aim = ai.toCharArray();
		if (aim.length != str1.length + str2.length) {
			return false;
		}
		boolean[][] dp = new boolean[str1.length + 1][str2.length + 1];
		dp[0][0] = true;
		for (int i = 1; i <= str1.length; i++) {
			if (str1[i - 1] != aim[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		for (int j = 1; j <= str2.length; j++) {
			if (str2[j - 1] != aim[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i <= str1.length; i++) {
			for (int j = 1; j <= str2.length; j++) {
				
				if (
						
						(str1[i - 1] == aim[i + j - 1] && dp[i - 1][j])
						
						|| 
						
						(str2[j - 1] == aim[i + j - 1] && dp[i][j - 1])
						
						
				) {
					
					
					dp[i][j] = true;
					
					
				}
				
				
				
			}
		}
		return dp[str1.length][str2.length];
	}

	public static boolean isCross2(String str1, String str2, String aim) {
		if (str1 == null || str2 == null || aim == null) {
			return false;
		}
		char[] ch1 = str1.toCharArray();
		char[] ch2 = str2.toCharArray();
		char[] chaim = aim.toCharArray();
		if (chaim.length != ch1.length + ch2.length) {
			return false;
		}
		char[] longs = ch1.length >= ch2.length ? ch1 : ch2;
		char[] shorts = ch1.length < ch2.length ? ch1 : ch2;
		boolean[] dp = new boolean[shorts.length + 1];
		dp[0] = true;
		for (int i = 1; i <= shorts.length; i++) {
			if (shorts[i - 1] != chaim[i - 1]) {
				break;
			}
			dp[i] = true;
		}
		for (int i = 1; i <= longs.length; i++) {
			dp[0] = dp[0] && longs[i - 1] == chaim[i - 1];
			for (int j = 1; j <= shorts.length; j++) {
				if ((longs[i - 1] == chaim[i + j - 1] && dp[j]) || (shorts[j - 1] == chaim[i + j - 1] && dp[j - 1])) {
					dp[j] = true;
				} else {
					dp[j] = false;
				}
			}
		}
		return dp[shorts.length];
	}
```

## 题目一最短排序子数组长度

第七节

![image-20221215134838698](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215134838698-16710833198774.png)

时间复杂度O(n),空间复杂度O(1)

```
	public static int getMinLength(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int min = arr[arr.length - 1];
		int noMinIndex = -1;
		for (int i = arr.length - 2; i != -1; i--) {
			if (arr[i] > min) {
				noMinIndex = i;
			} else {
				min = Math.min(min, arr[i]);
			}
		}
		if (noMinIndex == -1) {
			return 0;
		}
		int max = arr[0];
		int noMaxIndex = -1;
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] < max) {
				noMaxIndex = i;
			} else {
				max = Math.max(max, arr[i]);
			}
		}
		return noMaxIndex - noMinIndex + 1;
	}
```

## 题目二最小不可组成和

![image-20221215135541289](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215135541289-16710837424095.png)

这个题的基础解法是，用背包问题的方法去做；然后进阶的解法是，如果arr一定有1，那么就可以做到O(nlogn)的时间复杂度。方法是首先排序，然后一定知道第一个数是1，可以准备一个range=1,表示从1-到range所有的数都可以加出来，对于arr[i]=a,有两种情况：1)a > range + 1,和2) a <=range+1,对于第二种情况，那么可以更新range = range + a;对于第一种情况，直接返回range+1就是结果。如果都没有遇到1）的情况，那就直接返回range+1就是结果。



下面代码中，前两个是背包的方法，第三个是进阶的方法。

```
public static int unformedSum1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		HashSet<Integer> set = new HashSet<Integer>();
		process(arr, 0, 0, set);
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			min = Math.min(min, arr[i]);
		}
		for (int i = min + 1; i != Integer.MIN_VALUE; i++) {
			if (!set.contains(i)) {
				return i;
			}
		}
		return 0;
	}

	public static void process(int[] arr, int i, int sum, HashSet<Integer> set) {
		if (i == arr.length) {
			set.add(sum);
			return;
		}
		process(arr, i + 1, sum, set);
		process(arr, i + 1, sum + arr[i], set);
	}

	public static int unformedSum2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		int sum = 0;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			sum += arr[i];
			min = Math.min(min, arr[i]);
		}
		// boolean[][] dp ...
		int N = arr.length;
		boolean[][] dp = new boolean[N][sum + 1];
		for (int i = 0; i < N; i++) {// arr[0..i] 0
			dp[i][0] = true;
		}
		dp[0][arr[0]] = true;
		for (int i = 1; i < N; i++) {
			for (int j = 1; j <= sum; j++) {
				dp[i][j] = dp[i - 1][j] || ((j - arr[i] >= 0) ? dp[i - 1][j - arr[i]] : false);
			}
		}
		for (int j = min; j <= sum; j++) {
			if (!dp[N - 1][j]) {
				return j;
			}
		}
		return sum + 1;
	}

	// 已知arr中肯定有1这个数
	public static int unformedSum3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		Arrays.sort(arr); // O (N * logN)
		int range = 1;
		// arr[0] == 1
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] > range + 1) {
				return range + 1;
			} else {
				range += arr[i];
			}
		}
		return range + 1;
	}
```

## 题目三 arr最少缺几个数

![image-20221215140849379](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215140849379-16710845302776.png)

这个题跟二进制很有关，如果实现了1-range的目标，但是没有达到1-aim，那么缺的永远是range+1;如果补上了range+1,那么此时的范围就会变为了1~(2*range+1)

```
// arr请保证有序，且正数
	public static int minPatches(int[] arr, int aim) {
		int patches = 0; // 缺多少个数字
		long range = 0; // 已经完成了1 ~ range的目标
		Arrays.sort(arr);
		for (int i = 0; i != arr.length; i++) {
			// 1~range
			// 1 ~ arr[i]-1
			while (arr[i] - 1 > range) { // arr[i] 1 ~ arr[i]-1
				range += range + 1; // range + 1 是缺的数字
				patches++;
				if (range >= aim) {
					return patches;
				}
			}
			range += arr[i];
			if (range >= aim) {
				return patches;
			}
		}
		while (aim >= range + 1) {
			range += range + 1;
			patches++;
		}
		return patches;
	}
```

## 题目六 没有重复字符子串的最长长度

![image-20221215142012396](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215142012396-16710852136367.png)

3. 无重复字符的最长子串(力扣)

这个题是用DP做的，不过我发现我之前是用滑动窗口做的。

```
public static int maxUnique(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		// map 替代了哈希表   假设字符的码是0~255
		int[] map = new int[256];
		for (int i = 0; i < 256; i++) {
			map[i] = -1;
		}
		int len = 0;
		int pre = -1;
		int cur = 0;
		for (int i = 0; i != chas.length; i++) {
			pre = Math.max(pre, map[chas[i]]);
			cur = i - pre;
			len = Math.max(len, cur);
			map[chas[i]] = i;
		}
		return len;
	}
```



# 20221216 26经典面试十

## 题目四 数组独立域

![image-20221215210002640](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215210002640-16711092040131.png)

并查集的题。如果有n个数，某个数值为V，那么算法可以优化为O(n*v),n为遍历数组，V为计算V这个数值是否是质数。这个算法最高可以优化为$ O(n*sqrt(V)) $，就是把2-sqrt(V)都当做V的质数，如果可以整除的话。

力扣\952. 按公因数计算最大组件大小；方法一会超时。



```
public static int largestComponentSize1(int[] arr) {
		int N = arr.length;
		UnionFind set = new UnionFind(N);
		for (int i = 0; i < N; i++) {
			for (int j = i + 1; j < N; j++) {
				if (gcd(arr[i], arr[j]) != 1) {
					set.union(i, j);
				}
			}
		}
		return set.maxSize();
	}

	public static int largestComponentSize2(int[] arr) {
		int N = arr.length;
		UnionFind unionFind = new UnionFind(N);
		HashMap<Integer, Integer> fatorsMap = new HashMap<>();
		for (int i = 0; i < N; i++) {
			int num = arr[i];
			int limit = (int) Math.sqrt(num);
			for (int j = 1; j <= limit; j++) {
				if (num % j == 0) {
					if (j != 1) {
						if (!fatorsMap.containsKey(j)) {
							fatorsMap.put(j, i);
						} else {
							unionFind.union(fatorsMap.get(j), i);
						}
					}
					int other = num / j;
					if (other != 1) {
						if (!fatorsMap.containsKey(other)) {
							fatorsMap.put(other, i);
						} else {
							unionFind.union(fatorsMap.get(other), i);
						}
					}
				}
			}
		}
		return unionFind.maxSize();
	}

	public static int gcd(int m, int n) {
	//辗转相除法，求最大公约数
		return n == 0 ? m : gcd(n, m % n);
	}

	public static class UnionFind {
		private int[] parents;
		private int[] sizes;
		private int[] help;

		public UnionFind(int N) {
			parents = new int[N];
			sizes = new int[N];
			help = new int[N];
			for (int i = 0; i < N; i++) {
				parents[i] = i;
				sizes[i] = 1;
			}
		}

		public int maxSize() {
			int ans = 0;
			for (int size : sizes) {
				ans = Math.max(ans, size);
			}
			return ans;
		}

		private int find(int i) {
			int hi = 0;
			while (i != parents[i]) {
				help[hi++] = i;
				i = parents[i];
			}
			for (hi--; hi >= 0; hi--) {
				parents[help[hi]] = i;
			}
			return i;
		}

		public void union(int i, int j) {
			int f1 = find(i);
			int f2 = find(j);
			if (f1 != f2) {
				int big = sizes[f1] >= sizes[f2] ? f1 : f1;
				int small = big == f1 ? f2 : f1;
				parents[small] = big;
				sizes[big] = sizes[f1] + sizes[f2];
			}
		}
	}
```

## 题目五 删除多于字符使每种只保留一个且字典序最小

![image-20221216122914348](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216122914348-16711649558341.png)

​	**删除的方案和保留的方案其实是一回事；如果挑了i位置的字符，那么不能再在左侧再挑字符，只能从i右侧挑选，这种方式其实也不会错过答案的。**

​	首先先统计一下词频，

方法1是讲的。如果有K种字符，那么复杂度为O（KN）

```
// 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回
	public static String removeDuplicateLetters1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		int[] map = new int[256];
		for (int i = 0; i < str.length(); i++) {
			map[str.charAt(i)]++;
		}
		int minACSIndex = 0;
		for (int i = 0; i < str.length(); i++) {
			minACSIndex = str.charAt(minACSIndex) > str.charAt(i) ? i : minACSIndex;
			if (--map[str.charAt(i)] == 0) {
				break;
			}
		}
		return String.valueOf(str.charAt(minACSIndex)) + removeDuplicateLetters1(
				str.substring(minACSIndex + 1).replaceAll(String.valueOf(str.charAt(minACSIndex)), ""));
	}

	public static String removeDuplicateLetters2(String s) {
		char[] str = s.toCharArray();
		// 小写字母ascii码值范围[97~122]，所以用长度为26的数组做次数统计
		// 如果map[i] > -1，则代表ascii码值为i的字符的出现次数
		// 如果map[i] == -1，则代表ascii码值为i的字符不再考虑
		int[] map = new int[26];
		for (int i = 0; i < str.length; i++) {
			map[str[i] - 'a']++;
		}
		char[] res = new char[26];
		int index = 0;
		int L = 0;
		int R = 0;
		while (R != str.length) {
			// 如果当前字符是不再考虑的，直接跳过
			// 如果当前字符的出现次数减1之后，后面还能出现，直接跳过
			if (map[str[R] - 'a'] == -1 || --map[str[R] - 'a'] > 0) {
				R++;
			} else { // 当前字符需要考虑并且之后不会再出现了
				// 在str[L..R]上所有需要考虑的字符中，找到ascii码最小字符的位置
				int pick = -1;
				for (int i = L; i <= R; i++) {
					if (map[str[i] - 'a'] != -1 && (pick == -1 || str[i] < str[pick])) {
						pick = i;
					}
				}
				// 把ascii码最小的字符放到挑选结果中
				res[index++] = str[pick];
				// 在上一个的for循环中，str[L..R]范围上每种字符的出现次数都减少了
				// 需要把str[pick + 1..R]上每种字符的出现次数加回来
				for (int i = pick + 1; i <= R; i++) {
					if (map[str[i] - 'a'] != -1) { // 只增加以后需要考虑字符的次数
						map[str[i] - 'a']++;
					}
				}
				// 选出的ascii码最小的字符，以后不再考虑了
				map[str[pick] - 'a'] = -1;
				// 继续在str[pick + 1......]上重复这个过程
				L = pick + 1;
				R = L;
			}
		}
		return String.valueOf(res, 0, index);
	}
```



## 题目七 直线最多穿越多少点

![image-20221216124515155](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216124515155-16711659163882.png)

​	力扣\149. 直线上最多的点数



思路：遍历每个点(x0,y0)，查看必须通过这个点，最多会穿过多少个点。对于两个点p1,p2有四种关系:1)重合2）水平，p1p2点共Y；3）垂直，p1p2共X；4）p1p2有斜率.。（p1y-p2y)/(p1x-p2x)

​	对于p1点，统计:1)多少点与p1重合;2)在不重合的情况下有多少和p1共y,3)有多少不重合的情况下与p1是共x，4）是一个map，key为一个斜率，value为在这个斜率下有多少个点共现的。

复杂度是O（N^2)的。**这道题难点在于怎么表示斜率**,应该用最大公倍数的字符串的形式去表示，比如20/30，那么就用"2_3"来表示，或者用二维表进行表示，比如{1:{3:2,4:2,5:2}}就表示1/3有2个;1/4有2个，1/5有2个。

```
	public static class Point {
		public int x;
		public int y;

		Point() {
			x = 0;
			y = 0;
		}

		Point(int a, int b) {
			x = a;
			y = b;
		}
	}

	public static int maxPoints(Point[] points) {
		if (points == null) {
			return 0;
		}
		if (points.length <= 2) {
			return points.length;
		}
		// key : 分子  value : 分母表
		Map<Integer, Map<Integer, Integer>> map = new HashMap<Integer, Map<Integer, Integer>>();
		int result = 0;
		for (int i = 0; i < points.length; i++) {
			map.clear();
			int samePosition = 1;
			int sameX = 0;
			int sameY = 0;
			int line = 0;
			for (int j = i + 1; j < points.length; j++) {
				int x = points[j].x - points[i].x;
				int y = points[j].y - points[i].y;
				if (x == 0 && y == 0) {
					samePosition++;
				} else if (x == 0) {
					sameX++;
				} else if (y == 0) {
					sameY++;
				} else {
					int gcd = gcd(x, y);
					x /= gcd;
					y /= gcd;
					if (!map.containsKey(x)) {
						map.put(x, new HashMap<Integer, Integer>());
					}
					if (!map.get(x).containsKey(y)) {
						map.get(x).put(y, 0);
					}
					map.get(x).put(y, map.get(x).get(y) + 1);
					line = Math.max(line, map.get(x).get(y));
				}
			}
			result = Math.max(result, Math.max(Math.max(sameX, sameY), line) + samePosition);
		}
		return result;
	}

	// 保证初始调用的时候，a和b不等于0
	public static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
```



## 题目四通关怪兽最少花费（从这里开始第八节了）

![image-20221216131036894](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216131036894-16711674384413.png)

DP有两种思路，一种是$DP[N][M]$,M为怪兽能力，这种方法在当M很大时，可能会有问题；第二种方法为$DP[I][J]$想来到I号怪兽，要严格正好花够J元时，最大能力是多少。 所以具体来说还是第二种方法更好，==这个是腾讯的原题，当时N给的500，能力最多1e6,钱是200==





```
	// int[] d d[i]：i号怪兽的武力
	// int[] p p[i]：i号怪兽要求的钱
	// ability 当前你所具有的能力
	// index 来到了第index个怪兽的面前

	// 目前，你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，
	// 请返回需要花的最少钱数
	public static long process(int[] d, int[] p, int ability, int index) {
		if (index == d.length) {
			return 0;
		}
		if (ability < d[index]) {
			return p[index] + process(d, p, ability + d[index], index + 1);
		} else { // 可以贿赂，也可以不贿赂
			return 
					Math.min(
							p[index] + process(d, p, ability + d[index], index + 1),
						    process(d, p, ability, index + 1)
							);
		}
	}

	public static long func1(int[] d, int[] p) {
		return process(d, p, 0, 0);
	}

	public static long func2(int[] d, int[] p) {
		int sum = 0;
		for (int num : d) {
			sum += num;
		}
		long[][] dp = new long[d.length + 1][sum + 1];
		for (int i = 0; i <= sum; i++) {
			dp[0][i] = 0;
		}
		for (int cur = d.length - 1; cur >= 0; cur--) {
			for (int hp = 0; hp <= sum; hp++) {
				// 如果这种情况发生，那么这个hp必然是递归过程中不会出现的状态
				// 既然动态规划是尝试过程的优化，尝试过程碰不到的状态，不必计算
				if (hp + d[cur] > sum) {
					continue;
				}
				if (hp < d[cur]) {
					dp[cur][hp] = p[cur] + dp[cur + 1][hp + d[cur]];
				} else {
					dp[cur][hp] = Math.min(p[cur] + dp[cur + 1][hp + d[cur]], dp[cur + 1][hp]);
				}
			}
		}
		return dp[0][0];
	}

	public static long func3(int[] d, int[] p) {
		int sum = 0;
		for (int num : p) {
			sum += num;
		}
		// dp[i][j]含义：
		// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
		int[][] dp = new int[d.length][sum + 1];
		for (int i = 0; i < dp.length; i++) {
			for (int j = 0; j <= sum; j++) {
				dp[i][j] = -1;
			}
		}
		// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
		dp[0][p[0]] = d[0];
		for (int i = 1; i < d.length; i++) {
			for (int j = 0; j <= sum; j++) {
				// 可能性一，为当前怪兽花钱
				// 存在条件：
				// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
				if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
					dp[i][j] = dp[i - 1][j - p[i]] + d[i];
				}
				// 可能性二，不为当前怪兽花钱
				// 存在条件：
				// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
				if (dp[i - 1][j] >= d[i]) {
					// 两种可能性中，选武力值最大的
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
				}
			}
		}
		int ans = 0;
		// dp表最后一行上，dp[N-1][j]代表：
		// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
		for (int j = 0; j <= sum; j++) {
			if (dp[d.length - 1][j] != -1) {
				ans = j;
				break;
			}
		}
		return ans;
	}
```

## 题目六 最少添加使回文

![image-20221216133712272](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216133712272-16711690340834.png)

这个题是可以在字符串任意位置添加的！

```
	public static String getPalindrome1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = getDP(chas);
		char[] res = new char[chas.length + dp[0][chas.length - 1]];
		int i = 0;
		int j = chas.length - 1;
		int resl = 0;
		int resr = res.length - 1;
		while (i <= j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) {
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else {
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}

	public static int[][] getDP(char[] str) {
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) {
					dp[i][j] = dp[i + 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		return dp;
	}

```

拓展：不仅要告诉有多少种，还要告诉变成怎样的回文串。就是反推吧，反正听着也挺有启发的。



# 20221216 27经典面试十一

## 题目一 信息接受打印结构

![image-20221216183247668](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216183247668-16711867685785.png)

主要是利用单链表+哈希表实现的。在直播的场景中总常用的



```
public static class Node {
		public String info;
		public Node next;

		public Node(String str) {
			info = str;
		}
	}

	public static class MessageBox {
		private HashMap<Integer, Node> headMap;
		private HashMap<Integer, Node> tailMap;
		private int waitPoint;

		public MessageBox() {
			headMap = new HashMap<Integer, Node>();
			tailMap = new HashMap<Integer, Node>();
			waitPoint = 1;
		}

		// 消息的编号，info消息的内容, 消息一定从1开始
		public void receive(int num, String info) {
			if (num < 1) {
				return;
			}
			Node cur = new Node(info);
			// num~num
			headMap.put(num, cur);
			tailMap.put(num, cur);
			// 建立了num~num这个连续区间的头和尾
			// 查询有没有某个连续区间以num-1结尾
			if (tailMap.containsKey(num - 1)) {
				tailMap.get(num - 1).next = cur;
				tailMap.remove(num - 1);
				headMap.remove(num);
			}
			// 查询有没有某个连续区间以num+1开头的
			if (headMap.containsKey(num + 1)) {
				cur.next = headMap.get(num + 1);
				tailMap.remove(num);
				headMap.remove(num + 1);
			}
			if (num == waitPoint) {
				print();
			}
		}

		private void print() {
			Node node = headMap.get(waitPoint);
			headMap.remove(waitPoint);
			while (node != null) {
				System.out.print(node.info + " ");
				node = node.next;
				waitPoint++;
			}
			tailMap.remove(waitPoint-1);
			System.out.println();
		}

	}

	public static void main(String[] args) {
		// MessageBox only receive 1~N
		MessageBox box = new MessageBox();

		box.receive(2,"B"); // - 2"
		box.receive(1,"A"); // 1 2 -> print, trigger is 1

		box.receive(4,"D"); // - 4
		box.receive(5,"E"); // - 4 5
		box.receive(7,"G"); // - 4 5 - 7
		box.receive(8,"H"); // - 4 5 - 7 8
		box.receive(6,"F"); // - 4 5 6 7 8
		box.receive(3,"C"); // 3 4 5 6 7 8 -> print, trigger is 3

		box.receive(9,"I"); // 9 -> print, trigger is 9

		box.receive(10,"J"); // 10 -> print, trigger is 10

		box.receive(12,"L"); // - 12
		box.receive(13,"M"); // - 12 13
		box.receive(11,"K"); // 11 12 13 -> print, trigger is 11

	}
```



## 题目二 纪念币与普通币的拼法

![image-20221223084931073](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223084931073-16717565722751.png)

这个题是DP的题，介绍了一种优化有枚举行为的方法，挺有意思的。



 对于普通币，是有枚举的优化，对于纪念币，就是背包问题。

这个题看着很难，但是其实就是中等难度的题。。。笔试原题。



```
public static int moneyWays(int[] arbitrary, int[] onlyone, int money) {
		if (money < 0) {
			return 0;
		}
		if ((arbitrary == null || arbitrary.length == 0) && (onlyone == null || onlyone.length == 0)) {
			return money == 0 ? 1 : 0;
		}
		// 任意张 的数组， 一张的数组，不可能都没有
		int[][] dparb = getDpArb(arbitrary, money);
		int[][] dpone = getDpOne(onlyone, money);
		if (dparb == null) { // 任意张的数组没有，一张的数组有
			return dpone[dpone.length - 1][money];
		}
		if (dpone == null) { // 任意张的数组有，一张的数组没有
			return dparb[dparb.length - 1][money];
		}
		int res = 0;
		for (int i = 0; i <= money; i++) {
			res += dparb[dparb.length - 1][i] * dpone[dpone.length - 1][money - i];
		}
		return res;
	}

	public static int[][] getDpArb(int[] arr, int money) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int[][] dp = new int[arr.length][money + 1];
		// dp[i][j] 0..i券 自由选择张数， 搞定j元， 有多少方法？

		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		// [0] 5元 0元 5元 10元 15元 20元
		for (int j = 1; arr[0] * j <= money; j++) {
			dp[0][arr[0] * j] = 1;
		}
		// 0行 0列 填完了
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= money; j++) {
				dp[i][j] = dp[i - 1][j];
				dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;
			}
		}
		return dp;
	}

	public static int[][] getDpOne(int[] arr, int money) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int[][] dp = new int[arr.length][money + 1];
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		if (arr[0] <= money) {
			dp[0][arr[0]] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= money; j++) {
				dp[i][j] = dp[i - 1][j];
				dp[i][j] += j - arr[i] >= 0 ? dp[i - 1][j - arr[i]] : 0;
			}
		}
		return dp;
	}
```

## 题目三 在写下1-N所有数字时写下了多少1

力扣 233. 数字 1 的个数



**![image-20221223085002395](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223085002395.png)**

这个题老师说很难。这个题不属于经典的DP问题，他是数位DP模型，他在比赛中经常出现，在面试中不总出现的。

1. 树形DP：二叉树递归套路
2. 矩乘DP斐波那数列的模型
3. 从左到右尝试模型（背包问题）
4. 范围尝试
5. 对应模型
6. 业务模型

以上6中就能满足95%的在面试中，其他5%里就是有这个数位DP模型，然后这个介绍的题是比较常见的。

```
public static int solution2(int num) {
		if (num < 1) {
			return 0;
		}
		// num -> 13625
		// len = 5位数
		int len = getLenOfNum(num);
		if (len == 1) {
			return 1;
		}
		// num 13625
		// tmp1 10000
		// num 7872328738273
		// tmp1 1000000000000
		int tmp1 = powerBaseOf10(len - 1);
		// num最高位 num / tmp1
		int first = num / tmp1;
		// 最高1 N % tmp1 + 1
		// 最高位first tmp1
		int firstOneNum = first == 1 ? num % tmp1 + 1 : tmp1;
		// 除去最高位之外，剩下1的数量
		// 最高位1 10(k-2次方) * (k-1) * 1
		// 最高位first 10(k-2次方) * (k-1) * first
		int otherOneNum = first * (len - 1) * (tmp1 / 10);
		return firstOneNum + otherOneNum + solution2(num % tmp1);
	}

	public static int getLenOfNum(int num) {
		int len = 0;
		while (num != 0) {
			len++;
			num /= 10;
		}
		return len;
	}

	public static int powerBaseOf10(int base) {
		return (int) Math.pow(10, base);
	}
```








# 20221223 28 经典面试十二

## 题目五 最大整合子数组的长度

![image-20221223102045044](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223102045044-16717620464652.png)

最优解是，首先穷举所有的子数组，然后只要满足1）子数组没有重复值，2）最大值减去最小值=子数组的长度，那么这就是一个整合子数组了。这是一个0（N^2)的难度。

==看到这个题，应该学会，如果定义写的很蛋疼，那么应该想想可以不可以优化下==



```
	public static int getLIL2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int len = 0;
		int max = 0;
		int min = 0;
		HashSet<Integer> set = new HashSet<Integer>();
		for (int L = 0; L < arr.length; L++) { // L 左边界
			// L .......
			set.clear();
			max = Integer.MIN_VALUE;
			min = Integer.MAX_VALUE;
			for (int R = L; R < arr.length; R++) { // R 右边界
				// arr[L..R]这个子数组在验证   l...R L...r+1  l...r+2  
				if (set.contains(arr[R])) {
					// arr[L..R]上开始 出现重复值了，arr[L..R往后]不需要验证了，
					// 一定不是可整合的
					break;
				}
				// arr[L..R]上无重复值
				set.add(arr[R]);
				max = Math.max(max, arr[R]);
				min = Math.min(min, arr[R]);
				if (max - min == R - L) { // L..R 是可整合的
					len = Math.max(len, R - L + 1);
				}
			}
		}
		return len;
	}
```



## 题目一 股票交易最大钱数

==第四期第二节题目==

![image-20221223112043540](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112043540-16717656443053.png)

这个就是假如i位置卖，那么在i位置之前最小的时候买就行了，很简单,最后看这些情况里最大的。



```
	public int maxProfit(int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int min = prices[0];
		int ans = 0;
		for (int i = 0; i < prices.length; i++) {
			min = Math.min(min, prices[i]);
			ans = Math.max(ans, prices[i] - min);
		}
		return ans;
	}
```

## 题目二 股票交易2

![image-20221223112409422](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112409422-16717658503214.png)

对于i位置是a，i-1位置是b，那么对于所有b>a的，(b-a)的所有值的和就是了。这其实就是个上坡的问题。

```
	public static int maxProfit(int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int ans = 0;
		for (int i = 1; i < prices.length; i++) {
            ans += Math.max(prices[i] - prices[i-1], 0);
		}
		return ans;
	}
```



## 题目三 股票交易3（这个有点难了）

这个属于DP。

![image-20221223112731502](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112731502-16717660526695.png)



假设数组长度知道，那么交易不超过K次，如果K>N/2,那么等同于无限次交易。有一个结论，==如果数组长度为N，那么大上坡的数量不会大于N/2的==。那么对于K>N/2的情况，就可以直接用题目二，就是股票交易2的代码得到。如果K<N/2,那么做一个DP表，$dp[i][j]$表示arr[0...i]交易次数小于等于j次获得的最大钱数。第一列就肯定全是0块钱。对于$dp[i][j]$有几种情况1)第[i]次就不参与教育，那么就是直接$dp[i-1][j]$，第二种可能性，就是[i]号参与了交易，并且他肯定只是参与的最后一次交易的卖出操作，那么在第二种可能性下又有i可能性：1)$dp[i][j-1] + [i] - [i]$,2)$dp[i-1][j-1]+[i] - [i-1]$...这里是一个枚举。这是一个枚举行为，那么就可以优化。

```
	public static int dp(int K, int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int N = prices.length;
		if (K >= N / 2) {
			return allTrans(prices);
		}
		int[][] dp = new int[N][K + 1];
		int ans = 0;
		for (int j = 1; j <= K; j++) {
			int t = dp[0][j - 1] - prices[0];
			for (int i = 1; i < N; i++) {
				t = Math.max(t, dp[i][j - 1] - prices[i]);
				dp[i][j] = Math.max(dp[i - 1][j], t + prices[i]);
				ans = Math.max(ans, dp[i][j]);
			}
		}
		return ans;
	}

	public static int maxProfit(int K, int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int N = prices.length;
		if (K >= N / 2) {
			return allTrans(prices);
		}
		// dp一维表，做了空间压缩
		int[] dp = new int[N];
		int ans = 0;
		for (int tran = 1; tran <= K; tran++) {
			int pre = dp[0];
			int best = pre - prices[0];
			for (int index = 1; index < N; index++) {
				pre = dp[index];
				dp[index] = Math.max(dp[index - 1], prices[index] + best);
				best = Math.max(best, pre - prices[index]);
				ans = Math.max(dp[index], ans);
			}
		}
		return ans;
	}

	public static int allTrans(int[] prices) {
		int ans = 0;
		for (int i = 1; i < prices.length; i++) {
			ans += Math.max(prices[i] - prices[i - 1], 0);
		}
		return ans;
	}
```





# 20221223 29 经典面试十三

第四期第一节的题。

## 题目二 离K最近的子数组累加和

![image-20221223114902130](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223114902130-16717673433776.png)

这个是用前缀和做的。

子数组问题，往往都是以i位置结尾的答案里最好的。这个题要用有序表去做。这里因为没有单调性，所以不能用窗口的方法去做。



```
	// 请返回arr中，求个子数组的累加和，是<=K的，并且是最大的。
	// 返回这个最大的累加和
	public static int getMaxLessOrEqualK(int[] arr, int K) {
		// 记录i之前的，前缀和，按照有序表组织
		TreeSet<Integer> set = new TreeSet<Integer>();
		// 一个数也没有的时候，就已经有一个前缀和是0了
		set.add(0);

		int max = Integer.MIN_VALUE;
		int sum = 0;
		// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是<=K的，并且是最大的
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i]; // sum -> arr[0..i];
			if (set.ceiling(sum - K) != null) {
				max = Math.max(max, sum - set.ceiling(sum - K));
			}
			set.add(sum); // 当前的前缀和加入到set中去
		}
		return max;

	}
```



## 题目三 离K最近的子矩阵累加和

![image-20221223160002906](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223160002906-16717824037357.png)

这个题的解题思路讲过,

```
	public static int maxSumSubmatrix(int[][] matrix, int k) {
		if (matrix == null || matrix[0] == null)
			return 0;
		int row = matrix.length, col = matrix[0].length, res = Integer.MIN_VALUE;
		TreeSet<Integer> sumSet = new TreeSet<>();
		for (int s = 0; s < row; s++) { // s开始行
			int[] colSum = new int[col];
			for (int e = s; e < row; e++) { // e结束行
				// 子矩阵必须包含s~e行的数，且只包含s~e行的数
				sumSet.add(0);
				int rowSum = 0;
				for (int c = 0; c < col; c++) {
					colSum[c] += matrix[e][c];
					rowSum += colSum[c];
					Integer it = sumSet.ceiling(rowSum - k);
					if (it != null) {
						res = Math.max(res, rowSum - it);
					}
					sumSet.add(rowSum);
				}
				sumSet.clear();
			}
		}
		return res;
	}
```





## 题目一 最大递增链的长度

![image-20221223160620650](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223160620650-16717827829878.png)



下面的代码第一个就是递归实现的，第二个就是用傻缓存优化的,这个优化的后的时间复杂度是O(NM)。

```
public static int maxPath(int[][] matrix) {
		int ans = Integer.MIN_VALUE;
		for (int row = 0; row < matrix.length; row++) {
			for (int col = 0; col < matrix[0].length; col++) {
				ans = Math.max(ans, process(matrix, row, col));
			}
		}
		return ans;
	}

	// 假设在matrix中，从i行，j列出发，能走出的最长递增路径，返回最长递增路径的长度
	public static int process(int[][] matrix, int i, int j) {
		if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) {
			return -1;
		}
		int up = 0;
		int down = 0;
		int left = 0;
		int right = 0;
		if (i - 1 >= 0 && matrix[i - 1][j] > matrix[i][j]) {
			up = process(matrix, i - 1, j);
		}
		if (i + 1 < matrix.length && matrix[i + 1][j] > matrix[i][j]) {
			down = process(matrix, i + 1, j);
		}
		if (j - 1 >= 0 && matrix[i][j - 1] > matrix[i][j]) {
			left = process(matrix, i, j - 1);
		}
		if (j + 1 < matrix[0].length && matrix[i][j + 1] > matrix[i][j]) {
			right = process(matrix, i, j + 1);
		}
		return 1 + Math.max(Math.max(up, down), Math.max(left, right));
	}

	public static int maxPath2(int[][] matrix) {
		int ans = Integer.MIN_VALUE;

		int[][] dp = new int[matrix.length][matrix[0].length];

		for (int row = 0; row < matrix.length; row++) {
			for (int col = 0; col < matrix[0].length; col++) {
				ans = Math.max(ans, process(matrix, row, col, dp));
			}
		}
		return ans;
	}

	// 假设在matrix中，从i行，j列出发，能走出的最长递增路径，返回
	// dp[i][j] == 0 process(i,j) 之前没遇到过
	// dp[i][j] != 0 process(i,j) 之前已经算过了
	public static int process(int[][] matrix, int i, int j, int[][] dp) {
		if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) {
			return -1;
		}
		if (dp[i][j] != 0) {
			return dp[i][j];
		}
		int next1 = 0;
		int next2 = 0;
		int next3 = 0;
		int next4 = 0;
		if (i - 1 >= 0 && matrix[i - 1][j] > matrix[i][j]) {
			next1 = process(matrix, i - 1, j);
		}
		if (i + 1 < matrix.length && matrix[i + 1][j] > matrix[i][j]) {
			next2 = process(matrix, i + 1, j);
		}
		if (j - 1 >= 0 && matrix[i][j - 1] > matrix[i][j]) {
			next3 = process(matrix, i, j - 1);
		}
		if (j + 1 < matrix[0].length && matrix[i][j + 1] > matrix[i][j]) {
			next4 = process(matrix, i, j + 1);
		}
		int ans = 1 + Math.max(Math.max(next1, next2), Math.max(next3, next4));
		dp[i][j] = ans;
		return ans;
	}

	public static int longestIncreasingPath(int[][] m) {
		if (m == null || m.length == 0 || m[0].length == 0) {
			return 0;
		}
		int[][] dp = new int[m.length][m[0].length];
		// dp[i][j] (i,j)出发，走出的最长链长度
		int max = 0;
		for (int i = 0; i < m.length; i++) {
			for (int j = 0; j < m[0].length; j++) {
				// 每一个(i,j)位置出发，都尝试
				max = Math.max(max, maxIncrease(m, dp, i + 1, j, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i, j + 1, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i - 1, j, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i, j - 1, m[i][j]) + 1);
			}

		}
		return max;
	}

	// 来到的当前位置是i,j位置
	// p 上一步值是什么
	// 从(i,j)位置出发，走出的最长链，要求：上一步是可以迈到当前步上的
	public static int maxIncrease(int[][] m, int[][] dp, int i, int j, int p) {
		if (i < 0 || i >= m.length || j < 0 || j >= m[0].length || m[i][j] <= p) {
			return 0;
		}
		if (dp[i][j] == 0) { // i,j 出发，当前没算过
			dp[i][j] = maxIncrease(m, dp, i + 1, j, m[i][j]) + 1;
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i, j + 1, m[i][j]) + 1);
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i - 1, j, m[i][j]) + 1);
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i, j - 1, m[i][j]) + 1);
		}
		return dp[i][j];
	}
```

## 题目四\212. 单词搜索 II



力扣212.单词搜索 II

这个题和题目五很重要，代表了递归的能力。

![image-20221223162104378](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223162104378-16717836658049.png)

路径不能重复走的意思就是，比如说【a  s;e  t】，那么不能走出来astst这个单词，因为回重复走。做这个题要想明白，1）怎么实现我已经走出来word了？我怎么知道？2）应该做的是深度优先遍历，就是先往一个方向走的不能再走了，再换方向，这样做的话可以实现标记，知道哪个点走过了。这两个点实现的方式就是前缀树。把words加入到前缀树，那么首先这样也可以筛选起点，一看起点就不是，那就去遍历另外一个点，这样。

这个代码写的很妙，尤其是递归的返回值再结合字典树又进行了一下加速，帅。

==这个题是故意设计出来考验那个剪枝技巧的==



```
public static class TrieNode {
		public TrieNode[] nexts;
		public int pass;
		public int end;

		public TrieNode() {
			nexts = new TrieNode[26];
			pass = 0;
			end = 0;
		}

	}

	public static void fillWord(TrieNode head, String word) {
		head.pass++;
		char[] chs = word.toCharArray();
		int index = 0;
		TrieNode node = head;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.nexts[index] == null) {
				node.nexts[index] = new TrieNode();
			}
			node = node.nexts[index];
			node.pass++;
		}
		node.end++;
	}

	public static String generatePath(LinkedList<Character> path) {
		char[] str = new char[path.size()];
		int index = 0;
		for (Character cha : path) {
			str[index++] = cha;
		}
		return String.valueOf(str);
	}

	public static List<String> findWords(char[][] board, String[] words) {
		TrieNode head = new TrieNode(); // 前缀树最顶端的头
		HashSet<String> set = new HashSet<>();
		for (String word : words) {
			if (!set.contains(word)) {
				fillWord(head, word);
				set.add(word);
			}
		}
		// 答案
		List<String> ans = new ArrayList<>();
		// 沿途走过的字符，收集起来，存在path里
		LinkedList<Character> path = new LinkedList<>();
		for (int row = 0; row < board.length; row++) {
			for (int col = 0; col < board[0].length; col++) {
				// 枚举在board中的所有位置
				// 每一个位置出发的情况下，答案都收集
				process(board, row, col, path, head, ans);
			}
		}
		return ans;
	}

	// 从board[row][col]位置的字符出发，
	// 之前的路径上，走过的字符，记录在path里
	// cur还没有登上，有待检查能不能登上去的前缀树的节点
	// 如果找到words中的某个str，就记录在 res里
	// 返回值，从row,col 出发，一共找到了多少个str
	public static int process(
			char[][] board, 
			int row, int col,
			LinkedList<Character> path,
			TrieNode cur, 
			List<String> res) {
		char cha = board[row][col];
		if (cha == 0) { // 这个row col位置是之前走过的位置
			return 0;
		}
		// (row,col) 不是回头路   cha 有效
		
		int index = cha - 'a';
		// 如果没路，或者这条路上最终的字符串之前加入过结果里
		if (cur.nexts[index] == null || cur.nexts[index].pass == 0) {
			return 0;
		}
		// 没有走回头路且能登上去
		cur = cur.nexts[index];
		path.addLast(cha);// 当前位置的字符加到路径里去
		int fix = 0; // 从row和col位置出发，后续一共搞定了多少答案
		// 当我来到row col位置，如果决定不往后走了。是不是已经搞定了某个字符串了
		if (cur.end > 0) { 
			res.add(generatePath(path));
			cur.end--;
			fix++;
		}
		// 往上、下、左、右，四个方向尝试
		board[row][col] = 0;
		if (row > 0) {
			fix += process(board, row - 1, col, path, cur, res);
		}
		if (row < board.length - 1) {
			fix += process(board, row + 1, col, path, cur, res);
		}
		if (col > 0) {
			fix += process(board, row, col - 1, path, cur, res);
		}
		if (col < board[0].length - 1) {
			fix += process(board, row, col + 1, path, cur, res);
		}
		board[row][col] = cha;
		path.pollLast();
		cur.pass -= fix;
		return fix;
	}
```



## 题目四 不同子序列的个数

这个是第二节的第四题  力扣\115. 不同的子序列

![image-20221223164922281](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223164922281-167178536348110.png)

这个就是一个样本做行，一个做列。$DP[i][j]$表示S[0...i]变到T[0...j]的方案数。 

```
public static int numDistinct1(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		return process(s, t, s.length, t.length);
	}

	public static int process(char[] s, char[] t, int i, int j) {
		if (j == 0) {
			return 1;
		}
		if (i == 0) {
			return 0;
		}
		int res = process(s, t, i - 1, j);
		if (s[i - 1] == t[j - 1]) {
			res += process(s, t, i - 1, j - 1);
		}
		return res;
	}

	// S[...i]的所有子序列中，包含多少个字面值等于T[...j]这个字符串的子序列
	// 记为dp[i][j]
	// 可能性1）S[...i]的所有子序列中，都不以s[i]结尾，则dp[i][j]肯定包含dp[i-1][j]
	// 可能性2）S[...i]的所有子序列中，都必须以s[i]结尾，
	// 这要求S[i] == T[j]，则dp[i][j]包含dp[i-1][j-1]
	public static int numDistinct2(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		int[][] dp = new int[s.length + 1][t.length + 1];
		for (int j = 0; j <= t.length; j++) {
			dp[0][j] = 0;
		}
		for (int i = 0; i <= s.length; i++) {
			dp[i][0] = 1;
		}
		for (int i = 1; i <= s.length; i++) {
			for (int j = 1; j <= t.length; j++) {
				dp[i][j] = dp[i - 1][j] + (s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] : 0);
			}
		}
		return dp[s.length][t.length];
	}

	public static int numDistinct3(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		int[] dp = new int[t.length + 1];
		dp[0] = 1;
		for (int j = 1; j <= t.length; j++) {
			dp[j] = 0;
		}
		for (int i = 1; i <= s.length; i++) {
			for (int j = t.length; j >= 1; j--) {
				dp[j] += s[i - 1] == t[j - 1] ? dp[j - 1] : 0;
			}
		}
		return dp[t.length];
	}
```





# 20221223 30 经典面试十四

## 题目五 骑士见公主

第二节 

力扣\174. 地下城游戏



![image-20221223191217114](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223191217114-167179393885811.png)

类似于矩阵的最大路径和问题，每个点依赖他的下面的和右面的点。





```
public static int needMin(int[][] matrix) {
		return process(matrix, matrix.length, matrix[0].length, 0, 0);
	}

	// 来到了matrix[row][col]，还没登上去，到达右下角，返回至少的初始血量
	public static int process(int[][] matrix, int N, int M, int row, int col) {
		if(row == N - 1 && col == M - 1) { // 已经达到右下角了
			return matrix[N-1][M-1] < 0 ? (-matrix[N-1][M-1] + 1) : 1;
		}
		if(row == N - 1) {
			int rightNeed = process(matrix, N, M, row, col+1);
			if(matrix[row][col] < 0) { // 3    -7    10
				return -matrix[row][col] + rightNeed;
			}else if(matrix[row][col] >= rightNeed) {  // 3    3    1
				return 1;
			}else { //  3   1    2
				return rightNeed - matrix[row][col];
			}
		}
		if(col == M - 1) {
			int downNeed = process(matrix, N, M, row+1, col);
			if(matrix[row][col] < 0) { // 3    -7    10
				return -matrix[row][col] + downNeed;
			}else if(matrix[row][col] >= downNeed) {  // 3    3    1
				return 1;
			}else { //  3   1    2
				return downNeed - matrix[row][col];
			}
		}
		int minNextNeed = Math.min(process(matrix, N, M, row, col+1), process(matrix, N, M, row+1, col));
		if(matrix[row][col] < 0) { // 3    -7    10
			return -matrix[row][col] + minNextNeed;
		}else if(matrix[row][col] >= minNextNeed) {  // 3    3    1
			return 1;
		}else { //  3   1    2
			return minNextNeed - matrix[row][col];
		}
	}

	public static int minHP1(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 1;
		}
		int row = m.length;
		int col = m[0].length;
		int[][] dp = new int[row--][col--];
		dp[row][col] = m[row][col] > 0 ? 1 : -m[row][col] + 1;
		for (int j = col - 1; j >= 0; j--) {
			dp[row][j] = Math.max(dp[row][j + 1] - m[row][j], 1);
		}
		int right = 0;
		int down = 0;
		for (int i = row - 1; i >= 0; i--) {
			dp[i][col] = Math.max(dp[i + 1][col] - m[i][col], 1);
			for (int j = col - 1; j >= 0; j--) {
				right = Math.max(dp[i][j + 1] - m[i][j], 1);
				down = Math.max(dp[i + 1][j] - m[i][j], 1);
				dp[i][j] = Math.min(right, down);
			}
		}
		return dp[0][0];
	}

	public static int minHP2(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 1;
		}
		int more = Math.max(m.length, m[0].length);
		int less = Math.min(m.length, m[0].length);
		boolean rowmore = more == m.length;
		int[] dp = new int[less];
		int tmp = m[m.length - 1][m[0].length - 1];
		dp[less - 1] = tmp > 0 ? 1 : -tmp + 1;
		int row = 0;
		int col = 0;
		for (int j = less - 2; j >= 0; j--) {
			row = rowmore ? more - 1 : j;
			col = rowmore ? j : more - 1;
			dp[j] = Math.max(dp[j + 1] - m[row][col], 1);
		}
		int choosen1 = 0;
		int choosen2 = 0;
		for (int i = more - 2; i >= 0; i--) {
			row = rowmore ? i : less - 1;
			col = rowmore ? less - 1 : i;
			dp[less - 1] = Math.max(dp[less - 1] - m[row][col], 1);
			for (int j = less - 2; j >= 0; j--) {
				row = rowmore ? i : j;
				col = rowmore ? j : i;
				choosen1 = Math.max(dp[j] - m[row][col], 1);
				choosen2 = Math.max(dp[j + 1] - m[row][col], 1);
				dp[j] = Math.min(choosen1, choosen2);
			}
		}
		return dp[0];
	}
```





## 题目六 往返最大路径和

还是第二节的题

![image-20221223193742467](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223193742467.png)

思路：同一个节点，如果走过的话，那么回来的时候就只能获得0.**这个题的做法是，去做两个小人，从左上角到右下角去做，然后这两人不重合，那么就是最大路径和，他俩加一起。**这个做法很骚，因为他利用了只能向右下走的限制。同时，因为俩人的步数肯定是一样多的，他们是同步走的，那么如果我知道A的位置，B的位置知道x,那么y也能推算出来。如果A的位置是Ar,Ac,那么B的位置就是Br,Ar + Ac - Br



```
// 从matrix左上角，走到右下角，过程中只能向右或者向下
	// 到达后，回来，过程中只能向左或者向上，沿途数字只能获得一遍
	// 返回，最大路径和
	public static int comeGoMaxPathSum(int[][] matrix) {
		return process(matrix, 0, 0, 0);
	}

	// matrix中，没有负数
	// A来到的位置是 Ar,Ac
	// B来到的位置是 Br, Ar + Ac - Br
	// A和B，一定迈出的步数，一样多，同步走的
	// 两人会共同到达右下角，返回两个人路径的最大累加和
	// 重要限制：来到同一个位置时，只获得一份
	// 3 7 5 ?
	public static int process(int[][] matrix, int Ar, int Ac, int Br) {
		int N = matrix.length;
		int M = matrix[0].length;
		if (Ar == N - 1 && Ac == M - 1) {
			return matrix[Ar][Ac];
		}
		// 还没到右下角
		// A 下 B 右
		// A 下 B 下
		// A 右 B 右
		// A 右 B 下
		int Bc = Ar + Ac - Br;
		int ADownBRight = -1;
		if (Ar + 1 < N && Bc + 1 < M) {
			ADownBRight = process(matrix, Ar + 1, Ac, Br);
		}
		int ADownBDown = -1;
		if (Ar + 1 < N && Br + 1 < N) {
			ADownBDown = process(matrix, Ar + 1, Ac, Br + 1);
		}

		int ARightBRight = -1;
		if (Ac + 1 < M && Bc + 1 < M) {
			ARightBRight = process(matrix, Ar, Ac + 1, Br);
		}
		int ARightBDown = -1;
		if (Ac + 1 < M && Br + 1 < N) {
			ARightBDown = process(matrix, Ar, Ac + 1, Br + 1);
		}
		int nextBest = Math.max(Math.max(ADownBRight, ADownBDown), Math.max(ARightBRight, ARightBDown));
		// A B
		if (Ar == Br) {
			return matrix[Ar][Ac] + nextBest;
		}
		// A 和 B，一定是不同位置
		return matrix[Ar][Ac] + matrix[Br][Bc] + nextBest;
	}

	public static int cherryPickup1(int[][] grid) {
		int ans = process1(grid, 0, 0, 0);
		return ans < 0 ? 0 : ans;
	}

	public static int process1(int[][] grid, int x1, int y1, int x2) {
		if (x1 == grid.length || y1 == grid[0].length || x2 == grid.length || x1 + y1 - x2 == grid[0].length) {
			return Integer.MIN_VALUE;
		}

		if (x1 == grid.length - 1 && y1 == grid[0].length - 1) {
			return grid[x1][y1];
		}
		int next = Integer.MIN_VALUE;
		next = Math.max(next, process1(grid, x1 + 1, y1, x2 + 1));
		next = Math.max(next, process1(grid, x1 + 1, y1, x2));
		next = Math.max(next, process1(grid, x1, y1 + 1, x2));
		next = Math.max(next, process1(grid, x1, y1 + 1, x2 + 1));
		if (grid[x1][y1] == -1 || grid[x2][x1 + y1 - x2] == -1 || next == -1) {
			return -1;
		}
		if (x1 == x2) {
			return grid[x1][y1] + next;
		}
		return grid[x1][y1] + grid[x2][x1 + y1 - x2] + next;
	}

	public static int cherryPickup2(int[][] grid) {
		int N = grid.length;
		int M = grid[0].length;
		int[][][] dp = new int[N][M][N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				for (int k = 0; k < N; k++) {
					dp[i][j][k] = Integer.MIN_VALUE;
				}
			}
		}
		int ans = process2(grid, 0, 0, 0, dp);
		return ans < 0 ? 0 : ans;
	}

	public static int process2(int[][] grid, int x1, int y1, int x2, int[][][] dp) {
		if (x1 == grid.length || y1 == grid[0].length || x2 == grid.length || x1 + y1 - x2 == grid[0].length) {
			return Integer.MIN_VALUE;
		}
		if (dp[x1][y1][x2] != Integer.MIN_VALUE) {
			return dp[x1][y1][x2];
		}
		if (x1 == grid.length - 1 && y1 == grid[0].length - 1) {
			dp[x1][y1][x2] = grid[x1][y1];
			return dp[x1][y1][x2];
		}
		int next = Integer.MIN_VALUE;
		next = Math.max(next, process2(grid, x1 + 1, y1, x2 + 1, dp));
		next = Math.max(next, process2(grid, x1 + 1, y1, x2, dp));
		next = Math.max(next, process2(grid, x1, y1 + 1, x2, dp));
		next = Math.max(next, process2(grid, x1, y1 + 1, x2 + 1, dp));
		if (grid[x1][y1] == -1 || grid[x2][x1 + y1 - x2] == -1 || next == -1) {
			dp[x1][y1][x2] = -1;
			return dp[x1][y1][x2];
		}
		if (x1 == x2) {
			dp[x1][y1][x2] = grid[x1][y1] + next;
			return dp[x1][y1][x2];
		}
		dp[x1][y1][x2] = grid[x1][y1] + grid[x2][x1 + y1 - x2] + next;
		return dp[x1][y1][x2];
	}
```



## 题目一 相邻数之间的最大差值



![image-20221223195212402](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223195212402-167179633356914.png)



这是第三节的，这个题很多ACM的都不会，但是会了的话就还行了。。不过这个题还是很难的。

​	解题思路，首先知道数组的min,max,然后再根据min,max分为N+1等分，然后每个等分都做一个桶，只保留这个一个范围内的最大值和最小值，然后相邻桶之间的最小值减最大值里面最大的，就是最大差值了，注意桶里肯定会至少有一个空桶，那么跨空桶的更容易产生这个最大差值，因为他差的范围更广嘛,**做空桶的目的是找不算差的平凡解，目的是为了杀死比平凡解还要差的解，不是为了说答案是什么，而是说答案不是什么**。 这个思路跟数组三连问题的第三个题很像，取舍可能性。但他比数组三连那个更难的是，他是固定的。





![image-20221223201653523](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223201653523-167179781555315.png)

```
public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
		// 不止一种数，min~max一定有range,  len个数据，准备len+1个桶
		boolean[] hasNum = new boolean[len + 1]; // hasNum[i] i号桶是否进来过数字
		int[] maxs = new int[len + 1];  // maxs[i] i号桶收集的所有数字的最大值
		int[] mins = new int[len + 1];  // mins[i] i号桶收集的所有数字的最小值
		
		int bid = 0; // 桶号
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max);
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = maxs[0]; // 上一个非空桶的最大值
		int i = 1;
		for (; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}

	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}

	// for test
	public static int comparator(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		Arrays.sort(nums);
		int gap = Integer.MIN_VALUE;
		for (int i = 1; i < nums.length; i++) {
			gap = Math.max(nums[i] - nums[i - 1], gap);
		}
		return gap;
	}
```



## 多少种拼接arr的方式

![image-20221223204027935](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223204027935-167179922926817.png)

这个题，可以用前缀树的方法进行加速，加速后的时间复杂度是

```
/*
	 * 
	 * 假设所有字符都是小写字母. 大字符串是str. arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次.
	 * 使用arr中的单词有多少种拼接str的方式. 返回方法数.
	 * 
	 */

	public static int ways(String str, String[] arr) {
		HashSet<String> set = new HashSet<>();
		for (String candidate : arr) {
			set.add(candidate);
		}
		return process(str, 0, set);
	}

	// 所有的贴纸，都已经放在了set中
	// str[i....] 能够被set中的贴纸分解的话，返回分解的方法数
	public static int process(String str, int i, HashSet<String> set) {
		if (i == str.length()) {
			return 1;
		}
		int ways = 0;
		// [i ... end] 前缀串 每一个前缀串
		for (int end = i; end < str.length(); end++) {
			String pre = str.substring(i, end + 1);// [)
			if (set.contains(pre)) {
				ways += process(str, end + 1, set);
			}
		}
		return ways;
	}

	public static int ways1(String str, String[] arr) {
		if (str == null || str.length() == 0 || arr == null || arr.length == 0) {
			return 0;
		}
		HashSet<String> map = new HashSet<>();
		for (String s : arr) {
			map.add(s);
		}
		return f(str, map, 0);
	}

	public static int f(String str, HashSet<String> map, int index) {
		if (index == str.length()) {
			return 1;
		}
		int ways = 0;
		for (int end = index; end < str.length(); end++) {
			if (map.contains(str.substring(index, end + 1))) {
				ways += f(str, map, end + 1);
			}
		}
		return ways;
	}

	public static int ways2(String str, String[] arr) {
		if (str == null || str.length() == 0 || arr == null || arr.length == 0) {
			return 0;
		}
		HashSet<String> map = new HashSet<>();
		for (String s : arr) {
			map.add(s);
		}
		int N = str.length();
		int[] dp = new int[N + 1];
		dp[N] = 1;
		for (int i = N - 1; i >= 0; i--) {
			for (int end = i; end < N; end++) {
				if (map.contains(str.substring(i, end + 1))) {
					dp[i] += dp[end + 1];
				}
			}
		}
		return dp[0];
	}

	public static class Node {
		public boolean end;
		public Node[] nexts;

		public Node() {
			end = false;
			nexts = new Node[26];
		}
	}

	public static int ways3(String str, String[] arr) {
		if (str == null || str.length() == 0 || arr == null || arr.length == 0) {
			return 0;
		}
		Node root = new Node();
		for (String s : arr) {
			char[] chs = s.toCharArray();
			Node node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					node.nexts[index] = new Node();
				}
				node = node.nexts[index];
			}
			node.end = true;
		}
		return g(str.toCharArray(), root, 0);
	}

	// str[i...] 被分解的方法数，返回

	public static int g(char[] str, Node root, int i) {
		if (i == str.length) {
			return 1;
		}
		int ways = 0;
		Node cur = root;
		// i...end
		for (int end = i; end < str.length; end++) {
			int path = str[end] - 'a';
			if (cur.nexts[path] == null) {
				break;
			}
			cur = cur.nexts[path];
			if (cur.end) { // i...end
				ways += g(str, root, end + 1);
			}
		}
		return ways;
	}

	public static int ways4(String s, String[] arr) {
		if (s == null || s.length() == 0 || arr == null || arr.length == 0) {
			return 0;
		}
		Node root = new Node();
		for (String str : arr) {
			char[] chs = str.toCharArray();
			Node node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a';
				if (node.nexts[index] == null) {
					node.nexts[index] = new Node();
				}
				node = node.nexts[index];
			}
			node.end = true;
		}
		char[] str = s.toCharArray();
		int N = str.length;
		int[] dp = new int[N + 1];
		dp[N] = 1;
		for (int i = N - 1; i >= 0; i--) {
			Node cur = root;
			for (int end = i; end < N; end++) {
				int path = str[end] - 'a';
				if (cur.nexts[path] == null) {
					break;
				}
				cur = cur.nexts[path];
				if (cur.end) {
					dp[i] += dp[end + 1];
				}
			}
		}
		return dp[0];
	}
```



# 20221224 31 经典面试十五

## 题目三 最长路径最多节点

![image-20221224095303689](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224095303689-16718467848591.png)

这个也是用到了数组三连问题的算法原型，不过这里用的更骚一点。sumMap只记录第一个出现的前缀和。

```
public static class Node {
		int value;
		public Node left;
		public Node right;

		public Node(int v) {
			value = v;
		}
	}

	public static int ans = 0; // 收集累加和为K的，最长路径有多少个节点

	public static int longest(Node head, int K) {
		ans = 0;
		// key ： 前缀和
		// value : 该前缀和，最早出现在哪一层
		// sumMap：只维持，从头节点出发到当前节点，这条路径上的前缀和
		HashMap<Integer, Integer> sumMap = new HashMap<>();
		sumMap.put(0, -1);
		process(head, 0, 0, K, sumMap);
		return ans;
	}

	// 节点X在level层，从头节点到X的父节点形成的累加和是preSum，
	// 从头节点到X的路径上，每一个前缀和都存在sumMap里(key)，记录的是该前缀和最早出现的层数(value)
	// 求出必须以X节点结尾的、累加和是K的所有路径中，含有最多的节点是多少？
	// 并看看能不能更新全局的ans
	public static void process(Node X, int level, int preSum, int K, HashMap<Integer, Integer> sumMap) {
		if (X != null) {
			// 从头节点出发，到当前X节点，总的前缀和是多少，allSum
			int allSum = preSum + X.value;
			if (sumMap.containsKey(allSum - K)) {
				ans = Math.max(ans, level - sumMap.get(allSum - K));
			}
			if (!sumMap.containsKey(allSum)) {
				sumMap.put(allSum, level);
			}
			process(X.left, level + 1, allSum, K, sumMap);
			process(X.right, level + 1, allSum, K, sumMap);
			if (sumMap.get(allSum) == level) {
				sumMap.remove(allSum);
			}
		}
	}
```



## 题目四 出现1次的数（其他都出现了K次）

![image-20221224101639302](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224101639302-16718482003752.png)

这个题是K进制的异或。其他数出现K次，那么就用K进制去做。



```
public static int onceNum(int[] arr, int k) {
		int[] eO = new int[32];
		for (int i = 0; i != arr.length; i++) {
			// 当前数是arr[i], 请把arr[i]变成K进制的形式，每一位累加到eO
			setExclusiveOr(eO, arr[i], k);
		}
		int res = getNumFromKSysNum(eO, k);
		return res;
	}

	public static void setExclusiveOr(int[] eO, int value, int k) {
		int[] curKSysNum = getKSysNumFromNum(value, k);
		for (int i = 0; i != eO.length; i++) {
			eO[i] = (eO[i] + curKSysNum[i]) % k;%这里每一次都加模是为了怕溢出
		}
	}

	public static int[] getKSysNumFromNum(int value, int k) {
		int[] res = new int[32];
		int index = 0;
		while (value != 0) {
			res[index++] = value % k;
			value = value / k;
		}
		return res;
	}

	public static int getNumFromKSysNum(int[] eO, int k) {
		int res = 0;
		for (int i = eO.length - 1; i != -1; i--) {
			res = res * k + eO[i];
		}
		return res;
	}
```



## 题目五 水王问题

![image-20221224103539842](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224103539842-16718493407123.png)

这是一个很著名很经典的问题，这里都要求额外空间O（1），对于问题1，就是设计一个流程，让每次删掉两个不同的数，那么最后余的数，**就可能是超过数组长度一半的数**，还需要再遍历一遍数组看看

这个问题叫水王问题，是因为这个数很能灌水，帖子里面，有一半都是这个数哈哈。

```
public static void printHalfMajor(int[] arr) {
		int cand = 0;
		int HP = 0;
		for (int i = 0; i < arr.length; i++) {
			if (HP == 0) {
				cand = arr[i];
				HP = 1;
			} else if (arr[i] == cand) {
				HP++;
			} else {
				HP--;
			}
		}
		if(HP == 0) {
			System.out.println("no such number.");
			return;
		}
		HP = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == cand) {
				HP++;
			}
		}
		if (HP > arr.length / 2) {
			System.out.println(cand);
		} else {
			System.out.println("no such number.");
		}
	}
```

对于上面的这个的第二题，就比较贼了。超过数量N/K,最多有K-1个候选。这个题的做题方法就是，做一个记录HP的map。要想明白一点，就是，**没有说候选里面的就是要打印的，而是候选里面的东西是可能的**这个时间复杂度是O(NK)的。



## 咖啡问题（业务限制问题）补充

对于一群咖啡机，比如$arr[3,2,1,7,2]$,arr[i]表示i号咖啡机处理咖啡需要的时间。咖啡机只能是串行的，也就是，比如咖啡机0号，他3分钟内只能做1个咖啡，不能做两个1半的。假如有M个人，这里是100个，举个例子，请返回一个和arr大小一样的数组，为了让M个人都得到咖啡的时间最少，这个返回的数组的i号位置表示i号咖啡要工作多久。

![image-20221224111932071](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224111932071-16718519734634.png)

这个题用小根堆做。这个在class4的6,这个最上面的方法用堆是效果最好的，N*logM

```
// 题目
// 数组arr代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。
// 现在有n个人需要喝咖啡，只能用咖啡机来制造咖啡。
// 认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。
// 每个人喝完之后咖啡杯可以选择洗或者自然挥发干净，只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。
// 洗杯子的机器洗完一个杯子时间为a，任何一个杯子自然挥发干净的时间为b。
// 四个参数：arr, n, a, b
// 假设时间点从0开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。
public class Code06_Coffee {
	
	
	public static class CoffeeMachine{
		public int start;
		public int work;
		
		public CoffeeMachine(int s, int w) {
			start = s;
			work = w;
		}
	}
	
	public static class CoffeeMachineComparator implements Comparator<CoffeeMachine>{

		@Override
		public int compare(CoffeeMachine o1, CoffeeMachine o2) {
			return o1.start + o1.work - o2.start - o2.work;
		}
		
	}
	
	
	
	
	public static int[] bestChoices(int[] arr, int M) {
		int[] ans = new int[M];
		PriorityQueue<CoffeeMachine> heap = new PriorityQueue<>(new CoffeeMachineComparator());
		for(int coffeWork : arr) {
			heap.add(new CoffeeMachine(0, coffeWork));
		}
		for(int i = 0; i< M; i++) {
			CoffeeMachine cur = heap.poll();
			ans[i] = cur.start + cur.work;
			cur.start = ans[i];
			heap.add(cur);
		}
		return ans;
	}
	
	
	
	
	
	
	

	// 方法一：暴力尝试方法
	public static int minTime1(int[] arr, int n, int a, int b) {
		int[] times = new int[arr.length];
		int[] drink = new int[n];
		return forceMake(arr, times, 0, drink, n, a, b);
	}

	// 方法一，每个人暴力尝试用每一个咖啡机给自己做咖啡
	public static int forceMake(int[] arr, int[] times, int kth, int[] drink, int n, int a, int b) {
		if (kth == n) {
			int[] drinkSorted = Arrays.copyOf(drink, kth);
			Arrays.sort(drinkSorted);
			return forceWash(drinkSorted, a, b, 0, 0, 0);
		}
		int time = Integer.MAX_VALUE;
		for (int i = 0; i < arr.length; i++) {
			int work = arr[i];
			int pre = times[i];
			drink[kth] = pre + work;
			times[i] = pre + work;
			time = Math.min(time, forceMake(arr, times, kth + 1, drink, n, a, b));
			drink[kth] = 0;
			times[i] = pre;
		}
		return time;
	}

	// 方法一，暴力尝试洗咖啡杯的方式
	public static int forceWash(int[] drinks, int a, int b, int index, int washLine, int time) {
		if (index == drinks.length) {
			return time;
		}
		// 选择一：当前index号咖啡杯，选择用洗咖啡机刷干净
		int wash = Math.max(drinks[index], washLine) + a;
		int ans1 = forceWash(drinks, a, b, index + 1, wash, Math.max(wash, time));

		// 选择二：当前index号咖啡杯，选择自然挥发
		int dry = drinks[index] + b;
		int ans2 = forceWash(drinks, a, b, index + 1, washLine, Math.max(dry, time));
		return Math.min(ans1, ans2);
	}

	// 方法二：稍微好一点的解法
	public static class Machine {
		public int timePoint;
		public int workTime;

		public Machine(int t, int w) {
			timePoint = t;
			workTime = w;
		}
	}

	public static class MachineComparator implements Comparator<Machine> {

		@Override
		public int compare(Machine o1, Machine o2) {
			return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
		}

	}

	// 方法二，每个人暴力尝试用每一个咖啡机给自己做咖啡，优化成贪心
	public static int minTime2(int[] arr, int n, int a, int b) {
		PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
		for (int i = 0; i < arr.length; i++) {
			heap.add(new Machine(0, arr[i]));
		}
		int[] drinks = new int[n];
		for (int i = 0; i < n; i++) {
			Machine cur = heap.poll();
			cur.timePoint += cur.workTime;
			drinks[i] = cur.timePoint;
			heap.add(cur);
		}
		// 洗杯子的阶段
		return process(drinks, a, b, 0, 0);
	}

	// 方法二，洗咖啡杯的方式和原来一样，只是这个暴力版本减少了一个可变参数
	// drinks、a、b代表洗的模型
	// drinks[index....],洗杯子的机器什么时候可以接受新的杯子叫washLine，
	// 来到的最早时间点。
	public static int process(int[] drinks, int a, int b, int index, int washLine) {
		if (index == drinks.length - 1) { // base case : 只剩一个杯子的时候
			// 洗 or 挥发
			return Math.min(Math.max(washLine, drinks[index]) + a, drinks[index] + b);
		}
		// index...  不止一个杯子
		// wash是我当前的咖啡杯，洗完的时间
		// 想洗
		int wash = Math.max(washLine, drinks[index]) + a; // 洗完我这一杯，时间来到哪？wash
		int next1 = process(drinks, a, b, index + 1, wash);
		int p1 = Math.max(wash, next1);
		// 想挥发
		int dry = drinks[index] + b; // 挥发完我这一杯，时间来到哪？dry
		int next2 = process(drinks, a, b, index + 1, washLine);
		int p2 = Math.max(dry, next2);
		return Math.min(p1, p2);
	}

	// 方法三：最终版本，把方法二洗咖啡杯的暴力尝试进一步优化成动态规划
	public static int minTime3(int[] arr, int n, int a, int b) {
		PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
		for (int i = 0; i < arr.length; i++) {
			heap.add(new Machine(0, arr[i]));
		}
		int[] drinks = new int[n];
		for (int i = 0; i < n; i++) {
			Machine cur = heap.poll();
			cur.timePoint += cur.workTime;
			drinks[i] = cur.timePoint;
			heap.add(cur);
		}
		if (a >= b) {
			return drinks[n - 1] + b;
		}
		int[][] dp = new int[n][drinks[n - 1] + n * a];
		for (int i = 0; i < dp[0].length; i++) {
			dp[n - 1][i] = Math.min(Math.max(i, drinks[n - 1]) + a, drinks[n - 1] + b);
		}
		for (int row = n - 2; row >= 0; row--) { // row 咖啡杯的编号
			int washLine = drinks[row] + (row + 1) * a;
			for (int col = 0; col < washLine; col++) {
				int wash = Math.max(col, drinks[row]) + a;
				dp[row][col] = Math.min(Math.max(wash, dp[row + 1][wash]), Math.max(drinks[row] + b, dp[row + 1][col]));
			}
		}
		return dp[0][0];
	}
```



# 20221224 32 经典面试 十六

## 题目二AB数组中最大的K个数字

第四节。![image-20221224124923776](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224124923776-16718573647706.png)

这个问题的最优解复杂度是O(log2{min{N,M}}).首先在A里面二分，然后再在B里定位，看能不能找到，如果能找到的话，那就试试B里二分，在A里定位，看看能不能找到，对于这个介绍的方法，复杂度是NlogM。

   如果A，B是等长有序的，（[1,2,3,4],[1',2',3',4']),如果A,B长度是偶数，那么讨论如果上中值（就是，1，2,3,4，的位置，2的这个位置），如果相等，那么上中位数的值相等，他们直接把值返回就行，因为这个值就是把AB合并后的中间位置的。如果A的上中位数比B的上中位数大，就是说A[2] > B[2']那么把A的[1,2]，和B的[1',2']，不管谁成为了这几个数中的第二小，都是原来整体里面的第4小。如果的上中位数比B的上中位数小，也是类似的。这个结论是总成立的，如果偶数长度换了那就是另外的。

  如果AB的长度为奇数，那么会和偶数的情况有一点点不一样，为了让这和偶数一样，方便接下来的递归，需要人工的去排除一下,不过下面的这个代码没有这么做。**注意下面的代码只是找到了两个排序数组中第K大的数**

```
	public static int getUpMedian(int[] A, int s1, int e1, int[] B, int s2, int e2) {
		int mid1 = 0;
		int mid2 = 0;
		while (s1 < e1) {
			mid1 = (s1 + e1) / 2;
			mid2 = (s2 + e2) / 2;
			if (A[mid1] == B[mid2]) {
				return A[mid1];
			}
			if (((e1 - s1 + 1) & 1) == 1) { // 奇数长度
				if (A[mid1] > B[mid2]) {
					if (B[mid2] >= A[mid1 - 1]) {
						return B[mid2];
					}
					e1 = mid1 - 1;
					s2 = mid2 + 1;
				} else { // A[mid1] < B[mid2]
					if (A[mid1] >= B[mid2 - 1]) {
						return A[mid1];
					}
					e2 = mid2 - 1;
					s1 = mid1 + 1;
				}
			} else { // 偶数长度
				if (A[mid1] > B[mid2]) {
					e1 = mid1;
					s2 = mid2 + 1;
				} else {
					e2 = mid2;
					s1 = mid1 + 1;
				}
			}
		}
		return Math.min(A[s1], B[s2]);
	}
```

假如A长10，B长17，如果找的K在1到10的范围内，那么就拿A和B的前K个，答案肯定在其中。如果K在(10,17]的范围，那么A都有可能， 而B的长度不一定，这个时候需要人工扣几个了，直到两个数组长度一样，再用上面的算法原型。如果K在(17,27]的范围，目的也是去凑AB长度一样。这个是老左的原创。

```
	public static int findKthNum(int[] arr1, int[] arr2, int kth) {
		if (arr1 == null || arr2 == null) {
			return -1;
		}
		if (kth < 1 || kth > arr1.length + arr2.length) {
			return -1;
		}
		int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
		int[] shorts = arr1.length < arr2.length ? arr1 : arr2;
		int l = longs.length;
		int s = shorts.length;
		if (kth <= s) {
			return getUpMedian(shorts, 0, kth - 1, longs, 0, kth - 1);
		}
		if (kth > l) {
			if (shorts[kth - l - 1] >= longs[l - 1]) {
				return shorts[kth - l - 1];
			}
			if (longs[kth - s - 1] >= shorts[s - 1]) {
				return longs[kth - s - 1];
			}
			return getUpMedian(shorts, kth - l, s - 1, longs, kth - s, l - 1);
		}
		// 短数组长度 < k <= 长数组长度
		if (longs[kth - s - 1] >= shorts[s - 1]) {
			return longs[kth - s - 1];
		}
		return getUpMedian(shorts, 0, s - 1, longs, kth - s, kth - 1);
	}

	// A[s1...e1]
	// B[s2...e2]
	// 这两段一定等长且都有序
	// 求这两段整体的上中位数，上中位数值返回
	public static int getUpMedian(int[] A, int s1, int e1, int[] B, int s2, int e2) {
		int mid1 = 0;
		int mid2 = 0;
		while (s1 < e1) {
			mid1 = (s1 + e1) / 2;
			mid2 = (s2 + e2) / 2;
			if (A[mid1] == B[mid2]) {
				return A[mid1];
			}
			if (((e1 - s1 + 1) & 1) == 1) { // 奇数长度
				if (A[mid1] > B[mid2]) {
					if (B[mid2] >= A[mid1 - 1]) {
						return B[mid2];
					}
					e1 = mid1 - 1;
					s2 = mid2 + 1;
				} else { // A[mid1] < B[mid2]
					if (A[mid1] >= B[mid2 - 1]) {
						return A[mid1];
					}
					e2 = mid2 - 1;
					s1 = mid1 + 1;
				}
			} else { // 偶数长度
				if (A[mid1] > B[mid2]) {
					e1 = mid1;
					s2 = mid2 + 1;
				} else {
					e2 = mid2;
					s1 = mid1 + 1;
				}
			}
		}
		return Math.min(A[s1], B[s2]);
	}
```

## 题目四 约瑟夫环问题

刚才那个题是比较妙，这个题的话就是纯难。要求是用O（N）的时间复杂度去做。这个题一般都考，安卓岗。正常的话是O（NK）的难度，如果K变大，对问题有很大的影响。做一个函数，实现的功能是，知道杀之后的编号，那么可以通过f(a)来得到杀之前的编号。

   y = x % i是一个函数，就是数到I的时候就从头数。也差不多：号=（数- 1） % i + 1，



​	旧=（新+s-1) % i + 1.i为杀之前的长度，S是杀的编号，其实S=(m -1) %i + 1,那么给代入进去，最终能优化为：旧 = (新+m - 1) % i + 1，因为m - 1 = k * i + r;

   有一个拓展，有N个人，然后每[3,1,5,2,7]类似的去杀人，比如说N=7，第一次是每3个人杀，等3号死后，然后去每1个人杀人，4死后去每5个人杀人这样。。。如果[3,1,5,2,7]都走完，不行的话，那就从3开始循环。这其实也是约瑟夫环问题，只不过是m一直在改变罢了。



```
	public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node josephusKill1(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node last = head;
		while (last.next != head) {
			last = last.next;
		}
		int count = 0;
		while (head != last) {
			if (++count == m) {
				last.next = head.next;
				count = 0;
			} else {
				last = last.next;
			}
			head = last.next;
		}
		return head;
	}

	public static Node josephusKill2(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node cur = head.next;
		int size = 1; // tmp -> list size
		while (cur != head) {
			size++;
			cur = cur.next;
		}
		int live = getLive(size, m); // tmp -> service node position
		while (--live != 0) {
			head = head.next;
		}
		head.next = head;
		return head;
	}

	// 现在一共有i个节点，数到m就杀死节点，最终会活下来的节点，请返回它在有i个节点时候的编号
	// 旧 
	// getLive(N, m)
	public static int getLive(int i, int m) {
		if (i == 1) {
			return 1;
		}
		// getLive(i - 1, m)   长度为i-1时候，活下来的编号
		return (getLive(i - 1, m) + m - 1) % i + 1;
	}
```



## 20221224 33 经典面试 十七

![image-20221224164913972](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224164913972-16718717551017.png)

力扣218



这是一个区间极值的问题，比较难的部分是怎么在脑海中去建模这个事情。

```
// 描述高度变化的对象
	public static class Op {
		public int x; // x轴上的值
		public boolean isAdd;// true为加入，false为删除
		public int h; // 高度

		public Op(int x, boolean isAdd, int h) {
			this.x = x;
			this.isAdd = isAdd;
			this.h = h;
		}
	}

	// 排序的比较策略
	// 1，第一个维度的x值从小到大。
	// 2，如果第一个维度的值相等，看第二个维度的值，“加入”排在前，“删除”排在后
	// 3，如果两个对象第一维度和第二个维度的值都相等，则认为两个对象相等，谁在前都行。
	public static class OpComparator implements Comparator<Op> {
		@Override
		public int compare(Op o1, Op o2) {
			if (o1.x != o2.x) {
				return o1.x - o2.x;
			}
			if (o1.isAdd != o2.isAdd) {
				return o1.isAdd ? -1 : 1;
			}
			return 0;
		}
	}

	// 全部流程的主方法
	// [s,e,h]
	// [s,e,h]
	// { {1,5,3} , {6,8,4}  .. ...  ...    }
	public static List<List<Integer>> buildingOutline(int[][] matrix) {
		int N = matrix.length;
		Op[] ops = new Op[N << 1];
		for (int i = 0; i < matrix.length; i++) {
			ops[i * 2] = new Op(matrix[i][0], true, matrix[i][2]);
			ops[i * 2 + 1] = new Op(matrix[i][1], false, matrix[i][2]);
		}
		// 把描述高度变化的对象数组，按照规定的排序策略排序
		Arrays.sort(ops, new OpComparator());
		
		
		// TreeMap就是java中的红黑树结构，直接当作有序表来使用
		// key  某个高度  value  次数
		TreeMap<Integer, Integer> mapHeightTimes = new TreeMap<>();
		// key   x点，   value 最大高度
		TreeMap<Integer, Integer> mapXHeight = new TreeMap<>();
		

		for (int i = 0; i < ops.length; i++) {
			// ops[i]
			if (ops[i].isAdd) { // 如果当前是加入操作
				if (!mapHeightTimes.containsKey(ops[i].h)) { // 没有出现的高度直接新加记录
					mapHeightTimes.put(ops[i].h, 1);
				} else { // 之前出现的高度，次数加1即可
					mapHeightTimes.put(ops[i].h, mapHeightTimes.get(ops[i].h) + 1);
				}
			} else { // 如果当前是删除操作
				if (mapHeightTimes.get(ops[i].h) == 1) { // 如果当前的高度出现次数为1，直接删除记录
					mapHeightTimes.remove(ops[i].h);
				} else { // 如果当前的高度出现次数大于1，次数减1即可
					mapHeightTimes.put(ops[i].h, mapHeightTimes.get(ops[i].h) - 1);
				}
			}
			// 根据mapHeightTimes中的最大高度，设置mapXvalueHeight表
			if (mapHeightTimes.isEmpty()) { // 如果mapHeightTimes为空，说明最大高度为0
				mapXHeight.put(ops[i].x, 0);
			} else { // 如果mapHeightTimes不为空，通过mapHeightTimes.lastKey()取得最大高度
				mapXHeight.put(ops[i].x, mapHeightTimes.lastKey());
			}
		}
		// res为结果数组，每一个List<Integer>代表一个轮廓线，有开始位置，结束位置，高度，一共三个信息
		List<List<Integer>> res = new ArrayList<>();
		// 一个新轮廓线的开始位置
		int start = 0;
		// 之前的最大高度
		int preHeight = 0;
		// 根据mapXvalueHeight生成res数组
		for (Entry<Integer, Integer> entry : mapXHeight.entrySet()) {
			// 当前位置
			int curX = entry.getKey();
			// 当前最大高度
			int curMaxHeight = entry.getValue();
			if (preHeight != curMaxHeight) { // 之前最大高度和当前最大高度不一样时
				if (preHeight != 0) {
					res.add(new ArrayList<>(Arrays.asList(start, curX, preHeight)));
				}
				start = curX;
				preHeight = curMaxHeight;
			}
		}
		return res;
	}
```

## 题目三 Nim博弈问题



![image-20221224173231679](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224173231679-16718743530958.png)

 流程：把数都异或起来，如果得到0的话，先手输，不是0的话先手赢，6.

​	先手应该想办法取铜板，取完后，自己不先面对全是0，就是输，而对手却遇到全是0. 

自己想了个段子：我以为的ab极度聪明：ab取铜板的时候疯狂的算。。真实的ab极度聪明：a:无所谓，我会那点硬币让剩余的硬币肯定异或为0；b:无所谓，我会拿点硬币让剩余的硬币肯定异或不为0



```
	// 保证arr是正数数组
	public static void printWinner(int[] arr) {
		int eor = 0;
		for (int num : arr) {
			eor ^= num;
		}
		if (eor == 0) {
			System.out.println("后手赢");
		} else {
			System.out.println("先手赢");
		}
	}
```



## 题目五 N人过河最少船

![image-20221224175148615](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224175148615-16718755095959.png)

 这其实是个贪心的题，排序双指针。 这个题很有意思，首先先排序，然后找limit/2,的位置，他左边是L指针起始，右边是R指针起始。



```
// 请保证arr有序
	public static int minBoat(int[] arr, int limit) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int N = arr.length;
		// Arrays.sort(arr);
		if(arr[N - 1] > limit) {
			return -1;
		}
		int lessR = -1;
		// 所有的人体重都不超过limit，继续讨论,  <= limit / 2  最右的位置
		for (int i = N  - 1; i >= 0; i--) {
			if (arr[i] <= (limit / 2)) {
				lessR = i;
				break;
			}
		}
		if (lessR == -1) {
			return N;
		}
		//  <= limit / 2
		int L = lessR;
		int R = lessR + 1;
		int noUsed = 0; // 画X的数量统计，画对号的量(加工出来的)
		while (L >= 0) {
			int solved = 0; // 此时的[L]，让R画过了几个数
			while (R < N && arr[L] + arr[R] <= limit) {
				R++;
				solved++;
			}
			// R来到又不达标的位置
			if (solved == 0) {
				noUsed++;
				L--;
			} else { // 此时的[L]，让R画过了solved（>0）个数
				L = Math.max(-1, L - solved);
			}
		}
		int all = lessR + 1;// 左半区总个数  <= limit /2 的区域
		int used = all - noUsed; // 画对号的量
		int moreUnsolved = (N - all) - used; // > limit/2 区中，没搞定的数量
		return used + ((noUsed + 1) >> 1) + moreUnsolved;
	}
```



# 20221224 34 经典面试 十八

来！！！！最好1小时内看完！不当误我看电影！！！！！



## 题目一 最长回文子序列长度

![image-20221224193726609](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224193726609-167188184774010.png)



方法一，行列模型。这个题可以看做字符串与自己的逆序串之间的最长公共子序列。

方法二，范围上的尝试模型，[L...R],有四种可能：1）最长回文子序列不包含L和R；2）包含L位置，不包含R位置；3）包含R位置，不包含L位置；4）既包含L位置，又包含R位置。

这两种方法，方法二比较好。



```
	public static int maxLen1(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		char[] str1 = str.toCharArray();
		char[] str2 = reverse(str1);
		return lcse(str1, str2);
	}

	public static char[] reverse(char[] str) {
		char[] reverse = new char[str.length];
		for (int i = 0; i < reverse.length; i++) {
			reverse[i] = str[str.length - 1 - i];
		}
		return reverse;
	}

	public static int lcse(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		dp[0][0] = str1[0] == str2[0] ? 1 : 0;
		for (int i = 1; i < str1.length; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
		}
		for (int j = 1; j < str2.length; j++) {
			dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				if (str1[i] == str2[j]) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
				}
			}
		}
		return dp[str1.length - 1][str2.length - 1];
	}

	public static int maxLen2(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int[][] dp = new int[str.length][str.length];
		for (int i = 0; i < str.length; i++) {
			dp[i][i] = 1;
		}
		for (int i = 0; i < str.length - 1; i++) {
			dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
		}
		for (int i = str.length - 2; i >= 0; i--) {
			for (int j = i + 2; j < str.length; j++) {
				dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
				if (str[i] == str[j]) {
					dp[i][j] = Math.max(dp[i + 1][j - 1] + 2, dp[i][j]);
				}
			}
		}
		return dp[0][str.length - 1];
	}
```



## 题目二 蛇的最长长度

![image-20221224194528768](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224194528768-167188232979811.png)

这个题是标准的业务限制问题。暴力尝试其实就是把业务抽象为递归表达。这个题的难度就在于这个抽象的过程，在做递归的时候，如果开始设置的参数不够，那就去补参数。



```
	public static int walk1(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
		int res = Integer.MIN_VALUE;
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[0].length; j++) {
				int[] ans = process(matrix, i, j);
				res = Math.max(res, Math.max(ans[0], ans[1]));
			}
		}
		return res;
	}

	// 从假想的最优左侧到达(i,j)的旅程中
	// 0) 在没有使用过能力的情况下，返回路径最大和，没有可能到达的话，返回负
	// 1) 在使用过能力的情况下，返回路径最大和，没有可能到达的话，返回负
	public static int[] process(int[][] m, int i, int j) {
		if (j == 0) { // (i,j)就是最左侧的位置
			return new int[] { m[i][j], -m[i][j] };
		}
		int[] preAns = process(m, i, j - 1);
		// 所有的路中，完全不使用能力的情况下，能够到达的最好长度是多大
		int preUnuse = preAns[0];
		// 所有的路中，使用过一次能力的情况下，能够到达的最好长度是多大
		int preUse = preAns[1];
		if (i - 1 >= 0) {
			preAns = process(m, i - 1, j - 1);
			preUnuse = Math.max(preUnuse, preAns[0]);
			preUse = Math.max(preUse, preAns[1]);
		}
		if (i + 1 < m.length) {
			preAns = process(m, i + 1, j - 1);
			preUnuse = Math.max(preUnuse, preAns[0]);
			preUse = Math.max(preUse, preAns[1]);
		}
		// preUnuse 之前旅程，没用过能力
		// preUse 之前旅程，已经使用过能力了
		int no = -1; // 之前没使用过能力，当前位置也不使用能力，的最优解
		int yes = -1; // 不管是之前使用能力，还是当前使用了能力，请保证能力只使用一次，最优解
		if (preUnuse >= 0) {
			no = m[i][j] + preUnuse;
			yes = -m[i][j] + preUnuse;
		}
		if (preUse >= 0) {
			yes = Math.max(yes, m[i][j] + preUse);
		}
		return new int[] { no, yes };
	}

	public static int walk2(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int[][][] dp = new int[matrix.length][matrix[0].length][2];
		for (int i = 0; i < dp.length; i++) {
			dp[i][0][0] = matrix[i][0];
			dp[i][0][1] = -matrix[i][0];
			max = Math.max(max, Math.max(dp[i][0][0], dp[i][0][1]));
		}
		for (int j = 1; j < matrix[0].length; j++) {
			for (int i = 0; i < matrix.length; i++) {
				int preUnuse = dp[i][j - 1][0];
				int preUse = dp[i][j - 1][1];
				if (i - 1 >= 0) {
					preUnuse = Math.max(preUnuse, dp[i - 1][j - 1][0]);
					preUse = Math.max(preUse, dp[i - 1][j - 1][1]);
				}
				if (i + 1 < matrix.length) {
					preUnuse = Math.max(preUnuse, dp[i + 1][j - 1][0]);
					preUse = Math.max(preUse, dp[i + 1][j - 1][1]);
				}
				dp[i][j][0] = -1;
				dp[i][j][1] = -1;
				if (preUnuse >= 0) {
					dp[i][j][0] = matrix[i][j] + preUnuse;
					dp[i][j][1] = -matrix[i][j] + preUnuse;
				}
				if (preUse >= 0) {
					dp[i][j][1] = Math.max(dp[i][j][1], matrix[i][j] + preUse);
				}
				max = Math.max(max, Math.max(dp[i][j][0], dp[i][j][1]));
			}
		}
		return max;
	}
```



## 题目三 字符串公式计算结果

![image-20221224200141118](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224200141118-167188330253112.png)

这个题和其他小括号优先级的是一样的递归模型。用栈其实也行，但是代码多。说明给的条件就是帮助我们不用仔细扣边界问题。

做这个题，首先想没有括号的情况，那么用栈就可以搞定。然后对于有括号的情况，其实就是递归了。

```
	public static int getValue(String str) {
		return value(str.toCharArray(), 0)[0];
	}

	// 请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止
	// 返回两个值，长度为2的数组
	// 0) 负责的这一段的结果是多少
	// 1) 负责的这一段计算到了哪个位置
	public static int[] value(char[] str, int i) {
		LinkedList<String> que = new LinkedList<String>();
		int cur = 0;
		int[] bra = null;
		// 从i出发，开始撸串
		while (i < str.length && str[i] != ')') {
			if (str[i] >= '0' && str[i] <= '9') {
				cur = cur * 10 + str[i++] - '0';
			} else if (str[i] != '(') { // 遇到的是运算符号
				addNum(que, cur);
				que.addLast(String.valueOf(str[i++]));
				cur = 0;
			} else { // 遇到左括号了
				bra = value(str, i + 1);
				cur = bra[0];
				i = bra[1] + 1;
			}
		}
		addNum(que, cur);
		return new int[] { getNum(que), i };
	}

	public static void addNum(LinkedList<String> que, int num) {
		if (!que.isEmpty()) {
			int cur = 0;
			String top = que.pollLast();
			if (top.equals("+") || top.equals("-")) {
				que.addLast(top);
			} else {
				cur = Integer.valueOf(que.pollLast());
				num = top.equals("*") ? (cur * num) : (cur / num);
			}
		}
		que.addLast(String.valueOf(num));
	}

	public static int getNum(LinkedList<String> que) {
		int res = 0;
		boolean add = true;
		String cur = null;
		int num = 0;
		while (!que.isEmpty()) {
			cur = que.pollFirst();
			if (cur.equals("+")) {
				add = true;
			} else if (cur.equals("-")) {
				add = false;
			} else {
				num = Integer.valueOf(cur);
				res += add ? num : (-num);
			}
		}
		return res;
	}
```





## 题目四 使字符串变为回文串的方案数

![image-20221224202218227](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221224202218227-167188453912413.png)

头条的题。还是明确一点，怎么删和怎么保留，是一回事。

​	这个题是范围模型，他难在于可能性的梳理，他把范围模型玩到了一种变态的地步。

​	从L。。。。R，的保留方案，让子序列是回文，有1)LR都不保留，2）只保留L位置，3）只保留R位置，4）LR都保留。对于$dp[L+1][R]$,他其实就是1)和3）的和，对于$DP[L][R-1]$，其实就是1）和2）的和。所以，因为我们想要的是1)+2)+3)+4)这个精确位置，但是难就难在他们是混合在一起的，比如如果简单的$DP[L][R]=DP[L+1][R]+DP[L][R-1]$的话，那其实就是1)+1)+2)+3)，这就难搞，需要再减去一个1)的可能，那1）的可能是啥呢？其实就是$DP[L+1][R+1]$。那么1)+2)+3)就是：$DP[L+1][R]+DP[L][R-1] - DP[L+1][R+1]$,然后4)的话，就是只有当[L] == [R]的时候，才需要加，如果需要加的话，那4）的情况其实是1)+1,因为LR相等，其实就等于不需要LR，所以是1),而+1是因为就算L。。R中间是空串，但是LR相等，所以是回文的（因为对于1）来说中间是空的就不行了），所以加一。

# 20220103 35经典面试十九

训练营第四期第6节，这节的题都很经典，一是面试原题，2是力扣原题，3是二叉树递归套路的题，4是经典题

## 题目一 整数裂开的方法数

![image-20230103112922590](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230103112922590-16727165636961.png)

下面的代码ways1就是暴力递归，wasy2就是暴力递归直接修改得到的动态规划，ways3的话就是对动态规划的行为，再进行了一步的优化。这个进一步优化就是斜率优化，这个是见到枚举优化的第三个题了。第一个是基础班组成硬币的方法数，第二个斜率优化是股票问题第三个？

```
	public static int ways1(int n) {
		if (n < 1) {
			return 0;
		}
		return process(1, n);
	}

	public static int process(int pre, int rest) {
		if (rest == 0) {
			return 1;
		}
		if (pre > rest) {
			return 0;
		}
		int ways = 0;
		for (int i = pre; i <= rest; i++) {
			ways += process(i, rest - i);
		}
		return ways;
	}

	public static int ways2(int n) {
		if (n < 1) {
			return 0;
		}
		int[][] dp = new int[n + 1][n + 1];
		for (int pre = 1; pre < dp.length; pre++) {
			dp[pre][0] = 1;
		}
		for (int pre = n; pre > 0; pre--) {
			for (int rest = pre; rest <= n; rest++) {
				for (int i = pre; i <= rest; i++) {
					dp[pre][rest] += dp[i][rest - i];
				}
			}
		}
		return dp[1][n];
	}

	public static int ways3(int n) {
		if (n < 1) {
			return 0;
		}
		int[][] dp = new int[n + 1][n + 1];
		for (int pre = 1; pre < dp.length; pre++) {
			dp[pre][0] = 1;
		}
		for (int pre = 1; pre < dp.length; pre++) {
			dp[pre][pre] = 1;
		}
		for (int pre = n - 1; pre > 0; pre--) {
			for (int rest = pre + 1; rest <= n; rest++) {
				dp[pre][rest] = dp[pre + 1][rest] + dp[pre][rest - pre];
			}
		}
		return dp[1][n];
	}
```

## 题目二 K个逆序对





![image-20230103133350257](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230103133350257-16727240311542.png)

这个题其实就是一个从左往右的尝试模型，他两个参数的原因就是加了限制而已。

逆序对就是，[a,b],然后a>b的。再比如说,[3,1,2],[2,3,1]他们都有2个逆序对，比如说【2,3，1],他其实就是21和31

​	然后这个题不是给了两个参数嘛，可以很自然的想到是一个作行一个作列的模型。

 对于$dp[i][j]$,有几种情况：1）第i的位置插入到最后去，那么他作为最后的话，会带来0个逆序对，因为前面的数肯定不会比他大的，那这样的话其实就是如果1到i-1可以形成j个达标的逆序对，那就是$dp[i-1][j]$.2) 1到i-1有一个排列了，现在决定把i插到倒数第二个位置上，那么这个i的加入，**只会形成一个逆序对**，就是他和第i个位置形成的，那么他再加上$dp[i-1][j-1]$其实就表示1到i-1可以形成j-1个逆序对，正好再加这么一个逆序对，就是达标的逆序对。3)就是插入到倒数第三个位置，这个时候就是加上$dp[i-1][j-2]$。。。。等等，直到j-k为0,**一共有这么k种情况。**

​	这个题很有意思，假如说是$dp[7][7]$,注意这个J=7比较大，这个时候其实他不依赖$dp[6,0]$,就是出现截掉一部分的情况，因为$dp[6][0]$其实是要不了的，7在开始最多会形成6个逆序对，6+0是不够7的，所以不满足，于是他只能取到$dp[6][1]$,**也就是说，当j变大的时候，可能不会依赖完，会有截掉的情况。**

​	上面两段可以这么总结：$dp[i][j]$,如果i>j,那么是一定和$dp[i-1][0....j]$有关。如果i<=j的时候（比如说$dp[7][9]$是可以形成的。）和$dp[i-1][j....j-i+1]$有关。

​	**不管什么模型，尤其关注开头和结尾。行列模型往往关注结尾，范围的模型往往关注开头和结尾都关注。**

代码的第15行：s >= Math.max(0, j - i + 1)  这句话其实就代表了两种可能性。dp1是原始的代码，可以注意到里面出现了枚举的行为，**所以应该可以进行优化的操作。**比如说在第一种情况i>j的时候，$dp[7][3]=dp[6][3..0]$,而$dp[7][4]=dp[6][3..0]+dp[6][4]$,那么就有了$dp[7][4] = dp[7][3]+dp[6][4]$,再比如说第二种情况i<=j的时候，$dp[7][9]=dp[6][9..3]$,$dp[7][10]=dp[6][10....4]$，那么$dp[7][10]=dp[6][10]+dp[6][9...4]-dp[6][3]$



​	这个其实也是斜率优化，也是通过观察看出来的。这个 代码最下面的第二个版本就是一个取模的版本。如果没有枚举行为，那就记忆化搜索就行了。

```
	public static int dp1(int N, int K) {
		if (N < 1 || K < 0) {
			return 0;
		}
		if (K == 0) {
			return 1;
		}
		int[][] dp = new int[N + 1][K + 1];
		dp[1][0] = 1;
		for (int i = 2; i <= N; i++) {
			dp[i][0] = 1;
		}
		for (int i = 2; i <= N; i++) {
			for (int j = 1; j <= K; j++) {
				for (int s = j; s >= Math.max(0, j - i + 1); s--) {
					dp[i][j] += dp[i - 1][s];
				}
			}
		}
		return dp[N][K];
	}

	public static int dp2(int N, int K) {
		if (N < 1 || K < 0) {
			return 0;
		}
		if (K == 0) {
			return 1;
		}
		int[][] dp = new int[N + 1][K + 1];
		// dp[0][...] 不要
		dp[1][0] = 1;// dp[1][1...] 0
		for (int i = 2; i <= N; i++) {
			dp[i][0] = 1;
		}
		for (int i = 2; i <= N; i++) {
			for (int j = 1; j <= K; j++) {
				// dp[i][j] -> dp[i][j-1]
				// j == 1 dp[i][1] dp[i][0]
//				if (i > j) {
//					dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
//				}
//				if (i <= j) {
//					dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i];
//				}
				dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - (i <= j ? dp[i - 1][j - i] : 0);
			}
		}
		return dp[N][K];
	}

	public static int kInversePairs1(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		int[][] dp = new int[n + 1][k + 1];
		dp[0][0] = 1;
		int mod = 1000000007;
		for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
			for (int p = 1; p <= k; p++) {
				for (int r = Math.max(0, p - i + 1); r <= p; r++) {
					dp[i][p] += dp[i - 1][r];
					dp[i][p] %= mod;
				}
			}
		}
		return dp[n][k];
	}

	public static int kInversePairs2(int n, int k) {
		if (n < 1 || k < 0) {
			return 0;
		}
		int[][] dp = new int[n + 1][k + 1];
		dp[0][0] = 1;
		int mod = 1000000007;
		for (int i = 1; i <= n; i++) {
			dp[i][0] = 1;
			for (int p = 1; p <= k; p++) {
				dp[i][p] = (dp[i][p - 1] + dp[i - 1][p]) % mod;
				if (p >= i) {
					dp[i][p] = (dp[i][p] - dp[i - 1][p - i] + mod) % mod;
				}
			}
		}
		return dp[n][k];
	}
```

# 20220103 36经典面试二十

有一个很经典的面试题，完美洗牌问题。

面试的话更多都是在本上写代码，需要练的，其实各种各样的数据结构都找2道练练，在本上写一遍，就差不多行了，也就20 30个题。可以多增加点沟通技巧，在写代码的时候可以和面试官聊，让他喜欢自己。需要点情商。

## 题目三 符合二叉树条件的最大拓扑结构的大小

训练营4第6节 

如果你面试面对这样的题，那月薪应该在3W以上

![image-20230103161047885](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230103161047885-16727334489573.png)



这个比子树要难，因为他可能会舍去点节点。

​	这个题暴力的方法都不好解，暴力的流程是这样的，拓扑结构也有头结点，就看看以当前节点为头，int f(node)，就是必须以node为头，最大的是多少，那么就遍历他的所有子， 所有的返回值抓一个最大的，就是这个头的最大的。这个其实是O(N^3)的方法。。然后这里讲的是一个O(N)的方法。

​	拓扑贡献记录：是针对的唯一一个头部，每个节点都有一个拓扑贡献记录，指的是每个节点以i为头的节点他的子贡献多少个节点，比如说下图，右下的是客观上的最大拓扑结构，然后可以看到，左边的图的5，有2,3,2表示他的左孩子能贡献多少，3表示他的右孩子也能弄多少。

​	代码思路：到X的时候，就递归他的左右孩子，然后得到左右孩子的最大贡献，然后记录给自己，最后弄个全局变量，抓取一下最大的。这个贡献也都不用该的，自动含义迁移。找一下左树的右边界，如果哪个右边界比头结点大，那这个贡献就减去他的贡献，右树也是类似的，如果哪个右树的左边界小于等于头结点的值，就回去；其实就是左树的右边界过一遍回去，右树的左边界过一遍回去。这个就是二叉树的递归套路。 

​	然后这个代码没讲，太绕了。



![image-20230103164036362](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230103164036362-16727352377815.png)



```
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static int bstTopoSize1(Node head) {
		if (head == null) {
			return 0;
		}
		int max = maxTopo(head, head);
		max = Math.max(bstTopoSize1(head.left), max);
		max = Math.max(bstTopoSize1(head.right), max);
		return max;
	}

	public static int maxTopo(Node h, Node n) {
		if (h != null && n != null && isBSTNode(h, n, n.value)) {
			return maxTopo(h, n.left) + maxTopo(h, n.right) + 1;
		}
		return 0;
	}

	public static boolean isBSTNode(Node h, Node n, int value) {
		if (h == null) {
			return false;
		}
		if (h == n) {
			return true;
		}
		return isBSTNode(h.value > value ? h.left : h.right, n, value);
	}

	public static class Record {
		public int l;
		public int r;

		public Record(int left, int right) {
			this.l = left;
			this.r = right;
		}
	}

	public static int bstTopoSize2(Node head) {
		Map<Node, Record> map = new HashMap<Node, Record>();
		return posOrder(head, map);
	}

	public static int posOrder(Node h, Map<Node, Record> map) {
		if (h == null) {
			return 0;
		}
		int ls = posOrder(h.left, map);
		int rs = posOrder(h.right, map);
		modifyMap(h.left, h.value, map, true);
		modifyMap(h.right, h.value, map, false);
		Record lr = map.get(h.left);
		Record rr = map.get(h.right);
		int lbst = lr == null ? 0 : lr.l + lr.r + 1;
		int rbst = rr == null ? 0 : rr.l + rr.r + 1;
		map.put(h, new Record(lbst, rbst));
		return Math.max(lbst + rbst + 1, Math.max(ls, rs));
	}

	public static int modifyMap(Node n, int v, Map<Node, Record> m, boolean s) {
		if (n == null || (!m.containsKey(n))) {
			return 0;
		}
		Record r = m.get(n);
		if ((s && n.value > v) || ((!s) && n.value < v)) {
			m.remove(n);
			return r.l + r.r + 1;
		} else {
			int minus = modifyMap(s ? n.right : n.left, v, m, s);
			if (s) {
				r.r = r.r - minus;
			} else {
				r.l = r.l - minus;
			}
			m.put(n, r);
			return minus;
		}
	} 
```

## 题目四 调整数组为RLRL

![image-20230103171719738](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230103171719738-16727374406356.png)



​	完美洗牌问题。

这个题难在，额外空间O(1),时间复杂度O(N)，这个还是足够的难的，不会太高频，但是还是会出现的。

​	如果长度是偶数2N，做一个int f(i,N),如果i>N,说明是右半区的，那就该去$(i-N)*2-1$这个位置i <= N的话，他会去$i*2$的位置，这其实就是一个O(1)的过程。一个比较具有启发性的操作，就是下标循环去怼。因为给任意一个i都知道他要到哪个i'上去，在这么变化的过程，会有环，多个环过程之间是没有相交的，比如abcdef，a要到b,b要到d，d要到1,这就是一个环。当$S=3^k-1$,这个也是偶数，S就是总长度，环的出发点是$1,3,9,...3^{k-1}$，这是一个结论。然后直接循环这些出发点，会走一圈就行了。如果是普遍长度，首先要把右部分弄到左边，左部分弄到右边，比如abcdefgh换为efghabcd那就左部分逆序一下，右部分逆序一下，再整体逆序一下，就可以了，这是O(1)额外空间，O（N）的操作的。然后把普遍长度的2N分解为若干个S去做。虽然感觉这个拆分的过程复杂，不过其实每个点就做了一次的。

```
	// 数组的长度为len，调整前的位置是i，返回调整之后的位置
	// 下标不从0开始，从1开始
	public static int modifyIndex1(int i, int len) {
		if (i <= len / 2) {
			return 2 * i;
		} else {
			return 2 * (i - (len / 2)) - 1;
		}
	}

	// 数组的长度为len，调整前的位置是i，返回调整之后的位置
	// 下标不从0开始，从1开始
	public static int modifyIndex2(int i, int len) {
		return (2 * i) % (len + 1);
	}

	// 主函数
	// 数组必须不为空，且长度为偶数
	public static void shuffle(int[] arr) {
		if (arr != null && arr.length != 0 && (arr.length & 1) == 0) {
			shuffle(arr, 0, arr.length - 1);
		}
	}

	// 在arr[L..R]上做完美洗牌的调整（arr[L..R]范围上一定要是偶数个数字）
	public static void shuffle(int[] arr, int L, int R) {
		while (R - L + 1 > 0) { // 切成一块一块的解决，每一块的长度满足(3^k)-1
			int len = R - L + 1;
			int base = 3;
			int k = 1;
			// 计算小于等于len并且是离len最近的，满足(3^k)-1的数
			// 也就是找到最大的k，满足3^k <= len+1
			while (base <= (len + 1) / 3) { // base > (N+1)/3
				base *= 3;
				k++;
			}
			// 3^k -1
			// 当前要解决长度为base-1的块，一半就是再除2
			int half = (base - 1) / 2;
			// [L..R]的中点位置
			int mid = (L + R) / 2;
			// 要旋转的左部分为[L+half...mid], 右部分为arr[mid+1..mid+half]
			// 注意在这里，arr下标是从0开始的
			rotate(arr, L + half, mid, mid + half);
			// 旋转完成后，从L开始算起，长度为base-1的部分进行下标连续推
			cycles(arr, L, base - 1, k);
			// 解决了前base-1的部分，剩下的部分继续处理
			L = L + base - 1; // L ->     [] [+1...R]
		}
	}

	// 从start位置开始，往右len的长度这一段，做下标连续推
	// 出发位置依次为1,3,9...
	public static void cycles(int[] arr, int start, int len, int k) {
		// 找到每一个出发位置trigger，一共k个
		// 每一个trigger都进行下标连续推
		// 出发位置是从1开始算的，而数组下标是从0开始算的。
		for (int i = 0, trigger = 1; i < k; i++, trigger *= 3) {
			int preValue = arr[trigger + start - 1];
			int cur = modifyIndex2(trigger, len);
			while (cur != trigger) {
				int tmp = arr[cur + start - 1];
				arr[cur + start - 1] = preValue;
				preValue = tmp;
				cur = modifyIndex2(cur, len);
			}
			arr[cur + start - 1] = preValue;
		}
	}

	// [L..M]为左部分，[M+1..R]为右部分，左右两部分互换
	public static void rotate(int[] arr, int L, int M, int R) {
		reverse(arr, L, M);
		reverse(arr, M + 1, R);
		reverse(arr, L, R);
	}

	// [L..R]做逆序调整
	public static void reverse(int[] arr, int L, int R) {
		while (L < R) {
			int tmp = arr[L];
			arr[L++] = arr[R];
			arr[R--] = tmp;
		}
	}
```

# 题目三 多少对山峰能够互相看见

这个是算法训练营第4期第7节。==老左说第四期和第五期讲的题的难度是谷歌难度的==，在面试过程比笔试过程是有很大自由度的。

![image-20230104080255466](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230104080255466-16727905768291.png)

​	这个题如果没哟重复值的话，很简单，复杂度O(1) 如果1个数，那肯定0对，如果2个不相等的，那就是1对 ，三个数的话，就没有不相邻的情况，是3对，如果N个不重的数，N>3，那么肯定能找到最大值，和次大值。要从小找大，这样是去重的，对于任意一个X，先逆时针找第一个比X大的位置Y，同样的，X在逆时针也能找到第一个比X大的位置Z，毫无疑问YZ之间的另一面肯定对X不可见的，所以我们从小找大可以去重。 

​	**这个题麻烦在有重复值的情况。**那么为了找离他最近的最大的数，用单调栈就行了。栈的每一次多压一个次数的信息。很复杂吧过程。必须要从数组的最大值开始遍历，这相当于打了一个底。 这个时间复杂度是O(N)，因为每个数就出入栈一次。

​	单调栈就是特别想知道一个数组里面离他最近的大的或小的，然后想O(N)实现，那就可以用。

```
	// 栈中放的记录，
	// value就是指，times是收集的个数
	public static class Record {
		public int value;
		public int times;

		public Record(int value) {
			this.value = value;
			this.times = 1;
		}
	}

	public static int getVisibleNum(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int N = arr.length;
		int maxIndex = 0;
		// 先在环中找到其中一个最大值的位置，哪一个都行
		for (int i = 0; i < N; i++) {
			maxIndex = arr[maxIndex] < arr[i] ? i : maxIndex;
		}
		Stack<Record> stack = new Stack<Record>();
		// 先把(最大值,1)这个记录放入stack中
		stack.push(new Record(arr[maxIndex]));
		// 从最大值位置的下一个位置开始沿next方向遍历
		int index = nextIndex(maxIndex, N);
		// 用“小找大”的方式统计所有可见山峰对
		int res = 0;
		// 遍历阶段开始，当index再次回到maxIndex的时候，说明转了一圈，遍历阶段就结束
		while (index != maxIndex) {
			// 当前数要进入栈，判断会不会破坏第一维的数字从顶到底依次变大
			// 如果破坏了，就依次弹出栈顶记录，并计算山峰对数量
			while (stack.peek().value < arr[index]) {
				int k = stack.pop().times;
				// 弹出记录为(X,K)，如果K==1，产生2对; 如果K>1，产生2*K + C(2,K)对。
				res += getInternalSum(k) + 2 * k;
			}
			// 当前数字arr[index]要进入栈了，如果和当前栈顶数字一样就合并
			// 不一样就把记录(arr[index],1)放入栈中
			if (stack.peek().value == arr[index]) {
				stack.peek().times++;
			} else { // >
				stack.push(new Record(arr[index]));
			}
			index = nextIndex(index, N);
		}
		// 清算阶段开始了
		// 清算阶段的第1小阶段
		while (stack.size() > 2) {
			int times = stack.pop().times;
			res += getInternalSum(times) + 2 * times;
		}
		// 清算阶段的第2小阶段
		if (stack.size() == 2) {
			int times = stack.pop().times;
			res += getInternalSum(times)
					+ (stack.peek().times == 1 ? times : 2 * times);
		}
		// 清算阶段的第3小阶段
		res += getInternalSum(stack.pop().times);
		return res;
	}

	// 如果k==1返回0，如果k>1返回C(2,k)
	public static int getInternalSum(int k) {
		return k == 1 ? 0 : (k * (k - 1) / 2);
	}

	// 环形数组中当前位置为i，数组长度为size，返回i的下一个位置
	public static int nextIndex(int i, int size) {
		return i < (size - 1) ? (i + 1) : 0;
	}
```

 

# 20230104 37经典面试二十一

## 第四期第7节第二题搜索二叉树错误节点查找

![image-20230104192717922](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230104192717922-16728316391651.png)

99. 恢复二叉搜索树 力扣

对于这个原始的问题，跑个中序遍历，如果出现了两次降序，然后第一个降序的第一个节点，和第二个降序的第二个节点，就是他俩了。如果只出现一次降序，那就是，其实也是第一个降序的第一个节点，和第二个降序的第二个节点，只不过是同一次，另外不可能有不降序的，这样的话就是正常的搜索二叉树了。

​	对于进阶，交换值其实很简单，但是思考在工程上，一个树是一个组织，一个节点可能就是会提供一些API，或者也可能在工程上拷贝值比交换结构位置更复杂，这样的话交换值其实没啥用，应该交换结构位置。

​	这个题把十四种错误情况都考虑全了，一定要好好练练，练好了，那就二叉树差不多了。

​	讲一下思路哈，其实交换结构的时候，需要考虑三种大情况：1)e1,e2有没有可能有一个是另外一个的头;2)e1,e2分别与其父节点的关系，比如e1是他父节点的左孩子还是右孩子？同理e2;3)e1e,e2是否是挨着的？（这样的话那谁是父亲？）；以上这3种情况，展开的话应该就是14种情况了吧，比如说，3)，可能e1父e2左子，e1父e2右子，e2父e1左子，e2父e1右子；不过根据一些搜索二叉树的规则等，可以剔除一些错误的情况，比如我们知道e1是比e2先出来的，是吧，那么e1父e2左子，e2父e1右子是不可能出现的。**这个题很练边界条件的整理。**

​	这个题代码就是注释乱码。

```
	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node[] getTwoErrNodes(Node head) {
		Node[] errs = new Node[2];
		if (head == null) {
			return errs;
		}
		Stack<Node> stack = new Stack<Node>();
		Node pre = null;
		while (!stack.isEmpty() || head != null) {
			if (head != null) {
				stack.push(head);
				head = head.left;
			} else {
				head = stack.pop();
				if (pre != null && pre.value > head.value) {
					errs[0] = errs[0] == null ? pre : errs[0];
					errs[1] = head;
				}
				pre = head;
				head = head.right;
			}
		}
		return errs;
	}

	public static Node[] getTwoErrParents(Node head, Node e1, Node e2) {
		Node[] parents = new Node[2];
		if (head == null) {
			return parents;
		}
		Stack<Node> stack = new Stack<Node>();
		while (!stack.isEmpty() || head != null) {
			if (head != null) {
				stack.push(head);
				head = head.left;
			} else {
				head = stack.pop();
				if (head.left == e1 || head.right == e1) {
					parents[0] = head;
				}
				if (head.left == e2 || head.right == e2) {
					parents[1] = head;
				}
				head = head.right;
			}
		}
		return parents;
	}

	public static Node recoverTree(Node head) {
		Node[] errs = getTwoErrNodes(head);
		Node[] parents = getTwoErrParents(head, errs[0], errs[1]);
		Node e1 = errs[0];
		Node e1P = parents[0];
		Node e1L = e1.left;
		Node e1R = e1.right;
		Node e2 = errs[1];
		Node e2P = parents[1];
		Node e2L = e2.left;
		Node e2R = e2.right;
		if (e1 == head) {
			if (e1 == e2P) { // ���һ
				e1.left = e2L;
				e1.right = e2R;
				e2.right = e1;
				e2.left = e1L;
			} else if (e2P.left == e2) { // �����
				e2P.left = e1;
				e2.left = e1L;
				e2.right = e1R;
				e1.left = e2L;
				e1.right = e2R;
			} else { // �����
				e2P.right = e1;
				e2.left = e1L;
				e2.right = e1R;
				e1.left = e2L;
				e1.right = e2R;
			}
			head = e2;
		} else if (e2 == head) {
			if (e2 == e1P) { // �����
				e2.left = e1L;
				e2.right = e1R;
				e1.left = e2;
				e1.right = e2R;
			} else if (e1P.left == e1) { // �����
				e1P.left = e2;
				e1.left = e2L;
				e1.right = e2R;
				e2.left = e1L;
				e2.right = e1R;
			} else { // �����
				e1P.right = e2;
				e1.left = e2L;
				e1.right = e2R;
				e2.left = e1L;
				e2.right = e1R;
			}
			head = e1;
		} else {
			if (e1 == e2P) {
				if (e1P.left == e1) { // �����
					e1P.left = e2;
					e1.left = e2L;
					e1.right = e2R;
					e2.left = e1L;
					e2.right = e1;
				} else { // �����
					e1P.right = e2;
					e1.left = e2L;
					e1.right = e2R;
					e2.left = e1L;
					e2.right = e1;
				}
			} else if (e2 == e1P) {
				if (e2P.left == e2) { // �����
					e2P.left = e1;
					e2.left = e1L;
					e2.right = e1R;
					e1.left = e2;
					e1.right = e2R;
				} else { // ���ʮ
					e2P.right = e1;
					e2.left = e1L;
					e2.right = e1R;
					e1.left = e2;
					e1.right = e2R;
				}
			} else {
				if (e1P.left == e1) {
					if (e2P.left == e2) { // ���ʮһ
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e1R;
						e1P.left = e2;
						e2P.left = e1;
					} else { // ���ʮ��
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e1R;
						e1P.left = e2;
						e2P.right = e1;
					}
				} else {
					if (e2P.left == e2) { // ���ʮ��
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e1R;
						e1P.right = e2;
						e2P.left = e1;
					} else { // ���ʮ��
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e1R;
						e1P.right = e2;
						e2P.right = e1;
					}
				}
			}
		}
		return head;
	}
```

##第四期第8节题目四子序列累加和取余m后的最大值

![image-20230104195506187](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230104195506187-16728333075072.png)

​	这个题最简单的做法是背包问题。$dp[i][sum]$表示arr[0...i]位置自由选择，能否凑出来sum，这是一个bool类型的。最后再把所有能搞定的%m，就得到了。这个算法是O（N*sum)的。也就是说，如果sum很大的话，那就不行了。

​	第二个思路就是，$dp[i][j]$,j是0到m-1的，他的含义就是arr[0..i]上的所有累加和%m后能不能得到j，如果能就是True，还是一个bool类型的表。那么对于普遍情况，有1）假如$dp[i-1][j]$为True,那就是说不用i位置就可以了，那么$dp[i][j]$就直接为True;2)如果arr[i]=x,那么如果$dp[i-1][j-x]=True$,就是说用上了i位置的值，那就是True.3）就是可能转一圈回来，比如说m=10,想知道$dp[5][2]$,假设arr[5]=3,那么就是凑一个余数，比如12 % 10 =2，也就是说$dp[i-1][9]$为True,或者$dp[i-1][19]$是不用考虑的，因为19>m.

​	把这个表做好后，最后一行从右往左遍历，第一个True对应的列就是答案。这种方法的复杂度是O(N*M)

​	第三种方法。把数组，前N/2作为arrleft，后N/2作为arrright，就暴力的方法找到前N/2的所有累加和放到一个list，然后%m得到一个List'，对右侧也这么干，得到一个list'',那么想凑出所有的，有三种可能1）这个答案只单独来自arrleft，那么list'中最接近M-1的就是答案的一部分，List''中最接近M-1的就是答案的另一部分，第三部分就是list'和list''一起凑出来的，那就枚举arr1里每一个余数，去和list2''的凑，尽量凑最大，然后就是这仨的最大值就是最终答案。我们知道数组得到所有子序列的累加和代价为O(2^N)， 合并又是O(2^N)次方 分两半就不一样了，找两半的一共为$O(2*2^{N/2})$次方，再合并又是一个$O(2*2^{N/2})$次方,这小很多的。然后不能多分几半，因为分越多越不好整理。左侧不拿只拿右侧，或者右侧不拿只拿左侧，其实95行代码有序表的那个遍历就包含了，因为比如左侧拿0了，那其实就是只拿右侧的情况了。

  	对于第二种方法和第三种方法，主要看N大还是M大，决定了谁更优良。**这是一个NP的问题，在出这个问题的时候他就憋着你用第三种方法。**因为实际状况是，每一个位置的值都是$ 10^8 $,N=20个，$ M=10^{12}$次，

```
	/*
	 * 给定一个非负数组arr，和一个正数m。 返回arr的所有子序列中累加和%m之后的最大值。
	 * 
	 */

	public static int max1(int[] arr, int m) {
		HashSet<Integer> set = new HashSet<>();
		process(arr, 0, 0, set);
		int max = 0;
		for (Integer sum : set) {
			max = Math.max(max, sum % m);
		}
		return max;
	}

	public static void process(int[] arr, int index, int sum, HashSet<Integer> set) {
		if (index == arr.length) {
			set.add(sum);
		} else {
			process(arr, index + 1, sum, set);
			process(arr, index + 1, sum + arr[index], set);
		}
	}

	public static int max2(int[] arr, int m) {
		int sum = 0;
		int N = arr.length;
		for (int i = 0; i < N; i++) {
			sum += arr[i];
		}
		boolean[][] dp = new boolean[N][sum + 1];
		for (int i = 0; i < N; i++) {
			dp[i][0] = true;
		}
		dp[0][arr[0]] = true;
		for (int i = 1; i < N; i++) {
			for (int j = 1; j <= sum; j++) {
				dp[i][j] = dp[i - 1][j];
				if (j - arr[i] >= 0) {
					dp[i][j] = dp[i][j] | dp[i - 1][j - arr[i]];
				}
			}
		}
		int ans = 0;
		for (int j = 0; j <= sum; j++) {
			if (dp[N - 1][j]) {
				ans = Math.max(ans, j % m);
			}
		}
		return ans;

	}

	public static int max3(int[] arr, int m) {
		int N = arr.length;
		boolean[][] dp = new boolean[N][m];
		for (int i = 0; i < N; i++) {
			dp[i][0] = true;
		}
		dp[0][arr[0] % m] = true;
		for (int i = 1; i < N; i++) {
			for (int j = 1; j < m; j++) {
				// dp[i][j]  T or F
				dp[i][j] = dp[i - 1][j];
				int cur = arr[i] % m;
				if (j - cur >= 0) {
					dp[i][j] = dp[i][j] | dp[i - 1][j - cur];
				}
				if (j - cur < 0) {
					dp[i][j] = dp[i][j] | dp[i - 1][m + j - cur];
				}
			}
		}
		int ans = 0;
		for (int i = 0; i < m; i++) {
			if (dp[N - 1][i]) {
				ans = i;
			}
		}
		return ans;
	}

	// 如果arr的累加和很大，m也很大
	// 但是arr的长度相对不大
	public static int max4(int[] arr, int m) {
		if (arr.length == 1) {
			return arr[0] % m;
		}
		int mid = (arr.length - 1) / 2;
		TreeSet<Integer> sortSet1 = new TreeSet<>();
		process4(arr, 0, 0, mid, m, sortSet1);
		TreeSet<Integer> sortSet2 = new TreeSet<>();
		process4(arr, mid + 1, 0, arr.length - 1, m, sortSet2);
		int ans = 0;
		for (Integer leftMod : sortSet1) {
			ans = Math.max(ans, leftMod + sortSet2.floor(m - 1 - leftMod));
		}
		return ans;
	}

	// 从index出发，最后有边界是end+1，arr[index...end]
	public static void process4(int[] arr, int index, int sum, int end, int m, TreeSet<Integer> sortSet) {
		if (index == end + 1) {
			sortSet.add(sum % m);
		} else {
			process4(arr, index + 1, sum, end, m, sortSet);
			process4(arr, index + 1, sum + arr[index], end, m, sortSet);
		}
	}
```

## 题目一 N个项目结束时间（第七节）

![image-20230104203501346](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230104203501346-16728357021853.png)

​	可以做一个设计池，里面有N个给定的项目经理，然后每个项目就用堆区组织，根据他喜欢的优先级，一个大根堆。然后再做一个程序员的，比如说有5个程序员，他们的效率是一样的。这5个程序员都盯着一个项目池，他会把自己最喜欢的项目扔进项目池，每个经理只能扔进去一个项目一次，而他的这个项目池，是根据程序员的喜好标准去组织的。程序员的这个也是一个堆，项目池和设计池组成的结构，对外开放两个API，一个是add，加一个设计书加到设计池响应的，一个是get方法，得到程序员里的顶的项目，每个程序员都可以调用。假如说来了一个X，他到了项目经理1的位置，如果他进来后不是项目经理1最喜欢的项目，那么不用动项目池，否则，如果X成了项目经理1的最喜欢的，那么需要给他弄到程序员堆里，如果他不是程序员堆最喜欢的，就在那里，否则就到堆顶；**也就是说，这是两个堆配合的结构。**

​	78 79两行代码虽然一起用了，也就是说同时做了往上和往下，但是其实内部只会发生一个的。startQueue 是用来处理时间节点信息的，他会根据时间点分发项目。然后还有一个员工池，他是一个唤醒队列吧，就是wakeQueue.

​	这道题如果写完了，以后管理堆，就是爹。这个题，1000多人，只有6个过，倒数第二道。5个题给4个小时。

​	不算猎头费，一个高效的公司为了招一个合格的员工，那些HR，SP的时间等，内部消耗平均5千二招一个人，就是不说奖金啥的，完全的纯消耗。

```
	public static class Program {
		public int index;
		public int pm;
		public int start;
		public int rank;
		public int cost;

		public Program(int index, int pmNum, int begin, int rank, int cost) {
			this.index = index;
			this.pm = pmNum;
			this.start = begin;
			this.rank = rank;
			this.cost = cost;
		}
	}
	//程序员的一个比较器。 
	public static class PmLoveRule implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			if (o1.rank != o2.rank) {
				return o1.rank - o2.rank;
			} else if (o1.cost != o2.cost) {
				return o1.cost - o2.cost;
			} else {
				return o1.start - o2.start;
			}
		}

	}

	// 大黑盒
	// 每一个pm，有自己的堆(PmLoveRule)
	// 每一个pm的堆里有堆顶，所有的堆顶会再组成一个，程序员堆(程序员喜好)
	// void add(...)  项目  pop()
	public static class BigQueues {
		//  PriorityQueue<Program> pmQ = pmQueues.get(i);
		private List<PriorityQueue<Program>> pmQueues;
		// 程序员堆（一个，程序员共享池）
		private Program[] sdeHeap;
		// indexes[i] -> i号pm的堆顶项目，在sde堆中处在啥位置
		private int[] indexes; 
		private int heapsize; // 程序员堆的大小

		public BigQueues(int pmNum) {
			heapsize = 0;
			sdeHeap = new Program[pmNum];
			indexes = new int[pmNum + 1];
			for (int i = 0; i <= pmNum; i++) {
				indexes[i] = -1;
			}
			pmQueues = new ArrayList<>();
			// i  pmQueues.get(i)
			for (int i = 0; i <= pmNum; i++) {
				pmQueues.add(new PriorityQueue<Program>(new PmLoveRule()));
			}
		}

		// 当前是否有项目可以弹出被程序员做
		public boolean isEmpty() {
			return heapsize == 0;
		}

		// 某一个项目加入了，黑盒里
		public void add(Program program) {
			PriorityQueue<Program> pmHeap = pmQueues.get(program.pm);
			pmHeap.add(program);
			// 有可能当前的项目，成了此时pm最喜欢的项目，换堆顶，调整sde堆中的项目
			Program head = pmHeap.peek(); // 现在的堆顶
			// 之前pm在sde堆中的自己的堆顶，sde？
			int heapindex = indexes[head.pm];
			if (heapindex == -1) { // 之前没堆顶, 
				sdeHeap[heapsize] = head;
				indexes[head.pm] = heapsize;
				heapInsert(heapsize++);
			} else { // 加此时的program之前，我有老堆顶
				sdeHeap[heapindex] = head;
				heapInsert(heapindex);
				heapify(heapindex);
			}
		}

		// 程序员挑项目，返回挑选的项目
		public Program pop() {
			Program head = sdeHeap[0];
			PriorityQueue<Program> queue = pmQueues.get(head.pm);
			queue.poll();
			if (queue.isEmpty()) { // 此时的pm手上没有项目了
				swap(0, heapsize - 1);
				sdeHeap[--heapsize] = null;
				indexes[head.pm] = -1;
			} else {
				sdeHeap[0] = queue.peek();
			}
			heapify(0);
			return head;
		}

		private void heapInsert(int index) {
			while (index != 0) {
				int parent = (index - 1) / 2;
				if (sdeLoveRule(sdeHeap[parent], sdeHeap[index]) > 0) {
					swap(parent, index);
					index = parent;
				} else {
					break;
				}
			}
		}

		private void heapify(int index) {
			int left = index * 2 + 1;
			int right = index * 2 + 2;
			int best = index;
			while (left < heapsize) {
				if (sdeLoveRule(sdeHeap[left], sdeHeap[index]) < 0) {
					best = left;
				}
				if (right < heapsize && sdeLoveRule(sdeHeap[right], sdeHeap[best]) < 0) {
					best = right;
				}
				if (best == index) {
					break;
				}
				swap(best, index);
				index = best;
				left = index * 2 + 1;
				right = index * 2 + 2;
			}
		}

		private void swap(int index1, int index2) {
			Program p1 = sdeHeap[index1];
			Program p2 = sdeHeap[index2];
			sdeHeap[index1] = p2;
			sdeHeap[index2] = p1;
			indexes[p1.pm] = index2;
			indexes[p2.pm] = index1;
		}

		private int sdeLoveRule(Program p1, Program p2) {
			if (p1.cost != p2.cost) {
				return p1.cost - p2.cost;
			} else {
				return p1.pm - p2.pm;
			}
		}

	}

	public static class StartRule implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o1.start - o2.start;
		}

	}

	public static int[] workFinish(int pms, int sdes, int[][] programs) {
		// 所有被锁住的项目（3，6，9）   time=0
		PriorityQueue<Program> startQueue  = new PriorityQueue<Program>(new StartRule());
		for (int i = 0; i < programs.length; i++) {
			Program program = new Program(
					i, programs[i][0], programs[i][1], programs[i][2], programs[i][3]);
			startQueue.add(program);
		}
		// 所有的项目，在最开始的时候，都在start堆中，被锁住
		//
		//
		PriorityQueue<Integer> wakeQueue = new PriorityQueue<Integer>();
		for (int i = 0; i < sdes; i++) {
			wakeQueue.add(1);
		}
		// add   pop   isEmpty
		BigQueues bigQueues = new BigQueues(pms);
		int finish = 0; // 目前完成项目的数量
		int[] ans = new int[programs.length];	
		while (finish != ans.length) { // 没有得到所有的答案就继续
			// 最早醒来的程序员的时间, 也是总的推进时间点
			int sdeWakeTime = wakeQueue.poll(); 
			while (!startQueue.isEmpty()) {
				if (startQueue.peek().start > sdeWakeTime) {
					break;
				}
				bigQueues.add(startQueue.poll());
			}
			// 
			if (bigQueues.isEmpty()) { // 当前时间点并无项目可做
				wakeQueue.add(startQueue.peek().start);
			} else { // 当前时间点有项目可做
				Program program = bigQueues.pop();
				ans[program.index] = sdeWakeTime + program.cost;
				wakeQueue.add(ans[program.index]);
				finish++;
			}
		}
		return ans;
	}
```



# 20230104 38经典面试二十二

后缀数组就用训练营第五期第八节的SuffixArray的代码，这个是一个大佬比赛写的模板。很帅。百度找的其实很多都是错的。工作的时候，如果总用不到算法，就要考虑跳槽了。。说明这个工作不太行。

​	网易一般是5个题做出来两个就会有面试资格。然后弄难的题是为了怕错过人才。第二弄难的是为了压薪水。在谈薪水的时候算法难题是个条件，自己也可以谈高点。 





## 题目一判断字符串

![image-20230104220109382](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230104220109382-16728408703364.png)

一个正则匹配的问题。比如所，如果是".*",可以说设么都匹配的。比如说str=aaabcde,那么a * abcde，他们其实也是匹配的

​	这个可以定义一个 bool f(str,express,si,ei)意思就是str[si...]能否exp[ei....]给变成，主函数其实就是调用f(str,exp,0,0)。然后match不会*开头，也不会有**，这都是不合法的。

​	比如来到了si,ei的位置，看一下ei+1是不是非*，那么必须ei和si对上，就是说`str[si]==exp[ei] || exp[ei] == "." `如果成立的话，就去做f(si+1,ei+1)的位置。44行代码，f(si,ei+2)的意思是，比如说`str=aaaabc`,然后`exp=k*bc`,那么当i=0的时候，很明显k!=a,这个时候如果 *为0的话，就该看那个b和第一个a匹配不匹配了，所以不动si动ei如果说`exp=a*.....`那么这个 * 会有很多的可能性，为了跟str匹配。这个的代码是在42行这个while循环。最后这个return的ei+2，是因为while少试这么一个情况。

​	这个题很有意思，我们发现他是两个可变参数的尝试，那其实就是改为一个二维表了，这个其实最后要的是`dp[0][0]`,basecase是填的最后一列。一个格子`dp[i][j]`一定会依赖`dp[i-1][j-1]`,然后他会依赖`dp[x][ei+2]`,x表示可能依赖从si到他下方的若干个位置。那么需要开始的时候先填一个basecase，然后再准备一下最后一行和倒数第二列。

   如果最后一个位置的ei是*，那么倒数第二列其实是不用求的，因为他不可能是 * (因为不会**这种情况)，所以无所谓。如果最后一个位置ei不为 * ,那么就知道最后一行的导数第二列必为F，然后他上面是T还是F取决于是否对应相等，再上面就全是F肯定。（因为俩长度不一样）。对于最后一行，如果说`ei=d*c*a*e*`,类似的，如果对应那就对了，如果断了，那前面都是False。（这个最后一行的情况还是看代码吧，有点抽象我这写的。。）

​	代码的initDPMap这个函数就是上面这一段说的。

​	如果不懂basecase，那么可以先考虑普遍位置，让后再推basecase，比如这个题的倒数第二列和最后一行要填。

​	代码我添加注释了。

​	这个代码其实可以斜率优化，不过这个代码没有写。这个优化只有在，比如说`str=aaaaab`类似的时候可以优化下。

```
	public static boolean isValid(char[] s, char[] e) {
		// s中不能有'.'  or  '*'
		for (int i = 0; i < s.length; i++) {
			if (s[i] == '*' || s[i] == '.') {
				return false;
			}
		}
		// 开头的e[0]不能是'*'，没有相邻的'*'
		for (int i = 0; i < e.length; i++) {
			if (e[i] == '*' && (i == 0 || e[i - 1] == '*')) {
				return false;
			}
		}
		return true;
	}

	public static boolean isMatch(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		return isValid(s, e) && process(s, e, 0, 0);
	}

	// e[ei....]  能否变成  s[si...]
	// 重要限制：e[ei]不能压中'*'
	public static boolean process(char[] s, char[] e, int si, int ei) {
		if (ei == e.length) { // base case   exp已经耗尽了  ""
			return si == s.length;
		}
		// si == s.length  没有讨论
		// exp[ei]有字符的   exp[ei] != "*"
		// 可能性一，ei+1位置，不是*
		if (ei + 1 == e.length || e[ei + 1] != '*') {
			// s[si...]必须有东西  &&   s[si]  e[ei]   && 后续还得能对上
			return si != s.length 
					&& (e[ei] == s[si] || e[ei] == '.') 
					&& process(s, e, si + 1, ei + 1);
		}
		// ei + 1 位置是*
		// 尝试  [ei][ei+1]共同的部分，匹配str可能的前缀
		while (si != s.length && (e[ei] == s[si] || e[ei] == '.')) {
			if (process(s, e, si, ei + 2)) {
				return true;
			}
			si++;
		}
		return process(s, e, si, ei + 2);
	}

	public static boolean isMatchDP(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		if (!isValid(s, e)) {
			return false;
		}
		// initDPMap  做出一张表，而且填好倒数两列，和最后一行
		boolean[][] dp = initDPMap(s, e);
		for (int i = s.length - 1; i > -1; i--) {
			for (int j = e.length - 2; j > -1; j--) {
				if (e[j + 1] != '*') {
					dp[i][j] = (s[i] == e[j] || e[j] == '.') && dp[i + 1][j + 1];
				} else {
					int si = i;
					while (si != s.length && (s[si] == e[j] || e[j] == '.')) {
						if (dp[si][j + 2]) {
							dp[i][j] = true;
							break;
						}
						si++;
					}
					if (dp[i][j] != true) {
						dp[i][j] = dp[si][j + 2];
					}
				}
			}
		}
		return dp[0][0];
	}

	public static boolean[][] initDPMap(char[] s, char[] e) {
		int slen = s.length;
		int elen = e.length;
		boolean[][] dp = new boolean[slen + 1][elen + 1];
		dp[slen][elen] = true;# 填最后一个位置。
		
		// 填最后一行
		for (int j = elen - 2; j > -1; j = j - 2) {
			if (e[j] != '*' && e[j + 1] == '*') {
				dp[slen][j] = true;
			} else {
				break;
			}
		}
		// 填倒数第二行的倒数第二列的位置。
		if (slen > 0 && elen > 0) {
			if ((e[elen - 1] == '.' || s[slen - 1] == e[elen - 1])) {
				dp[slen - 1][elen - 1] = true;
			}
		}
		return dp;
	}
```



​		

​	









## 题目二 力扣514自由之路

记忆化搜索

这个题可能是最近见得最简单的题。 

​	力扣其实中等难度大于困难的题多了去了，因为中等难度的解法并不限制最优解罢了，如果限制的话很多也是很顶的。

​	`int f(i,j)`表示从i位置到j位置，其实就是两个方向里面最少的返回。

​	首先做一个map:{key:[key出现的所有位置]}最后就是一个深度优先遍历就行了。

​	这个代码可以从递归改为记忆化搜索。

```
	public static class Node {
		public int value;
		Node left;
		Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void morris(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			// cur有没有左树
			mostRight = cur.left;
			if (mostRight != null) { // 有左树的情况下
				// 找到cur左树上，真实的最右
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				// 从while中出来，mostRight一定是cur左树上的最右节点
				// mostRight
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // mostRight.right != null -> mostRight.right == cur
					mostRight.right = null;
				}
			}
			cur = cur.right;
		}
	}

	public static void morrisIn(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			System.out.print(cur.value + " ");
			cur = cur.right;
		}
		System.out.println();
	}

	public static void morrisPre(Node head) {
		if (head == null) {
			return;
		}
		Node cur1 = head;
		Node cur2 = null;
		while (cur1 != null) {
			cur2 = cur1.left;
			if (cur2 != null) {
				while (cur2.right != null && cur2.right != cur1) {
					cur2 = cur2.right;
				}
				if (cur2.right == null) {
					cur2.right = cur1;
					System.out.print(cur1.value + " ");
					cur1 = cur1.left;
					continue;
				} else {
					cur2.right = null;
				}
			} else {
				System.out.print(cur1.value + " ");
			}
			cur1 = cur1.right;
		}
		System.out.println();
	}

	public static void morrisPos(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
					printEdge(cur.left);
				}
			}
			cur = cur.right;
		}
		printEdge(head);
		System.out.println();
	}

	public static void printEdge(Node head) {
		Node tail = reverseEdge(head);
		Node cur = tail;
		while (cur != null) {
			System.out.print(cur.value + " ");
			cur = cur.right;
		}
		reverseEdge(tail);
	}

	public static Node reverseEdge(Node from) {
		Node pre = null;
		Node next = null;
		while (from != null) {
			next = from.right;
			from.right = pre;
			pre = from;
			from = next;
		}
		return pre;
	}

	// for test -- print tree
	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}

	public static boolean isBST(Node head) {
		if (head == null) {
			return true;
		}
		Node cur = head;
		Node mostRight = null;
		Integer pre = null;
		boolean ans = true;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			if (pre != null && pre >= cur.value) {
				ans = false;
			}
			pre = cur.value;
			cur = cur.right;
		}
		return ans;
	}
```



## 题目三 打爆气球的最大分数

基础班讲过的递归试法设计原则。从左往右尝试模型

![image-20230105071017266](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230105071017266-16728738191911.png)

​	力扣\312. 戳气球

​	 `int f(L,R)`表示在arr[L...R]的范围上打爆气球，并且L-1位置是没爆的，R+1位置也是没爆的。打爆arr[L...R]上的所有气球最大得分是什么。那么主函数就是，比如arr为[3,2,5],那么给他填充一下变为arr=[1,3,2,5,1],然后0和4位置永远不用。考虑谁是最后打的气球？1)L最后爆，`f(L+1,R)+[L-1]*[L]*[R+1]`;2)R最后爆，`f(L,R-1)+[L-1]*[R]*[R+1]`.3)对于普遍尝试，中间位置i为`f(L,i-1)+f(i+1,R)+[L-1]*[i]*[R+1]`,取一个max

​	这个题暴力尝试还是不好想的，一般会想去枚举f(L...R)，这样其实不太行的。这其实就是原则起作用了。什么试法都不要让自己的可变参数突破整型的复杂程度。这个问题本身就是要拿**最后一个打爆的去试**，这个想法很有意思的。

```
	public static int maxCoins1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		if (arr.length == 1) {
			return arr[0];
		}
		int N = arr.length;
		int[] help = new int[N + 2];
		help[0] = 1;
		help[N + 1] = 1;
		for (int i = 0; i < N; i++) {
			help[i + 1] = arr[i];
		}
		return process(help, 1, N);
	}

	// 打爆arr[L..R]范围上的所有气球，返回最大的分数
	// 假设arr[L-1]和arr[R+1]一定没有被打爆
	public static int process(int[] arr, int L, int R) {
		if (L == R) {// 如果arr[L..R]范围上只有一个气球，直接打爆即可
			return arr[L - 1] * arr[L] * arr[R + 1];
		}
		// 最后打爆arr[L]的方案，和最后打爆arr[R]的方案，先比较一下
		int max = Math.max(
				arr[L - 1] * arr[L] * arr[R + 1] + process(arr, L + 1, R),
				arr[L - 1] * arr[R] * arr[R + 1] + process(arr, L, R - 1));
		// 尝试中间位置的气球最后被打爆的每一种方案
		for (int i = L + 1; i < R; i++) {
			max = Math.max(max,
					arr[L - 1] * arr[i] * arr[R + 1] + process(arr, L, i - 1)
							+ process(arr, i + 1, R));
		}
		return max;
	}

	public static int maxCoins2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		if (arr.length == 1) {
			return arr[0];
		}
		int N = arr.length;
		int[] help = new int[N + 2];
		help[0] = 1;
		help[N + 1] = 1;
		for (int i = 0; i < N; i++) {
			help[i + 1] = arr[i];
		}
		int[][] dp = new int[N + 2][N + 2];
		for (int i = 1; i <= N; i++) {
			dp[i][i] = help[i - 1] * help[i] * help[i + 1];
			System.out.println(dp[i][i]);
		}
		for (int L = N; L >= 1; L--) {
			for (int R = L + 1; R <= N; R++) {
				// 求解dp[L][R]，表示help[L..R]上打爆所有气球的最大分数
				// 最后打爆help[L]的方案
				int finalL = help[L - 1] * help[L] * help[R + 1] + dp[L + 1][R];
				// 最后打爆help[R]的方案
				int finalR = help[L - 1] * help[R] * help[R + 1] + dp[L][R - 1];
				// 最后打爆help[L]的方案，和最后打爆help[R]的方案，先比较一下
				dp[L][R] = Math.max(finalL, finalR);
				// 尝试中间位置的气球最后被打爆的每一种方案
				for (int i = L + 1; i < R; i++) {
					dp[L][R] = Math.max(dp[L][R], help[L - 1] * help[i]
							* help[R + 1] + dp[L][i - 1] + dp[i + 1][R]);
				}
			}
		}
		return dp[1][N];
	}
```



## 题目四 汉诺塔问题2

arr数组上只有1,2,3三个值，表示在左中右三个塔上，也就是说这个arr可以表示一个汉诺塔状态，如果他是最优解走法中的其中一步，那就返回第几步否则返回-1.

​	第0步是arr全为1的状态。·int f(arr,N,from,to,other)`返回他是整体大目标的第几步，如果不属于，那就返回-1.汉诺塔就是三步1)0到i-1从from到other，第二步是i从from到to，第三步是0到i-1从other到to。那么明显1)3)两步就是递归调用就行了，如果发现arr[i]==other，那就返回-1就行了，因为从上面的三步可以看出来，不会出现这个情况。如果发现    arr[i] == from,那就调用f(arr,i-1,from,other,to)就行了，因为这个调用其实就是说1)的情况走了多少步，这就找到了i走了多少。然后我们知道汉诺塔问题得走2^N-1步，那么如果我知道了3)要走多少步，其实一减就有了。其实就是22行代码的了。

```
	public static int step1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1;
		}
		return process(arr, arr.length - 1, 1, 2, 3);
	}

	// 目标是:  把0~i的圆盘，从from全部挪到to上
	// 返回，根据arr中的状态arr[0..i]，它是最优解的第几步？
	// f(i, 3 , 2, 1)    f(i, 1, 3, 2)    f(i, 3, 1, 2)
	public static int process(int[] arr, int i, int from, int other, int to) {
		if (i == -1) {
			return 0;
		}
		if (arr[i] != from && arr[i] != to) {
			return -1;
		}
		if (arr[i] == from) { // 第一大步没走完
			return process(arr, i - 1, from, to, other);
		} else { // arr[i] == to
			// 已经走完1，2两步了，
			int rest = process(arr, i - 1, other, from, to); // 第三大步完成的程度
			if (rest == -1) {
				return -1;
			}
			return (1 << i) + rest;
		}
	}

	public static int step2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1;
		}
		int from = 1;
		int mid = 2;
		int to = 3;
		int i = arr.length - 1;
		int res = 0;
		int tmp = 0;
		while (i >= 0) {
			if (arr[i] != from && arr[i] != to) {
				return -1;
			}
			if (arr[i] == to) {
				res += 1 << i;
				tmp = from;
				from = mid;
			} else {
				tmp = to;
				to = mid;
			}
			mid = tmp;
			i--;
		}
		return res;
	}
```





## 题目五 相邻k个数字合并的最小代价

也是牵涉到递归试法的设计原则，实际上是范围上的尝试。



![image-20230105073646888](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230105073646888-16728754079492.png)

这有一个大过滤，就是根据数组长度N和K可以知道能不能合并出来。代码给了就是`(n-1)%(k-1)>0`这个猜法的话，可以写为`int f(L,R,part)`，表示在[L...R]上一定要合出part个数，最小代价是什么。

​	注意第31行的for循环为mid+=k-1,其实用mid++也是行的，不过有很多的解不用试，他们一定返回-1所以要给他们过滤掉。

​	这个题位置依赖不好整理，就改记忆化搜索。这个题就是记忆化搜索。

	public static int mergeStones1(int[] stones, int K) {
		int n = stones.length;
		if ((n - 1) % (K - 1) > 0) {
			return -1;
		}
		int[] presum = new int[n + 1];
		for (int i = 0; i < n; i++) {
			presum[i + 1] = presum[i] + stones[i];
		}
		return process1(0, n - 1, 1, stones, K, presum);
	}
	
	// part >= 1
	// arr[L..R]  一定要弄出part份，返回最低代价
	// arr、K、presum（前缀累加和数组，求i..j的累加和，就是O(1)了）
	public static int process1(int L, int R, int part, int[] arr, int K, int[] presum) {
		if (L == R) { // arr[L..R]
			return part == 1 ? 0 : -1;
		}
		// L ... R  不只一个数
		if (part == 1) {
			int next = process1(L, R, K, arr, K, presum);
			if (next == -1) {
				return -1;
			} else {
				return next + presum[R + 1] - presum[L];
			}
		} else { // P > 1
			int ans = Integer.MAX_VALUE;
			// L...mid是第1块，剩下的是part-1块
			for (int mid = L; mid < R; mid += K - 1) {
				// L..mid(一份)   mid+1...R(part - 1)
				int next1 = process1(L, mid, 1, arr, K, presum);
				int next2 = process1(mid + 1, R, part - 1, arr, K, presum);
				if (next1 != -1 && next2 != -1) {
					ans = Math.min(ans, next1 + next2);
				}
			}
			return ans;
		}
	}





# 20230105 39经典面试二十三（这一期音画不同步先不看了）

训练营第五期第一节，训练第五期最难了。



## 子串包含的最小长度

![image-20230105082459610](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230105082459610-16728783005083.png)

哈希表。



# 20230105 40经典面试二十四

训练营第五期第一节

## 题目三LFU

![image-20230105165808357](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230105165808357-16729090895644.png)



​	这个题的难度其实不在于算法，而在于coding；前面好像第三期还讲过一个LRU；LFU就是扔掉频度最低的那个，如果频度都一样最小的，那就仍上次修改时间最久远的那个。

​	这个get()和put()都是O(1)的。put()做O(1)还是比较难的，因为有替换的情况。这是一个二维双向链表。如下图，就是每一个桶内部都是一个双链表，然后桶也是双链表的一个节点。

​	要做一个map，去存值的位置，就是他在一个桶的哪个位置`str->node`。这样下次再来的话就不用遍历了，因为直接有他的地址node。同样还有一个map，node是键，然后有他在桶的位置`node->bucked`。每个桶放的是频数为x的数值，比如可能桶1放的是频数为1，桶2放的是频数为2.。。等。在get()后，如果一个桶变为空了，要把桶给删掉。这个题难就难在调整容易整迷。

![image-20230105170813269](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230105170813269-16729096943385.png)



然后这个代码就跳过了没讲。笔试会出现，面试也会出现的，不过面试是让填一个片段，这个样子。面试的时候要和面试官轻松的聊一聊。

```
	// 节点的数据结构
	public static class Node {
		public Integer key;
		public Integer value;
		public Integer times; // 这个节点发生get或者set的次数总和
		public Node up; // 节点之间是双向链表所以有上一个节点
		public Node down;// 节点之间是双向链表所以有下一个节点

		public Node(int key, int value, int times) {
			this.key = key;
			this.value = value;
			this.times = times;
		}
	}

	// 桶结构
	public static class NodeList {
		public Node head; // 桶的头节点
		public Node tail; // 桶的尾节点
		public NodeList last; // 桶之间是双向链表所以有前一个桶
		public NodeList next; // 桶之间是双向链表所以有后一个桶

		public NodeList(Node node) {
			head = node;
			tail = node;
		}

		// 把一个新的节点加入这个桶，新的节点都放在顶端变成新的头部
		public void addNodeFromHead(Node newHead) {
			newHead.down = head;
			head.up = newHead;
			head = newHead;
		}

		// 判断这个桶是不是空的
		public boolean isEmpty() {
			return head == null;
		}

		// 删除node节点并保证node的上下环境重新连接
		public void deleteNode(Node node) {
			if (head == tail) {
				head = null;
				tail = null;
			} else {
				if (node == head) {
					head = node.down;
					head.up = null;
				} else if (node == tail) {
					tail = node.up;
					tail.down = null;
				} else {
					node.up.down = node.down;
					node.down.up = node.up;
				}
			}
			node.up = null;
			node.down = null;
		}
	}

	// 总的缓存结构
	public static class LFUCache {
		private int capacity; // 缓存的大小限制，即K
		private int size; // 缓存目前有多少个节点
		private HashMap<Integer, Node> records;// 表示key(Integer)由哪个节点(Node)代表
		private HashMap<Node, NodeList> heads; // 表示节点(Node)在哪个桶(NodeList)里
		private NodeList headList; // 整个结构中位于最左的桶

		public LFUCache(int K) {
			this.capacity = K;
			this.size = 0;
			this.records = new HashMap<>();
			this.heads = new HashMap<>();
			headList = null;
		}

		// removeNodeList：刚刚减少了一个节点的桶
		// 这个函数的功能是，判断刚刚减少了一个节点的桶是不是已经空了。
		// 1）如果不空，什么也不做
		//
		// 2)如果空了，removeNodeList还是整个缓存结构最左的桶(headList)。
		// 删掉这个桶的同时也要让最左的桶变成removeNodeList的下一个。
		//
		// 3)如果空了，removeNodeList不是整个缓存结构最左的桶(headList)。
		// 把这个桶删除，并保证上一个的桶和下一个桶之间还是双向链表的连接方式
		//
		// 函数的返回值表示刚刚减少了一个节点的桶是不是已经空了，空了返回true；不空返回false
		private boolean modifyHeadList(NodeList removeNodeList) {
			if (removeNodeList.isEmpty()) {
				if (headList == removeNodeList) {
					headList = removeNodeList.next;
					if (headList != null) {
						headList.last = null;
					}
				} else {
					removeNodeList.last.next = removeNodeList.next;
					if (removeNodeList.next != null) {
						removeNodeList.next.last = removeNodeList.last;
					}
				}
				return true;
			}
			return false;
		}

		// 函数的功能
		// node这个节点的次数+1了，这个节点原来在oldNodeList里。
		// 把node从oldNodeList删掉，然后放到次数+1的桶中
		// 整个过程既要保证桶之间仍然是双向链表，也要保证节点之间仍然是双向链表
		private void move(Node node, NodeList oldNodeList) {
			oldNodeList.deleteNode(node);
			// preList表示次数+1的桶的前一个桶是谁
			// 如果oldNodeList删掉node之后还有节点，oldNodeList就是次数+1的桶的前一个桶
			// 如果oldNodeList删掉node之后空了，oldNodeList是需要删除的，所以次数+1的桶的前一个桶，是oldNodeList的前一个
			NodeList preList = modifyHeadList(oldNodeList) ? oldNodeList.last
					: oldNodeList;
			// nextList表示次数+1的桶的后一个桶是谁
			NodeList nextList = oldNodeList.next;
			if (nextList == null) {
				NodeList newList = new NodeList(node);
				if (preList != null) {
					preList.next = newList;
				}
				newList.last = preList;
				if (headList == null) {
					headList = newList;
				}
				heads.put(node, newList);
			} else {
				if (nextList.head.times.equals(node.times)) {
					nextList.addNodeFromHead(node);
					heads.put(node, nextList);
				} else {
					NodeList newList = new NodeList(node);
					if (preList != null) {
						preList.next = newList;
					}
					newList.last = preList;
					newList.next = nextList;
					nextList.last = newList;
					if (headList == nextList) {
						headList = newList;
					}
					heads.put(node, newList);
				}
			}
		}

		public void put(int key, int value) {
			if(capacity == 0) {
				return;
			}
			if (records.containsKey(key)) {
				Node node = records.get(key);
				node.value = value;
				node.times++;
				NodeList curNodeList = heads.get(node);
				move(node, curNodeList);
			} else {
				if (size == capacity) {
					Node node = headList.tail;
					headList.deleteNode(node);
					modifyHeadList(headList);
					records.remove(node.key);
					heads.remove(node);
					size--;
				}
				Node node = new Node(key, value, 1);
				if (headList == null) {
					headList = new NodeList(node);
				} else {
					if (headList.head.times.equals(node.times)) {
						headList.addNodeFromHead(node);
					} else {
						NodeList newList = new NodeList(node);
						newList.next = headList;
						headList.last = newList;
						headList = newList;
					}
				}
				records.put(key, node);
				heads.put(node, headList);
				size++;
			}
		}

		public Integer get(int key) {
			if (!records.containsKey(key)) {
				return null;
			}
			Node node = records.get(key);
			node.times++;
			NodeList curNodeList = heads.get(node);
			move(node, curNodeList);
			return node.value;
		}

	}
```



## 题目四 最大的三子数组的最大和

![image-20230106100447765](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106100447765-16729706892181.png)



`dp[i]`表示从0到i位置的所有子数组中累加和最大的是多少 ；情况1)选择的子数组以i结尾,这个时候有两种可能，1个是只和arr[i]有关，另外一个是看看max(dp[i-1]+arr[i]和dp[i-1])；2）选择的子数组不以i结尾，那直接就是等于`dp[i-1]`

​	现在做两个，一个dp1,一个dp2,dp1[i]是必须以i结尾的最大累加和，dp2[i]是必须不以i结尾的 。dp1[i]就用子数组的最大累加和问题来得到。 

​	先说原问题，求dp[i]表示0...ik个连续子数组最大，有了。再求dp反[i] 表示i到n-1上选k个数做子数组，得到累加和。dpi和dp反i中间有k个数。 不好理解反正，这段看着忘了就行。就是下图的吧。必须dp给这5个程度，然后中间也是K=5的长度。

​	这个题感觉听的不太理解。

![image-20230106101504768](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106101504768-16729713067382.png)



```
	public static int[] maxSumOfThreeSubarrays(int[] nums, int k) {
		int N = nums.length;
		int[] range = new int[N];
		int[] left = new int[N];
		int sum = 0;
		for (int i = 0; i < k; i++) {
			sum += nums[i];
		}
		range[0] = sum;
		left[k - 1] = 0;
		int max = sum;
		for (int i = k; i < N; i++) {
			sum = sum - nums[i - k] + nums[i];
			range[i - k + 1] = sum;
			left[i] = left[i - 1];
			if (sum > max) {
				max = sum;
				left[i] = i - k + 1;
			}
		}
		sum = 0;
		for (int i = N - 1; i >= N - k; i--) {
			sum += nums[i];
		}
		max = sum;
		int[] right = new int[N];
		right[N - k] = N - k;
		for (int i = N - k - 1; i >= 0; i--) {
			sum = sum - nums[i + k] + nums[i];
			right[i] = right[i + 1];
			if (sum >= max) {
				max = sum;
				right[i] = i;
			}
		}
		int a = 0;
		int b = 0;
		int c = 0;
		max = 0;
		for (int i = k; i < N - 2 * k + 1; i++) { // 中间一块的起始点  (0...k-1)选不了   i == N-1
			
			int part1 = range[left[i - 1]];
			int part2 = range[i];
			int part3 = range[right[i + k]];
			if (part1 + part2 + part3 > max) {
				max = part1 + part2 + part3;
				a = left[i - 1];
				b = i;
				c = right[i + k];
			}
		}
		return new int[] { a, b, c };
	}
```



## 题目二 分糖果



![image-20230106102926540](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106102926540-16729721676343.png)





这个题如果让用辅助数组的话很简单，难就难在不用.

​	这个题其实就是贪心，不过不是特别好猜，比如说就是下面的这个，顶部的就以坡度大的算。比如说4这个值，对吧，他左侧的上坡是1,2,他右侧的上坡是1,2,3如果我填3的话，那岂不是没有右边的三大嘛，所以要按照坡度大的算，1,2,3该填4了。

![image-20230106103638441](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106103638441-16729725999304.png)



​	然后还可以推出来更简单的。 做两个数组，一个left,一个right,left从左往右，如果I比i-1大，那就是left[i-1]+1，不然回到1.right同理，arr[i]不必arr[i-1]大，回到1，不然是right[i+1]+1，然后每个孩子怎么分糖，就是求最大值了。

​	如果进阶一下，相等孩子只能拿同样数量的糖，那其实还是上面的过程，只不过是i和i-1一样大的话，就维持，就是left[i]=left[i-1]或者right[i]=right[i+1]，进阶的其实类似下图的感觉。

![image-20230106104257770](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106104257770-16729729788635.png)		这个题的难点就是不用数组。遍历数组的目的其实是找坡，如果不使用辅助数组，很考验coding的。然后这个代码其实救过了吧，O(1)的方法，辅助数组就行。

```
	public static int candy1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int index = nextMinIndex1(arr, 0);
		int res = rightCands(arr, 0, index++);
		int lbase = 1;
		int next = 0;
		int rcands = 0;
		int rbase = 0;
		while (index != arr.length) {
			if (arr[index] > arr[index - 1]) {
				res += ++lbase;
				index++;
			} else if (arr[index] < arr[index - 1]) {
				next = nextMinIndex1(arr, index - 1);
				rcands = rightCands(arr, index - 1, next++);
				rbase = next - index + 1;
				res += rcands + (rbase > lbase ? -lbase : -rbase);
				lbase = 1;
				index = next;
			} else {
				res += 1;
				lbase = 1;
				index++;
			}
		}
		return res;
	}

	public static int nextMinIndex1(int[] arr, int start) {
		for (int i = start; i != arr.length - 1; i++) {
			if (arr[i] <= arr[i + 1]) {
				return i;
			}
		}
		return arr.length - 1;
	}

	public static int rightCands(int[] arr, int left, int right) {
		int n = right - left + 1;
		return n + n * (n - 1) / 2;
	}

	public static int candy2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int index = nextMinIndex2(arr, 0);
		int[] data = rightCandsAndBase(arr, 0, index++);
		int res = data[0];
		int lbase = 1;
		int same = 1;
		int next = 0;
		while (index != arr.length) {
			if (arr[index] > arr[index - 1]) {
				res += ++lbase;
				same = 1;
				index++;
			} else if (arr[index] < arr[index - 1]) {
				next = nextMinIndex2(arr, index - 1);
				data = rightCandsAndBase(arr, index - 1, next++);
				if (data[1] <= lbase) {
					res += data[0] - data[1];
				} else {
					res += -lbase * same + data[0] - data[1] + data[1] * same;
				}
				index = next;
				lbase = 1;
				same = 1;
			} else {
				res += lbase;
				same++;
				index++;
			}
		}
		return res;
	}

	public static int nextMinIndex2(int[] arr, int start) {
		for (int i = start; i != arr.length - 1; i++) {
			if (arr[i] < arr[i + 1]) {
				return i;
			}
		}
		return arr.length - 1;
	}

	public static int[] rightCandsAndBase(int[] arr, int left, int right) {
		int base = 1;
		int cands = 1;
		for (int i = right - 1; i >= left; i--) {
			if (arr[i] == arr[i + 1]) {
				cands += base;
			} else {
				cands += ++base;
			}
		}
		return new int[] { cands, base };
	}
```



## 题目三 至少需要相机

![image-20230106104910696](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20230106104910696-16729733515966.png)

这个是第2节的题。相机问题直播那年考了4会了，能得到O(n),这个题很有用，适合二叉树的递归套路，就算不用贪心，也能O(n)解掉。

​	这个比较麻烦的是能影响到父环境。这个问题，不能去那么想：以x为头的树都被覆盖了需要几个相机，这样会错失最优解，而是应该想以x节点为头的时候，有几种状态，1）x是相机，2）x没相机，但是被覆盖了，3）x没被覆盖。那么有三个答案：1）x是相机，下面都被覆盖有a个相机；2）x不放相机但被coverd，下面都被覆盖需要b个相机；3）x不能覆盖，需要c个相机。

​	minCameraCover1虽然把所有的可能性都列完了，但是他的复杂度还是O(n)minCameraCover2是最优解，他基于了一种假设，就是不贪心的解minCameraCover1是三种答案都要，都返回了，而最优解的话假设明确父亲只要一种答案的解。

​	树形dp可以用二叉树的递归套路讲。

```
	public static class Node {
		public int value;
		public Node left;
		public Node right;
	}

	public static int minCameraCover1(Node root) {
		Info data = process1(root);
		return (int) Math.min(data.uncovered + 1,
				Math.min(data.coveredNoCamera, data.coveredHasCamera));
	}

	// 潜台词：x是头节点，x下方的点都被覆盖的情况下
	public static class Info {
		public long uncovered; // x没有被覆盖，x为头的树至少需要几个相机
		public long coveredNoCamera; // x被相机覆盖，但是x没相机，x为头的树至少需要几个相机
		public long coveredHasCamera; // x被相机覆盖了，并且x上放了相机，x为头的树至少需要几个相机

		public Info(long un, long no, long has) {
			uncovered = un;
			coveredNoCamera = no;
			coveredHasCamera = has;
		}
	}

	// 所有可能性都穷尽了
	public static Info process1(Node X) {	
		if (X == null) { // base case
			return new Info(Integer.MAX_VALUE, 0, Integer.MAX_VALUE);
		}
		
		
		Info left = process1(X.left);
		Info right = process1(X.right);
		// x  uncovered  x自己不被覆盖，x下方所有节点，都被覆盖
		//  左孩子： 左孩子没被覆盖，左孩子以下的点都被覆盖
		//          左孩子被覆盖但没相机，左孩子以下的点都被覆盖
		//          左孩子被覆盖也有相机，左孩子以下的点都被覆盖
		long uncovered = left.coveredNoCamera + right.coveredNoCamera;
		
		
		
		// x下方的点都被covered，x也被cover，但x上没相机
		long coveredNoCamera = Math.min(
				// 1)
				left.coveredHasCamera + right.coveredHasCamera,
				
				Math.min(
						// 2) 
						left.coveredHasCamera + right.coveredNoCamera,
						
						// 3)
						left.coveredNoCamera + right.coveredHasCamera)
				);
		
		
		// x下方的点都被covered，x也被cover，且x上有相机
		long coveredHasCamera = Math.min(
				
				left.uncovered, 
				Math.min(
						left.coveredNoCamera, 
						left.coveredHasCamera)
				)
				
				
				+
				Math.min(
						right.uncovered, 
						Math.min(
								right.coveredNoCamera, 
								right.coveredHasCamera))
				
				
				+ 1;
		
		
		return new Info(uncovered, coveredNoCamera, coveredHasCamera);
	}

	public static int minCameraCover2(Node root) {
		Data data = process2(root);
		return data.cameras + (data.status == Status.UNCOVERED ? 1 : 0);
	}

	// 以x为头，x下方的节点都是被covered，x自己的状况，分三种
	public static enum Status {
		UNCOVERED, COVERED_NO_CAMERA, COVERED_HAS_CAMERA
	}

	// 以x为头，x下方的节点都是被covered，得到的最优解中：
	// x是什么状态，在这种状态下，需要至少几个相机
	public static class Data {
		public Status status;
		public int cameras;

		public Data(Status status, int cameras) {
			this.status = status;
			this.cameras = cameras;
		}
	}

	public static Data process2(Node X) {
		if (X == null) {//空节点默认被覆盖。
			return new Data(Status.COVERED_NO_CAMERA, 0);
		}
		Data left = process2(X.left);
		Data right = process2(X.right);
		int cameras = left.cameras + right.cameras;
		if (left.status == Status.UNCOVERED || right.status == Status.UNCOVERED) {
			return new Data(Status.COVERED_HAS_CAMERA, cameras + 1);
		}
		
		
		// 左右孩子，不存在没被覆盖的情况
		if (left.status == Status.COVERED_HAS_CAMERA 
				|| 
				right.status == Status.COVERED_HAS_CAMERA) {
			return new Data(Status.COVERED_NO_CAMERA, cameras);
		}
		// 左右孩子，不存在没被覆盖的情况，也都没有相机
		return new Data(Status.UNCOVERED, cameras);
	}
```

