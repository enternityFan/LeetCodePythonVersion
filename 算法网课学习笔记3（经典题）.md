

# 1.覆盖问题



给定一系列x轴的点坐标，例如 1，3，7，8，9，11这些坐标升序放在数组中，
现在给一根绳子，长度为4，问绳子最多能覆盖的点数有多少，
例如绳子放前面只能覆盖两个点，1,3，如果放后面能覆盖4个点。



求解方法：1.二分法（N*logN),2.滑动窗口法(N)



# 2.括号有效配对问题

![image-20221116191818810](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116191818810-16685975003191.png)

对于问题1，可以用栈，但是没必要，只用一个变量cnt就行，遇到左括号就让cnt++，遇到右括号，就让cnt--，然后有两个原则：1）若过程中cnt<0那就直接返回false,2)遍历结束后看cnt是否等于0，若不是的话返回false.

对于问题2，用两个变量，一个cnt,一个need，当左括号就cnt++,右括号就cnt--,如果cnt==-1的话，那就说明右括号比左括号多1个，那就need++,然后从新把cnt恢复为0，最后返回cnt+next



# 3.最长的括号有效子串的长度（力扣32题）



![image-20221116192835645](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116192835645-16685981169632.png)假如子串必须以i位置的字符结尾，它最长的有效括号子串多长，那么以0,1,2,...n-1结尾都有一个答案，那么最终答案就是上面的n个答案种最大的。

​	dp就是构造辅助数组，看在求解i位置的答案时，是否i-1位置的答案有没有帮助。如果i位置是左括号，那么dp[i]=0,因为不会以左括号结尾，同时dp[0]==0。



# 3.2有效括号最大嵌套层数



很简单，遇到左括号cnt++,右括号cnt---,cnt到达的最大值，就是嵌套的最大层数

# 4.红和绿（爱奇艺笔试）





![image-20221116195859801](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116195859801-16685999407953.png)

枚举分界线。

**可以利用预处理数组的技巧来做**，准备一个辅助数字L，记录0到i位置上有几个G，再准备一个辅助数组R，记录从i到n-1的位置有几个R，然后直接在L，R数组中拿值就可以知道分界线的最好位置。



# 5.边框全为1的最大正方形

![image-20221116201513049](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116201513049-16686009154274.png)

力扣\1139. 最大的以 1 为边界的正方形



​	对于一个NxN的矩形，其中长方形的数量是O(N^ 4),正方形的数量是O（N^ 3)   ,正方形这个就是，左上角点的选取概率是O(N^ 2),那么右下角的点是O(N),N是边长，为了维持正方形嘛，但是长方形的话右下角也是N^ 2 的选择的概率。

​	对于这个大流程，就是三个for循环，for row, for col, for边长，来找正方形。如果不优化的话，里面还有一个for是看边长上的点是否为1，那么这就是一个4阶的，但是这个最里面的for是可以从O（N）优化为O（1）的。

​	**可以用预处理数组来做**，r[i] [j]是(i,j)右边有多少个连续的1，d[i] [j]是(i,j)下面有多少个连续的 1.





# 6.构造数据

力扣\1968. 构造元素不等于两相邻元素平均值的数组有点类似，但很不一样的还是。

![image-20221116204839164](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116204839164-16686029207435.png)

如果有a+c !=2*b,那么可以把a,b,c转换为对应的奇数，即(2*a-1)+(2*c-1) !=2*(2*b-1),同样的也可以给替换为偶数，也是会满足这个公式的。那么如果长度为M，只需要长度为如果M是偶数，需要M//2,否则是(M+1)//2,通过分治法来实现。

​	这个题有点黑。



# 7.二叉树三种最大路径和 



剑指 Offer II 050. 向下的路径节点之和是2）的情况

![image-20221116210451900](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116210451900-16686038942956.png)

对于2,3题就是两种情况，1）与x有关，2）与x无关。x就是当前路径。前者有4中情况：1）x自己，2）x左边，3）x右边，4）x左右



# 8.有序矩阵找值

面试题 10.09. 排序矩阵查找是这个题；然后这个题没讲，不过看源码还挺简单的。从右上角或者左下角走都可以找到最好的答案。





# 9.机器打包问题

这个题硬记，是个很诡异的贪心，我就先跳过这个题吧。



# 10.左右子数组的最大差值

给定一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。



思路流程：**求数组中的最大值，然后减去0位置和i-1位置较小的那个一数。**；因为不管全局的max被分配到左部分还是右部分，最后的结果都是max减去左部分或者右部分的最大值。而右部分或者左部分一定或囊括0或者n-1位置





        //当最大值包含在左侧时，需要找到右侧相对较小的最大值，而右侧一定会包含arr[arr.length - 1]
        // 当右侧最后一个数为右侧最大值时，右侧怎么变化，左右两侧最大值差值也是 max - arr[arr.length - 1]
        // 当右侧最后一个数不是右侧最大值时，那么左右两个的最大差值会变小，是不会取到的
        // 同理，最大值包含在右侧，只需要找左侧相对较小的最大值，而arr[0]是一定包含的



# 11.装水问题

\42. 接雨水



![image-20221118085127928](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221118085127928-16687326891081.png)

解题思路：求第i位置上面有多少个水，为了知道i位置上面有多少个水，需要知道i位置的左侧和右侧的最大值，然后得到这两个值的最小值，再减去i位置的高度，就是这个位置能装的水。
$$
max(min(左max,右max),0)
$$
​	可以首先使用预处理数组，来把问题从N ** 2 优化到N，**当然这不是最优的。。最优的都不需要这玩意**





# 12.二维接雨水

\407. 接雨水 II

​	解题思路，首先做一个对象，存放num,row,col，表示这个num是row,col位置的数，然后做一个小根堆，把外围的数据给放到小根堆里面，然后用一个flag[ rows ][ cols \]大小标记数组，如果i,j位置的数进入了小根堆，那么就标记为True.

1. 把边沿每个数放入heap
2. heap中弹出堆顶
3. max - num > 0，那么把水量加到一个water的变量上，如果<0就不累加，然后把num所在的上下左右放到小根堆里面。（注意要查询flag,如果上下左右哪个进过小根堆了，就不要进）
4. 然后看看num是否更新max。