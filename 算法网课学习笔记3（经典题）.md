

# 1.覆盖问题



给定一系列x轴的点坐标，例如 1，3，7，8，9，11这些坐标升序放在数组中，
现在给一根绳子，长度为4，问绳子最多能覆盖的点数有多少，
例如绳子放前面只能覆盖两个点，1,3，如果放后面能覆盖4个点。



求解方法：1.二分法（N*logN),2.滑动窗口法(N)



# 2.括号有效配对问题

![image-20221116191818810](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116191818810-16685975003191.png)

对于问题1，可以用栈，但是没必要，只用一个变量cnt就行，遇到左括号就让cnt++，遇到右括号，就让cnt--，然后有两个原则：1）若过程中cnt<0那就直接返回false,2)遍历结束后看cnt是否等于0，若不是的话返回false.

对于问题2，用两个变量，一个cnt,一个need，当左括号就cnt++,右括号就cnt--,如果cnt==-1的话，那就说明右括号比左括号多1个，那就need++,然后从新把cnt恢复为0，最后返回cnt+next



# 3.最长的括号有效子串的长度（力扣32题）



![image-20221116192835645](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116192835645-16685981169632.png)假如子串必须以i位置的字符结尾，它最长的有效括号子串多长，那么以0,1,2,...n-1结尾都有一个答案，那么最终答案就是上面的n个答案种最大的。

​	dp就是构造辅助数组，看在求解i位置的答案时，是否i-1位置的答案有没有帮助。如果i位置是左括号，那么dp[i]=0,因为不会以左括号结尾，同时dp[0]==0。



# 3.2有效括号最大嵌套层数



很简单，遇到左括号cnt++,右括号cnt---,cnt到达的最大值，就是嵌套的最大层数

# 4.红和绿（爱奇艺笔试）





![image-20221116195859801](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116195859801-16685999407953.png)

枚举分界线。

**可以利用预处理数组的技巧来做**，准备一个辅助数字L，记录0到i位置上有几个G，再准备一个辅助数组R，记录从i到n-1的位置有几个R，然后直接在L，R数组中拿值就可以知道分界线的最好位置。



# 5.边框全为1的最大正方形

![image-20221116201513049](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116201513049-16686009154274.png)

力扣\1139. 最大的以 1 为边界的正方形



​	对于一个NxN的矩形，其中长方形的数量是O(N^ 4),正方形的数量是O（N^ 3)   ,正方形这个就是，左上角点的选取概率是O(N^ 2),那么右下角的点是O(N),N是边长，为了维持正方形嘛，但是长方形的话右下角也是N^ 2 的选择的概率。

​	对于这个大流程，就是三个for循环，for row, for col, for边长，来找正方形。如果不优化的话，里面还有一个for是看边长上的点是否为1，那么这就是一个4阶的，但是这个最里面的for是可以从O（N）优化为O（1）的。

​	**可以用预处理数组来做**，r[i] [j]是(i,j)右边有多少个连续的1，d[i] [j]是(i,j)下面有多少个连续的 1.





# 6.构造数据

力扣\1968. 构造元素不等于两相邻元素平均值的数组有点类似，但很不一样的还是。

![image-20221116204839164](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116204839164-16686029207435.png)

如果有a+c !=2*b,那么可以把a,b,c转换为对应的奇数，即(2*a-1)+(2*c-1) !=2*(2*b-1),同样的也可以给替换为偶数，也是会满足这个公式的。那么如果长度为M，只需要长度为如果M是偶数，需要M//2,否则是(M+1)//2,通过分治法来实现。

​	这个题有点黑。



# 7.二叉树三种最大路径和 



剑指 Offer II 050. 向下的路径节点之和是2）的情况

![image-20221116210451900](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116210451900-16686038942956.png)

对于2,3题就是两种情况，1）与x有关，2）与x无关。x就是当前路径。前者有4中情况：1）x自己，2）x左边，3）x右边，4）x左右



# 8.有序矩阵找值

面试题 10.09. 排序矩阵查找是这个题；然后这个题没讲，不过看源码还挺简单的。从右上角或者左下角走都可以找到最好的答案。





# 9.机器打包问题

这个题硬记，是个很诡异的贪心，我就先跳过这个题吧。



# 10.左右子数组的最大差值

给定一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。



思路流程：**求数组中的最大值，然后减去0位置和i-1位置较小的那个一数。**；因为不管全局的max被分配到左部分还是右部分，最后的结果都是max减去左部分或者右部分的最大值。而右部分或者左部分一定或囊括0或者n-1位置





        //当最大值包含在左侧时，需要找到右侧相对较小的最大值，而右侧一定会包含arr[arr.length - 1]
        // 当右侧最后一个数为右侧最大值时，右侧怎么变化，左右两侧最大值差值也是 max - arr[arr.length - 1]
        // 当右侧最后一个数不是右侧最大值时，那么左右两个的最大差值会变小，是不会取到的
        // 同理，最大值包含在右侧，只需要找左侧相对较小的最大值，而arr[0]是一定包含的



# 11.装水问题

\42. 接雨水



![image-20221118085127928](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221118085127928-16687326891081.png)

解题思路：求第i位置上面有多少个水，为了知道i位置上面有多少个水，需要知道i位置的左侧和右侧的最大值，然后得到这两个值的最小值，再减去i位置的高度，就是这个位置能装的水。
$$
max(min(左max,右max),0)
$$
​	可以首先使用预处理数组，来把问题从N ** 2 优化到N，**当然这不是最优的。。最优的都不需要这玩意**





# 12.二维接雨水

\407. 接雨水 II

​	解题思路，首先做一个对象，存放num,row,col，表示这个num是row,col位置的数，然后做一个小根堆，把外围的数据给放到小根堆里面，然后用一个flag[ rows ][ cols \]大小标记数组，如果i,j位置的数进入了小根堆，那么就标记为True.

1. 把边沿每个数放入heap
2. heap中弹出堆顶
3. max - num > 0，那么把水量加到一个water的变量上，如果<0就不累加，然后把num所在的上下左右放到小根堆里面。（注意要查询flag,如果上下左右哪个进过小根堆了，就不要进）
4. 然后看看num是否更新max。





# 第四节6、搜索二叉树转换为有序的双向链表

剑指 Offer 36. 二叉搜索树与双向链表





# 第四节7、子矩阵的最大累加和

给定一个整形矩阵，返回子矩阵的最大累加和

力扣面试题 17.24. 最大子矩阵  类似

# 第五节2、编辑距离问题

力扣72. 编辑距离





# 第六节1、最大子数组异或和问题

一个数组的异或和是指数组中所有的数异或在一起的结果给定一个数组arr，求最大子数组异或和。







# 20221215 25经典面试九

## 题目四有序数组累加和前K个

![image-20221215115542539](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215115542539-16710765443911.png)

复杂度：O（n*logk)，利用大根堆实现的一个题。

```java
package class06;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class Code04_TopKSumCrossTwoArrays {

	// 放入大根堆中的结构
	public static class Node {
		public int index1;// arr1中的位置
		public int index2;// arr2中的位置
		public int sum;// arr1[index1] + arr2[index2]的值

		public Node(int i1, int i2, int s) {
			index1 = i1;
			index2 = i2;
			sum = s;
		}
	}

	// 生成大根堆的比较器
	public static class MaxHeapComp implements Comparator<Node> {
		@Override
		public int compare(Node o1, Node o2) {
			return o2.sum - o1.sum;
		}
	}

	public static int[] topKSum(int[] arr1, int[] arr2, int topK) {
		if (arr1 == null || arr2 == null || topK < 1) {
			return null;
		}
		// arr1 50  arr2 20   1000   topk 100万
		topK = Math.min(topK, arr1.length * arr2.length);

		int[] res = new int[topK];
		int resIndex = 0;

		PriorityQueue<Node> maxHeap = new PriorityQueue<>(new MaxHeapComp());

		// set[i][j] == false, arr1[i]  arr2[j] 之前，没进过
		// set[i][j] == true;  arr1[i]  arr2[j] 之前，进过
		boolean[][] set = new boolean[arr1.length][arr2.length];
		int i1 = arr1.length - 1;
		int i2 = arr2.length - 1;
		maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
		set[i1][i2] = true;
		while (resIndex != topK) {
			Node curNode = maxHeap.poll();
			res[resIndex++] = curNode.sum;
			i1 = curNode.index1;
			i2 = curNode.index2;
			if (i1 - 1 >= 0 && !set[i1 - 1][i2]) {
				set[i1 - 1][i2] = true;
				maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
			}
			if (i2 - 1 >= 0 && !set[i1][i2 - 1]) {
				set[i1][i2 - 1] = true;
				maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
			}
		}
		return res;
	}

	// For test, this method is inefficient but absolutely right
	public static int[] topKSumTest(int[] arr1, int[] arr2, int topK) {
		int[] all = new int[arr1.length * arr2.length];
		int index = 0;
		for (int i = 0; i != arr1.length; i++) {
			for (int j = 0; j != arr2.length; j++) {
				all[index++] = arr1[i] + arr2[j];
			}
		}
		Arrays.sort(all);
		int[] res = new int[Math.min(topK, all.length)];
		index = all.length - 1;
		for (int i = 0; i != res.length; i++) {
			res[i] = all[index--];
		}
		return res;
	}

	public static int[] generateRandomSortArray(int len) {
		int[] res = new int[len];
		for (int i = 0; i != res.length; i++) {
			res[i] = (int) (Math.random() * 50000) + 1;
		}
		Arrays.sort(res);
		return res;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static boolean isEqual(int[] arr1, int[] arr2) {
		if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i != arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		int a1Len = 5000;
		int a2Len = 4000;
		int k = 20000000;
		int[] arr1 = generateRandomSortArray(a1Len);
		int[] arr2 = generateRandomSortArray(a2Len);
		long start = System.currentTimeMillis();
		int[] res = topKSum(arr1, arr2, k);
		long end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		start = System.currentTimeMillis();
		int[] absolutelyRight = topKSumTest(arr1, arr2, k);
		end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		System.out.println(isEqual(res, absolutelyRight));

	}

}

```

## 题目五切分n分累加和相等

![image-20221215125450443](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215125450443-16710800912862.png)

算法复杂度：O(n)

这个题听讲解感觉还是很简单的重要的是思路，和敢式。

做一个map去记录位置i的前缀和，然后枚举第一刀，然后得到结果。

```

	public static boolean canSplits2(int[] arr) {
		if (arr == null || arr.length < 7) {
			return false;
		}
		// key 某一个累加和， value出现的位置
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		int sum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			map.put(sum, i);
			sum += arr[i];
		}
		int lsum = arr[0]; // 第一刀左侧的累加和
		for (int s1 = 1; s1 < arr.length - 5; s1++) { // s1是第一刀的位置
			int checkSum = lsum * 2 + arr[s1]; // 100 x 100   100*2 + x
			if (map.containsKey(checkSum)) {
				int s2 = map.get(checkSum); // j -> y
				checkSum += lsum + arr[s2];
				if (map.containsKey(checkSum)) { // 100 * 3 + x + y
					int s3 = map.get(checkSum); // k -> z
					if (checkSum + arr[s3] + lsum == sum) {
						return true;
					}
				}
			}
			lsum += arr[s1];
		}
		return false;
	}



```



## 题目六 交错组成



![image-20221215130305530](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215130305530-16710805866803.png)

这是一个动态规划的题，每个格子只依赖于其左侧和上侧的格子，并且需要用$str3[i][j]$进行判断

```
	public static boolean isCross1(String s1, String s2, String ai) {
		if (s1 == null || s2 == null || ai == null) {
			return false;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		char[] aim = ai.toCharArray();
		if (aim.length != str1.length + str2.length) {
			return false;
		}
		boolean[][] dp = new boolean[str1.length + 1][str2.length + 1];
		dp[0][0] = true;
		for (int i = 1; i <= str1.length; i++) {
			if (str1[i - 1] != aim[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		for (int j = 1; j <= str2.length; j++) {
			if (str2[j - 1] != aim[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i <= str1.length; i++) {
			for (int j = 1; j <= str2.length; j++) {
				
				if (
						
						(str1[i - 1] == aim[i + j - 1] && dp[i - 1][j])
						
						|| 
						
						(str2[j - 1] == aim[i + j - 1] && dp[i][j - 1])
						
						
				) {
					
					
					dp[i][j] = true;
					
					
				}
				
				
				
			}
		}
		return dp[str1.length][str2.length];
	}

	public static boolean isCross2(String str1, String str2, String aim) {
		if (str1 == null || str2 == null || aim == null) {
			return false;
		}
		char[] ch1 = str1.toCharArray();
		char[] ch2 = str2.toCharArray();
		char[] chaim = aim.toCharArray();
		if (chaim.length != ch1.length + ch2.length) {
			return false;
		}
		char[] longs = ch1.length >= ch2.length ? ch1 : ch2;
		char[] shorts = ch1.length < ch2.length ? ch1 : ch2;
		boolean[] dp = new boolean[shorts.length + 1];
		dp[0] = true;
		for (int i = 1; i <= shorts.length; i++) {
			if (shorts[i - 1] != chaim[i - 1]) {
				break;
			}
			dp[i] = true;
		}
		for (int i = 1; i <= longs.length; i++) {
			dp[0] = dp[0] && longs[i - 1] == chaim[i - 1];
			for (int j = 1; j <= shorts.length; j++) {
				if ((longs[i - 1] == chaim[i + j - 1] && dp[j]) || (shorts[j - 1] == chaim[i + j - 1] && dp[j - 1])) {
					dp[j] = true;
				} else {
					dp[j] = false;
				}
			}
		}
		return dp[shorts.length];
	}
```

## 题目一最短排序子数组长度

第七节

![image-20221215134838698](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215134838698-16710833198774.png)

时间复杂度O(n),空间复杂度O(1)

```
	public static int getMinLength(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int min = arr[arr.length - 1];
		int noMinIndex = -1;
		for (int i = arr.length - 2; i != -1; i--) {
			if (arr[i] > min) {
				noMinIndex = i;
			} else {
				min = Math.min(min, arr[i]);
			}
		}
		if (noMinIndex == -1) {
			return 0;
		}
		int max = arr[0];
		int noMaxIndex = -1;
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] < max) {
				noMaxIndex = i;
			} else {
				max = Math.max(max, arr[i]);
			}
		}
		return noMaxIndex - noMinIndex + 1;
	}
```

## 题目二最小不可组成和

![image-20221215135541289](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215135541289-16710837424095.png)

这个题的基础解法是，用背包问题的方法去做；然后进阶的解法是，如果arr一定有1，那么就可以做到O(nlogn)的时间复杂度。方法是首先排序，然后一定知道第一个数是1，可以准备一个range=1,表示从1-到range所有的数都可以加出来，对于arr[i]=a,有两种情况：1)a > range + 1,和2) a <=range+1,对于第二种情况，那么可以更新range = range + a;对于第一种情况，直接返回range+1就是结果。如果都没有遇到1）的情况，那就直接返回range+1就是结果。



下面代码中，前两个是背包的方法，第三个是进阶的方法。

```
public static int unformedSum1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		HashSet<Integer> set = new HashSet<Integer>();
		process(arr, 0, 0, set);
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			min = Math.min(min, arr[i]);
		}
		for (int i = min + 1; i != Integer.MIN_VALUE; i++) {
			if (!set.contains(i)) {
				return i;
			}
		}
		return 0;
	}

	public static void process(int[] arr, int i, int sum, HashSet<Integer> set) {
		if (i == arr.length) {
			set.add(sum);
			return;
		}
		process(arr, i + 1, sum, set);
		process(arr, i + 1, sum + arr[i], set);
	}

	public static int unformedSum2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		int sum = 0;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			sum += arr[i];
			min = Math.min(min, arr[i]);
		}
		// boolean[][] dp ...
		int N = arr.length;
		boolean[][] dp = new boolean[N][sum + 1];
		for (int i = 0; i < N; i++) {// arr[0..i] 0
			dp[i][0] = true;
		}
		dp[0][arr[0]] = true;
		for (int i = 1; i < N; i++) {
			for (int j = 1; j <= sum; j++) {
				dp[i][j] = dp[i - 1][j] || ((j - arr[i] >= 0) ? dp[i - 1][j - arr[i]] : false);
			}
		}
		for (int j = min; j <= sum; j++) {
			if (!dp[N - 1][j]) {
				return j;
			}
		}
		return sum + 1;
	}

	// 已知arr中肯定有1这个数
	public static int unformedSum3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		Arrays.sort(arr); // O (N * logN)
		int range = 1;
		// arr[0] == 1
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] > range + 1) {
				return range + 1;
			} else {
				range += arr[i];
			}
		}
		return range + 1;
	}
```

## 题目三 arr最少缺几个数

![image-20221215140849379](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215140849379-16710845302776.png)

这个题跟二进制很有关，如果实现了1-range的目标，但是没有达到1-aim，那么缺的永远是range+1;如果补上了range+1,那么此时的范围就会变为了1~(2*range+1)

```
// arr请保证有序，且正数
	public static int minPatches(int[] arr, int aim) {
		int patches = 0; // 缺多少个数字
		long range = 0; // 已经完成了1 ~ range的目标
		Arrays.sort(arr);
		for (int i = 0; i != arr.length; i++) {
			// 1~range
			// 1 ~ arr[i]-1
			while (arr[i] - 1 > range) { // arr[i] 1 ~ arr[i]-1
				range += range + 1; // range + 1 是缺的数字
				patches++;
				if (range >= aim) {
					return patches;
				}
			}
			range += arr[i];
			if (range >= aim) {
				return patches;
			}
		}
		while (aim >= range + 1) {
			range += range + 1;
			patches++;
		}
		return patches;
	}
```

## 题目六 没有重复字符子串的最长长度

![image-20221215142012396](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215142012396-16710852136367.png)

3. 无重复字符的最长子串(力扣)

这个题是用DP做的，不过我发现我之前是用滑动窗口做的。

```
public static int maxUnique(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		// map 替代了哈希表   假设字符的码是0~255
		int[] map = new int[256];
		for (int i = 0; i < 256; i++) {
			map[i] = -1;
		}
		int len = 0;
		int pre = -1;
		int cur = 0;
		for (int i = 0; i != chas.length; i++) {
			pre = Math.max(pre, map[chas[i]]);
			cur = i - pre;
			len = Math.max(len, cur);
			map[chas[i]] = i;
		}
		return len;
	}
```



# 20221216 26经典面试十

## 题目四 数组独立域

![image-20221215210002640](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215210002640-16711092040131.png)

并查集的题。如果有n个数，某个数值为V，那么算法可以优化为O(n*v),n为遍历数组，V为计算V这个数值是否是质数。这个算法最高可以优化为$ O(n*sqrt(V)) $，就是把2-sqrt(V)都当做V的质数，如果可以整除的话。

力扣\952. 按公因数计算最大组件大小；方法一会超时。



```
public static int largestComponentSize1(int[] arr) {
		int N = arr.length;
		UnionFind set = new UnionFind(N);
		for (int i = 0; i < N; i++) {
			for (int j = i + 1; j < N; j++) {
				if (gcd(arr[i], arr[j]) != 1) {
					set.union(i, j);
				}
			}
		}
		return set.maxSize();
	}

	public static int largestComponentSize2(int[] arr) {
		int N = arr.length;
		UnionFind unionFind = new UnionFind(N);
		HashMap<Integer, Integer> fatorsMap = new HashMap<>();
		for (int i = 0; i < N; i++) {
			int num = arr[i];
			int limit = (int) Math.sqrt(num);
			for (int j = 1; j <= limit; j++) {
				if (num % j == 0) {
					if (j != 1) {
						if (!fatorsMap.containsKey(j)) {
							fatorsMap.put(j, i);
						} else {
							unionFind.union(fatorsMap.get(j), i);
						}
					}
					int other = num / j;
					if (other != 1) {
						if (!fatorsMap.containsKey(other)) {
							fatorsMap.put(other, i);
						} else {
							unionFind.union(fatorsMap.get(other), i);
						}
					}
				}
			}
		}
		return unionFind.maxSize();
	}

	public static int gcd(int m, int n) {
	//辗转相除法，求最大公约数
		return n == 0 ? m : gcd(n, m % n);
	}

	public static class UnionFind {
		private int[] parents;
		private int[] sizes;
		private int[] help;

		public UnionFind(int N) {
			parents = new int[N];
			sizes = new int[N];
			help = new int[N];
			for (int i = 0; i < N; i++) {
				parents[i] = i;
				sizes[i] = 1;
			}
		}

		public int maxSize() {
			int ans = 0;
			for (int size : sizes) {
				ans = Math.max(ans, size);
			}
			return ans;
		}

		private int find(int i) {
			int hi = 0;
			while (i != parents[i]) {
				help[hi++] = i;
				i = parents[i];
			}
			for (hi--; hi >= 0; hi--) {
				parents[help[hi]] = i;
			}
			return i;
		}

		public void union(int i, int j) {
			int f1 = find(i);
			int f2 = find(j);
			if (f1 != f2) {
				int big = sizes[f1] >= sizes[f2] ? f1 : f1;
				int small = big == f1 ? f2 : f1;
				parents[small] = big;
				sizes[big] = sizes[f1] + sizes[f2];
			}
		}
	}
```

## 题目五 删除多于字符使每种只保留一个且字典序最小

![image-20221216122914348](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216122914348-16711649558341.png)

​	**删除的方案和保留的方案其实是一回事；如果挑了i位置的字符，那么不能再在左侧再挑字符，只能从i右侧挑选，这种方式其实也不会错过答案的。**

​	首先先统计一下词频，

方法1是讲的。如果有K种字符，那么复杂度为O（KN）

```
// 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回
	public static String removeDuplicateLetters1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		int[] map = new int[256];
		for (int i = 0; i < str.length(); i++) {
			map[str.charAt(i)]++;
		}
		int minACSIndex = 0;
		for (int i = 0; i < str.length(); i++) {
			minACSIndex = str.charAt(minACSIndex) > str.charAt(i) ? i : minACSIndex;
			if (--map[str.charAt(i)] == 0) {
				break;
			}
		}
		return String.valueOf(str.charAt(minACSIndex)) + removeDuplicateLetters1(
				str.substring(minACSIndex + 1).replaceAll(String.valueOf(str.charAt(minACSIndex)), ""));
	}

	public static String removeDuplicateLetters2(String s) {
		char[] str = s.toCharArray();
		// 小写字母ascii码值范围[97~122]，所以用长度为26的数组做次数统计
		// 如果map[i] > -1，则代表ascii码值为i的字符的出现次数
		// 如果map[i] == -1，则代表ascii码值为i的字符不再考虑
		int[] map = new int[26];
		for (int i = 0; i < str.length; i++) {
			map[str[i] - 'a']++;
		}
		char[] res = new char[26];
		int index = 0;
		int L = 0;
		int R = 0;
		while (R != str.length) {
			// 如果当前字符是不再考虑的，直接跳过
			// 如果当前字符的出现次数减1之后，后面还能出现，直接跳过
			if (map[str[R] - 'a'] == -1 || --map[str[R] - 'a'] > 0) {
				R++;
			} else { // 当前字符需要考虑并且之后不会再出现了
				// 在str[L..R]上所有需要考虑的字符中，找到ascii码最小字符的位置
				int pick = -1;
				for (int i = L; i <= R; i++) {
					if (map[str[i] - 'a'] != -1 && (pick == -1 || str[i] < str[pick])) {
						pick = i;
					}
				}
				// 把ascii码最小的字符放到挑选结果中
				res[index++] = str[pick];
				// 在上一个的for循环中，str[L..R]范围上每种字符的出现次数都减少了
				// 需要把str[pick + 1..R]上每种字符的出现次数加回来
				for (int i = pick + 1; i <= R; i++) {
					if (map[str[i] - 'a'] != -1) { // 只增加以后需要考虑字符的次数
						map[str[i] - 'a']++;
					}
				}
				// 选出的ascii码最小的字符，以后不再考虑了
				map[str[pick] - 'a'] = -1;
				// 继续在str[pick + 1......]上重复这个过程
				L = pick + 1;
				R = L;
			}
		}
		return String.valueOf(res, 0, index);
	}
```



## 题目七 直线最多穿越多少点

![image-20221216124515155](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216124515155-16711659163882.png)

​	力扣\149. 直线上最多的点数



思路：遍历每个点(x0,y0)，查看必须通过这个点，最多会穿过多少个点。对于两个点p1,p2有四种关系:1)重合2）水平，p1p2点共Y；3）垂直，p1p2共X；4）p1p2有斜率.。（p1y-p2y)/(p1x-p2x)

​	对于p1点，统计:1)多少点与p1重合;2)在不重合的情况下有多少和p1共y,3)有多少不重合的情况下与p1是共x，4）是一个map，key为一个斜率，value为在这个斜率下有多少个点共现的。

复杂度是O（N^2)的。**这道题难点在于怎么表示斜率**,应该用最大公倍数的字符串的形式去表示，比如20/30，那么就用"2_3"来表示，或者用二维表进行表示，比如{1:{3:2,4:2,5:2}}就表示1/3有2个;1/4有2个，1/5有2个。

```
	public static class Point {
		public int x;
		public int y;

		Point() {
			x = 0;
			y = 0;
		}

		Point(int a, int b) {
			x = a;
			y = b;
		}
	}

	public static int maxPoints(Point[] points) {
		if (points == null) {
			return 0;
		}
		if (points.length <= 2) {
			return points.length;
		}
		// key : 分子  value : 分母表
		Map<Integer, Map<Integer, Integer>> map = new HashMap<Integer, Map<Integer, Integer>>();
		int result = 0;
		for (int i = 0; i < points.length; i++) {
			map.clear();
			int samePosition = 1;
			int sameX = 0;
			int sameY = 0;
			int line = 0;
			for (int j = i + 1; j < points.length; j++) {
				int x = points[j].x - points[i].x;
				int y = points[j].y - points[i].y;
				if (x == 0 && y == 0) {
					samePosition++;
				} else if (x == 0) {
					sameX++;
				} else if (y == 0) {
					sameY++;
				} else {
					int gcd = gcd(x, y);
					x /= gcd;
					y /= gcd;
					if (!map.containsKey(x)) {
						map.put(x, new HashMap<Integer, Integer>());
					}
					if (!map.get(x).containsKey(y)) {
						map.get(x).put(y, 0);
					}
					map.get(x).put(y, map.get(x).get(y) + 1);
					line = Math.max(line, map.get(x).get(y));
				}
			}
			result = Math.max(result, Math.max(Math.max(sameX, sameY), line) + samePosition);
		}
		return result;
	}

	// 保证初始调用的时候，a和b不等于0
	public static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
```



## 题目四通关怪兽最少花费（从这里开始第八节了）

![image-20221216131036894](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216131036894-16711674384413.png)

DP有两种思路，一种是$DP[N][M]$,M为怪兽能力，这种方法在当M很大时，可能会有问题；第二种方法为$DP[I][J]$想来到I号怪兽，要严格正好花够J元时，最大能力是多少。 所以具体来说还是第二种方法更好，==这个是腾讯的原题，当时N给的500，能力最多1e6,钱是200==





```
	// int[] d d[i]：i号怪兽的武力
	// int[] p p[i]：i号怪兽要求的钱
	// ability 当前你所具有的能力
	// index 来到了第index个怪兽的面前

	// 目前，你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，
	// 请返回需要花的最少钱数
	public static long process(int[] d, int[] p, int ability, int index) {
		if (index == d.length) {
			return 0;
		}
		if (ability < d[index]) {
			return p[index] + process(d, p, ability + d[index], index + 1);
		} else { // 可以贿赂，也可以不贿赂
			return 
					Math.min(
							p[index] + process(d, p, ability + d[index], index + 1),
						    process(d, p, ability, index + 1)
							);
		}
	}

	public static long func1(int[] d, int[] p) {
		return process(d, p, 0, 0);
	}

	public static long func2(int[] d, int[] p) {
		int sum = 0;
		for (int num : d) {
			sum += num;
		}
		long[][] dp = new long[d.length + 1][sum + 1];
		for (int i = 0; i <= sum; i++) {
			dp[0][i] = 0;
		}
		for (int cur = d.length - 1; cur >= 0; cur--) {
			for (int hp = 0; hp <= sum; hp++) {
				// 如果这种情况发生，那么这个hp必然是递归过程中不会出现的状态
				// 既然动态规划是尝试过程的优化，尝试过程碰不到的状态，不必计算
				if (hp + d[cur] > sum) {
					continue;
				}
				if (hp < d[cur]) {
					dp[cur][hp] = p[cur] + dp[cur + 1][hp + d[cur]];
				} else {
					dp[cur][hp] = Math.min(p[cur] + dp[cur + 1][hp + d[cur]], dp[cur + 1][hp]);
				}
			}
		}
		return dp[0][0];
	}

	public static long func3(int[] d, int[] p) {
		int sum = 0;
		for (int num : p) {
			sum += num;
		}
		// dp[i][j]含义：
		// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
		int[][] dp = new int[d.length][sum + 1];
		for (int i = 0; i < dp.length; i++) {
			for (int j = 0; j <= sum; j++) {
				dp[i][j] = -1;
			}
		}
		// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
		dp[0][p[0]] = d[0];
		for (int i = 1; i < d.length; i++) {
			for (int j = 0; j <= sum; j++) {
				// 可能性一，为当前怪兽花钱
				// 存在条件：
				// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
				if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
					dp[i][j] = dp[i - 1][j - p[i]] + d[i];
				}
				// 可能性二，不为当前怪兽花钱
				// 存在条件：
				// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
				if (dp[i - 1][j] >= d[i]) {
					// 两种可能性中，选武力值最大的
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
				}
			}
		}
		int ans = 0;
		// dp表最后一行上，dp[N-1][j]代表：
		// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
		for (int j = 0; j <= sum; j++) {
			if (dp[d.length - 1][j] != -1) {
				ans = j;
				break;
			}
		}
		return ans;
	}
```

## 题目六 最少添加使回文

![image-20221216133712272](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216133712272-16711690340834.png)

这个题是可以在字符串任意位置添加的！

```
	public static String getPalindrome1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = getDP(chas);
		char[] res = new char[chas.length + dp[0][chas.length - 1]];
		int i = 0;
		int j = chas.length - 1;
		int resl = 0;
		int resr = res.length - 1;
		while (i <= j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) {
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else {
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}

	public static int[][] getDP(char[] str) {
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) {
					dp[i][j] = dp[i + 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		return dp;
	}

```

拓展：不仅要告诉有多少种，还要告诉变成怎样的回文串。就是反推吧，反正听着也挺有启发的。



# 20221216 27经典面试十一

## 题目一 信息接受打印结构

![image-20221216183247668](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216183247668-16711867685785.png)

主要是利用单链表+哈希表实现的。在直播的场景中总常用的



```
public static class Node {
		public String info;
		public Node next;

		public Node(String str) {
			info = str;
		}
	}

	public static class MessageBox {
		private HashMap<Integer, Node> headMap;
		private HashMap<Integer, Node> tailMap;
		private int waitPoint;

		public MessageBox() {
			headMap = new HashMap<Integer, Node>();
			tailMap = new HashMap<Integer, Node>();
			waitPoint = 1;
		}

		// 消息的编号，info消息的内容, 消息一定从1开始
		public void receive(int num, String info) {
			if (num < 1) {
				return;
			}
			Node cur = new Node(info);
			// num~num
			headMap.put(num, cur);
			tailMap.put(num, cur);
			// 建立了num~num这个连续区间的头和尾
			// 查询有没有某个连续区间以num-1结尾
			if (tailMap.containsKey(num - 1)) {
				tailMap.get(num - 1).next = cur;
				tailMap.remove(num - 1);
				headMap.remove(num);
			}
			// 查询有没有某个连续区间以num+1开头的
			if (headMap.containsKey(num + 1)) {
				cur.next = headMap.get(num + 1);
				tailMap.remove(num);
				headMap.remove(num + 1);
			}
			if (num == waitPoint) {
				print();
			}
		}

		private void print() {
			Node node = headMap.get(waitPoint);
			headMap.remove(waitPoint);
			while (node != null) {
				System.out.print(node.info + " ");
				node = node.next;
				waitPoint++;
			}
			tailMap.remove(waitPoint-1);
			System.out.println();
		}

	}

	public static void main(String[] args) {
		// MessageBox only receive 1~N
		MessageBox box = new MessageBox();

		box.receive(2,"B"); // - 2"
		box.receive(1,"A"); // 1 2 -> print, trigger is 1

		box.receive(4,"D"); // - 4
		box.receive(5,"E"); // - 4 5
		box.receive(7,"G"); // - 4 5 - 7
		box.receive(8,"H"); // - 4 5 - 7 8
		box.receive(6,"F"); // - 4 5 6 7 8
		box.receive(3,"C"); // 3 4 5 6 7 8 -> print, trigger is 3

		box.receive(9,"I"); // 9 -> print, trigger is 9

		box.receive(10,"J"); // 10 -> print, trigger is 10

		box.receive(12,"L"); // - 12
		box.receive(13,"M"); // - 12 13
		box.receive(11,"K"); // 11 12 13 -> print, trigger is 11

	}
```



## 题目二 纪念币与普通币的拼法

![image-20221223084931073](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223084931073-16717565722751.png)

这个题是DP的题，介绍了一种优化有枚举行为的方法，挺有意思的。



 对于普通币，是有枚举的优化，对于纪念币，就是背包问题。

这个题看着很难，但是其实就是中等难度的题。。。笔试原题。



```
public static int moneyWays(int[] arbitrary, int[] onlyone, int money) {
		if (money < 0) {
			return 0;
		}
		if ((arbitrary == null || arbitrary.length == 0) && (onlyone == null || onlyone.length == 0)) {
			return money == 0 ? 1 : 0;
		}
		// 任意张 的数组， 一张的数组，不可能都没有
		int[][] dparb = getDpArb(arbitrary, money);
		int[][] dpone = getDpOne(onlyone, money);
		if (dparb == null) { // 任意张的数组没有，一张的数组有
			return dpone[dpone.length - 1][money];
		}
		if (dpone == null) { // 任意张的数组有，一张的数组没有
			return dparb[dparb.length - 1][money];
		}
		int res = 0;
		for (int i = 0; i <= money; i++) {
			res += dparb[dparb.length - 1][i] * dpone[dpone.length - 1][money - i];
		}
		return res;
	}

	public static int[][] getDpArb(int[] arr, int money) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int[][] dp = new int[arr.length][money + 1];
		// dp[i][j] 0..i券 自由选择张数， 搞定j元， 有多少方法？

		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		// [0] 5元 0元 5元 10元 15元 20元
		for (int j = 1; arr[0] * j <= money; j++) {
			dp[0][arr[0] * j] = 1;
		}
		// 0行 0列 填完了
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= money; j++) {
				dp[i][j] = dp[i - 1][j];
				dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;
			}
		}
		return dp;
	}

	public static int[][] getDpOne(int[] arr, int money) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int[][] dp = new int[arr.length][money + 1];
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		if (arr[0] <= money) {
			dp[0][arr[0]] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= money; j++) {
				dp[i][j] = dp[i - 1][j];
				dp[i][j] += j - arr[i] >= 0 ? dp[i - 1][j - arr[i]] : 0;
			}
		}
		return dp;
	}
```

## 题目三 在写下1-N所有数字时写下了多少1

力扣 233. 数字 1 的个数



**![image-20221223085002395](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223085002395.png)**

这个题老师说很难。这个题不属于经典的DP问题，他是数位DP模型，他在比赛中经常出现，在面试中不总出现的。

1. 树形DP：二叉树递归套路
2. 矩乘DP斐波那数列的模型
3. 从左到右尝试模型（背包问题）
4. 范围尝试
5. 对应模型
6. 业务模型

以上6中就能满足95%的在面试中，其他5%里就是有这个数位DP模型，然后这个介绍的题是比较常见的。

```
public static int solution2(int num) {
		if (num < 1) {
			return 0;
		}
		// num -> 13625
		// len = 5位数
		int len = getLenOfNum(num);
		if (len == 1) {
			return 1;
		}
		// num 13625
		// tmp1 10000
		// num 7872328738273
		// tmp1 1000000000000
		int tmp1 = powerBaseOf10(len - 1);
		// num最高位 num / tmp1
		int first = num / tmp1;
		// 最高1 N % tmp1 + 1
		// 最高位first tmp1
		int firstOneNum = first == 1 ? num % tmp1 + 1 : tmp1;
		// 除去最高位之外，剩下1的数量
		// 最高位1 10(k-2次方) * (k-1) * 1
		// 最高位first 10(k-2次方) * (k-1) * first
		int otherOneNum = first * (len - 1) * (tmp1 / 10);
		return firstOneNum + otherOneNum + solution2(num % tmp1);
	}

	public static int getLenOfNum(int num) {
		int len = 0;
		while (num != 0) {
			len++;
			num /= 10;
		}
		return len;
	}

	public static int powerBaseOf10(int base) {
		return (int) Math.pow(10, base);
	}
```








# 20221223 28 经典面试十二

## 题目五 最大整合子数组的长度

![image-20221223102045044](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223102045044-16717620464652.png)

最优解是，首先穷举所有的子数组，然后只要满足1）子数组没有重复值，2）最大值减去最小值=子数组的长度，那么这就是一个整合子数组了。这是一个0（N^2)的难度。

==看到这个题，应该学会，如果定义写的很蛋疼，那么应该想想可以不可以优化下==



```
	public static int getLIL2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int len = 0;
		int max = 0;
		int min = 0;
		HashSet<Integer> set = new HashSet<Integer>();
		for (int L = 0; L < arr.length; L++) { // L 左边界
			// L .......
			set.clear();
			max = Integer.MIN_VALUE;
			min = Integer.MAX_VALUE;
			for (int R = L; R < arr.length; R++) { // R 右边界
				// arr[L..R]这个子数组在验证   l...R L...r+1  l...r+2  
				if (set.contains(arr[R])) {
					// arr[L..R]上开始 出现重复值了，arr[L..R往后]不需要验证了，
					// 一定不是可整合的
					break;
				}
				// arr[L..R]上无重复值
				set.add(arr[R]);
				max = Math.max(max, arr[R]);
				min = Math.min(min, arr[R]);
				if (max - min == R - L) { // L..R 是可整合的
					len = Math.max(len, R - L + 1);
				}
			}
		}
		return len;
	}
```



## 题目一 股票交易最大钱数

==第四期第二节题目==

![image-20221223112043540](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112043540-16717656443053.png)

这个就是假如i位置卖，那么在i位置之前最小的时候买就行了，很简单,最后看这些情况里最大的。



```
	public int maxProfit(int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int min = prices[0];
		int ans = 0;
		for (int i = 0; i < prices.length; i++) {
			min = Math.min(min, prices[i]);
			ans = Math.max(ans, prices[i] - min);
		}
		return ans;
	}
```

## 题目二 股票交易2

![image-20221223112409422](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112409422-16717658503214.png)

对于i位置是a，i-1位置是b，那么对于所有b>a的，(b-a)的所有值的和就是了。这其实就是个上坡的问题。

```
	public static int maxProfit(int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int ans = 0;
		for (int i = 1; i < prices.length; i++) {
            ans += Math.max(prices[i] - prices[i-1], 0);
		}
		return ans;
	}
```



## 题目三 股票交易3（这个有点难了）

这个属于DP。

![image-20221223112731502](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223112731502-16717660526695.png)



假设数组长度知道，那么交易不超过K次，如果K>N/2,那么等同于无限次交易。有一个结论，==如果数组长度为N，那么大上坡的数量不会大于N/2的==。那么对于K>N/2的情况，就可以直接用题目二，就是股票交易2的代码得到。如果K<N/2,那么做一个DP表，$dp[i][j]$表示arr[0...i]交易次数小于等于j次获得的最大钱数。第一列就肯定全是0块钱。对于$dp[i][j]$有几种情况1)第[i]次就不参与教育，那么就是直接$dp[i-1][j]$，第二种可能性，就是[i]号参与了交易，并且他肯定只是参与的最后一次交易的卖出操作，那么在第二种可能性下又有i可能性：1)$dp[i][j-1] + [i] - [i]$,2)$dp[i-1][j-1]+[i] - [i-1]$...这里是一个枚举。这是一个枚举行为，那么就可以优化。

```
	public static int dp(int K, int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int N = prices.length;
		if (K >= N / 2) {
			return allTrans(prices);
		}
		int[][] dp = new int[N][K + 1];
		int ans = 0;
		for (int j = 1; j <= K; j++) {
			int t = dp[0][j - 1] - prices[0];
			for (int i = 1; i < N; i++) {
				t = Math.max(t, dp[i][j - 1] - prices[i]);
				dp[i][j] = Math.max(dp[i - 1][j], t + prices[i]);
				ans = Math.max(ans, dp[i][j]);
			}
		}
		return ans;
	}

	public static int maxProfit(int K, int[] prices) {
		if (prices == null || prices.length == 0) {
			return 0;
		}
		int N = prices.length;
		if (K >= N / 2) {
			return allTrans(prices);
		}
		// dp一维表，做了空间压缩
		int[] dp = new int[N];
		int ans = 0;
		for (int tran = 1; tran <= K; tran++) {
			int pre = dp[0];
			int best = pre - prices[0];
			for (int index = 1; index < N; index++) {
				pre = dp[index];
				dp[index] = Math.max(dp[index - 1], prices[index] + best);
				best = Math.max(best, pre - prices[index]);
				ans = Math.max(dp[index], ans);
			}
		}
		return ans;
	}

	public static int allTrans(int[] prices) {
		int ans = 0;
		for (int i = 1; i < prices.length; i++) {
			ans += Math.max(prices[i] - prices[i - 1], 0);
		}
		return ans;
	}
```





# 20221223 29 经典面试十三

第四期第一节的题。

## 题目二 离K最近的子数组累加和

![image-20221223114902130](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223114902130-16717673433776.png)

这个是用前缀和做的。

子数组问题，往往都是以i位置结尾的答案里最好的。这个题要用有序表去做。这里因为没有单调性，所以不能用窗口的方法去做。



```
	// 请返回arr中，求个子数组的累加和，是<=K的，并且是最大的。
	// 返回这个最大的累加和
	public static int getMaxLessOrEqualK(int[] arr, int K) {
		// 记录i之前的，前缀和，按照有序表组织
		TreeSet<Integer> set = new TreeSet<Integer>();
		// 一个数也没有的时候，就已经有一个前缀和是0了
		set.add(0);

		int max = Integer.MIN_VALUE;
		int sum = 0;
		// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是<=K的，并且是最大的
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i]; // sum -> arr[0..i];
			if (set.ceiling(sum - K) != null) {
				max = Math.max(max, sum - set.ceiling(sum - K));
			}
			set.add(sum); // 当前的前缀和加入到set中去
		}
		return max;

	}
```



## 题目三 离K最近的子矩阵累加和

![image-20221223160002906](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223160002906-16717824037357.png)

这个题的解题思路讲过,

```
	public static int maxSumSubmatrix(int[][] matrix, int k) {
		if (matrix == null || matrix[0] == null)
			return 0;
		int row = matrix.length, col = matrix[0].length, res = Integer.MIN_VALUE;
		TreeSet<Integer> sumSet = new TreeSet<>();
		for (int s = 0; s < row; s++) { // s开始行
			int[] colSum = new int[col];
			for (int e = s; e < row; e++) { // e结束行
				// 子矩阵必须包含s~e行的数，且只包含s~e行的数
				sumSet.add(0);
				int rowSum = 0;
				for (int c = 0; c < col; c++) {
					colSum[c] += matrix[e][c];
					rowSum += colSum[c];
					Integer it = sumSet.ceiling(rowSum - k);
					if (it != null) {
						res = Math.max(res, rowSum - it);
					}
					sumSet.add(rowSum);
				}
				sumSet.clear();
			}
		}
		return res;
	}
```





## 题目一 最大递增链的长度

![image-20221223160620650](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223160620650-16717827829878.png)



下面的代码第一个就是递归实现的，第二个就是用傻缓存优化的,这个优化的后的时间复杂度是O(NM)。

```
public static int maxPath(int[][] matrix) {
		int ans = Integer.MIN_VALUE;
		for (int row = 0; row < matrix.length; row++) {
			for (int col = 0; col < matrix[0].length; col++) {
				ans = Math.max(ans, process(matrix, row, col));
			}
		}
		return ans;
	}

	// 假设在matrix中，从i行，j列出发，能走出的最长递增路径，返回最长递增路径的长度
	public static int process(int[][] matrix, int i, int j) {
		if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) {
			return -1;
		}
		int up = 0;
		int down = 0;
		int left = 0;
		int right = 0;
		if (i - 1 >= 0 && matrix[i - 1][j] > matrix[i][j]) {
			up = process(matrix, i - 1, j);
		}
		if (i + 1 < matrix.length && matrix[i + 1][j] > matrix[i][j]) {
			down = process(matrix, i + 1, j);
		}
		if (j - 1 >= 0 && matrix[i][j - 1] > matrix[i][j]) {
			left = process(matrix, i, j - 1);
		}
		if (j + 1 < matrix[0].length && matrix[i][j + 1] > matrix[i][j]) {
			right = process(matrix, i, j + 1);
		}
		return 1 + Math.max(Math.max(up, down), Math.max(left, right));
	}

	public static int maxPath2(int[][] matrix) {
		int ans = Integer.MIN_VALUE;

		int[][] dp = new int[matrix.length][matrix[0].length];

		for (int row = 0; row < matrix.length; row++) {
			for (int col = 0; col < matrix[0].length; col++) {
				ans = Math.max(ans, process(matrix, row, col, dp));
			}
		}
		return ans;
	}

	// 假设在matrix中，从i行，j列出发，能走出的最长递增路径，返回
	// dp[i][j] == 0 process(i,j) 之前没遇到过
	// dp[i][j] != 0 process(i,j) 之前已经算过了
	public static int process(int[][] matrix, int i, int j, int[][] dp) {
		if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) {
			return -1;
		}
		if (dp[i][j] != 0) {
			return dp[i][j];
		}
		int next1 = 0;
		int next2 = 0;
		int next3 = 0;
		int next4 = 0;
		if (i - 1 >= 0 && matrix[i - 1][j] > matrix[i][j]) {
			next1 = process(matrix, i - 1, j);
		}
		if (i + 1 < matrix.length && matrix[i + 1][j] > matrix[i][j]) {
			next2 = process(matrix, i + 1, j);
		}
		if (j - 1 >= 0 && matrix[i][j - 1] > matrix[i][j]) {
			next3 = process(matrix, i, j - 1);
		}
		if (j + 1 < matrix[0].length && matrix[i][j + 1] > matrix[i][j]) {
			next4 = process(matrix, i, j + 1);
		}
		int ans = 1 + Math.max(Math.max(next1, next2), Math.max(next3, next4));
		dp[i][j] = ans;
		return ans;
	}

	public static int longestIncreasingPath(int[][] m) {
		if (m == null || m.length == 0 || m[0].length == 0) {
			return 0;
		}
		int[][] dp = new int[m.length][m[0].length];
		// dp[i][j] (i,j)出发，走出的最长链长度
		int max = 0;
		for (int i = 0; i < m.length; i++) {
			for (int j = 0; j < m[0].length; j++) {
				// 每一个(i,j)位置出发，都尝试
				max = Math.max(max, maxIncrease(m, dp, i + 1, j, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i, j + 1, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i - 1, j, m[i][j]) + 1);
				max = Math.max(max, maxIncrease(m, dp, i, j - 1, m[i][j]) + 1);
			}

		}
		return max;
	}

	// 来到的当前位置是i,j位置
	// p 上一步值是什么
	// 从(i,j)位置出发，走出的最长链，要求：上一步是可以迈到当前步上的
	public static int maxIncrease(int[][] m, int[][] dp, int i, int j, int p) {
		if (i < 0 || i >= m.length || j < 0 || j >= m[0].length || m[i][j] <= p) {
			return 0;
		}
		if (dp[i][j] == 0) { // i,j 出发，当前没算过
			dp[i][j] = maxIncrease(m, dp, i + 1, j, m[i][j]) + 1;
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i, j + 1, m[i][j]) + 1);
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i - 1, j, m[i][j]) + 1);
			dp[i][j] = Math.max(dp[i][j], maxIncrease(m, dp, i, j - 1, m[i][j]) + 1);
		}
		return dp[i][j];
	}
```

## 题目四\212. 单词搜索 II



力扣212.单词搜索 II

这个题和题目五很重要，代表了递归的能力。

![image-20221223162104378](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223162104378-16717836658049.png)

路径不能重复走的意思就是，比如说【a  s;e  t】，那么不能走出来astst这个单词，因为回重复走。做这个题要想明白，1）怎么实现我已经走出来word了？我怎么知道？2）应该做的是深度优先遍历，就是先往一个方向走的不能再走了，再换方向，这样做的话可以实现标记，知道哪个点走过了。这两个点实现的方式就是前缀树。把words加入到前缀树，那么首先这样也可以筛选起点，一看起点就不是，那就去遍历另外一个点，这样。

这个代码写的很妙，尤其是递归的返回值再结合字典树又进行了一下加速，帅。

==这个题是故意设计出来考验那个剪枝技巧的==



```
public static class TrieNode {
		public TrieNode[] nexts;
		public int pass;
		public int end;

		public TrieNode() {
			nexts = new TrieNode[26];
			pass = 0;
			end = 0;
		}

	}

	public static void fillWord(TrieNode head, String word) {
		head.pass++;
		char[] chs = word.toCharArray();
		int index = 0;
		TrieNode node = head;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.nexts[index] == null) {
				node.nexts[index] = new TrieNode();
			}
			node = node.nexts[index];
			node.pass++;
		}
		node.end++;
	}

	public static String generatePath(LinkedList<Character> path) {
		char[] str = new char[path.size()];
		int index = 0;
		for (Character cha : path) {
			str[index++] = cha;
		}
		return String.valueOf(str);
	}

	public static List<String> findWords(char[][] board, String[] words) {
		TrieNode head = new TrieNode(); // 前缀树最顶端的头
		HashSet<String> set = new HashSet<>();
		for (String word : words) {
			if (!set.contains(word)) {
				fillWord(head, word);
				set.add(word);
			}
		}
		// 答案
		List<String> ans = new ArrayList<>();
		// 沿途走过的字符，收集起来，存在path里
		LinkedList<Character> path = new LinkedList<>();
		for (int row = 0; row < board.length; row++) {
			for (int col = 0; col < board[0].length; col++) {
				// 枚举在board中的所有位置
				// 每一个位置出发的情况下，答案都收集
				process(board, row, col, path, head, ans);
			}
		}
		return ans;
	}

	// 从board[row][col]位置的字符出发，
	// 之前的路径上，走过的字符，记录在path里
	// cur还没有登上，有待检查能不能登上去的前缀树的节点
	// 如果找到words中的某个str，就记录在 res里
	// 返回值，从row,col 出发，一共找到了多少个str
	public static int process(
			char[][] board, 
			int row, int col,
			LinkedList<Character> path,
			TrieNode cur, 
			List<String> res) {
		char cha = board[row][col];
		if (cha == 0) { // 这个row col位置是之前走过的位置
			return 0;
		}
		// (row,col) 不是回头路   cha 有效
		
		int index = cha - 'a';
		// 如果没路，或者这条路上最终的字符串之前加入过结果里
		if (cur.nexts[index] == null || cur.nexts[index].pass == 0) {
			return 0;
		}
		// 没有走回头路且能登上去
		cur = cur.nexts[index];
		path.addLast(cha);// 当前位置的字符加到路径里去
		int fix = 0; // 从row和col位置出发，后续一共搞定了多少答案
		// 当我来到row col位置，如果决定不往后走了。是不是已经搞定了某个字符串了
		if (cur.end > 0) { 
			res.add(generatePath(path));
			cur.end--;
			fix++;
		}
		// 往上、下、左、右，四个方向尝试
		board[row][col] = 0;
		if (row > 0) {
			fix += process(board, row - 1, col, path, cur, res);
		}
		if (row < board.length - 1) {
			fix += process(board, row + 1, col, path, cur, res);
		}
		if (col > 0) {
			fix += process(board, row, col - 1, path, cur, res);
		}
		if (col < board[0].length - 1) {
			fix += process(board, row, col + 1, path, cur, res);
		}
		board[row][col] = cha;
		path.pollLast();
		cur.pass -= fix;
		return fix;
	}
```



## 题目四 不同子序列的个数

这个是第二节的第四题  力扣\115. 不同的子序列

![image-20221223164922281](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221223164922281-167178536348110.png)

这个就是一个样本做行，一个做列。$DP[i][j]$表示S[0...i]变到T[0...j]的方案数。 

```
public static int numDistinct1(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		return process(s, t, s.length, t.length);
	}

	public static int process(char[] s, char[] t, int i, int j) {
		if (j == 0) {
			return 1;
		}
		if (i == 0) {
			return 0;
		}
		int res = process(s, t, i - 1, j);
		if (s[i - 1] == t[j - 1]) {
			res += process(s, t, i - 1, j - 1);
		}
		return res;
	}

	// S[...i]的所有子序列中，包含多少个字面值等于T[...j]这个字符串的子序列
	// 记为dp[i][j]
	// 可能性1）S[...i]的所有子序列中，都不以s[i]结尾，则dp[i][j]肯定包含dp[i-1][j]
	// 可能性2）S[...i]的所有子序列中，都必须以s[i]结尾，
	// 这要求S[i] == T[j]，则dp[i][j]包含dp[i-1][j-1]
	public static int numDistinct2(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		int[][] dp = new int[s.length + 1][t.length + 1];
		for (int j = 0; j <= t.length; j++) {
			dp[0][j] = 0;
		}
		for (int i = 0; i <= s.length; i++) {
			dp[i][0] = 1;
		}
		for (int i = 1; i <= s.length; i++) {
			for (int j = 1; j <= t.length; j++) {
				dp[i][j] = dp[i - 1][j] + (s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] : 0);
			}
		}
		return dp[s.length][t.length];
	}

	public static int numDistinct3(String S, String T) {
		char[] s = S.toCharArray();
		char[] t = T.toCharArray();
		int[] dp = new int[t.length + 1];
		dp[0] = 1;
		for (int j = 1; j <= t.length; j++) {
			dp[j] = 0;
		}
		for (int i = 1; i <= s.length; i++) {
			for (int j = t.length; j >= 1; j--) {
				dp[j] += s[i - 1] == t[j - 1] ? dp[j - 1] : 0;
			}
		}
		return dp[t.length];
	}
```

