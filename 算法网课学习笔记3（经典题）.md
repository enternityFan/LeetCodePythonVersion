

# 1.覆盖问题



给定一系列x轴的点坐标，例如 1，3，7，8，9，11这些坐标升序放在数组中，
现在给一根绳子，长度为4，问绳子最多能覆盖的点数有多少，
例如绳子放前面只能覆盖两个点，1,3，如果放后面能覆盖4个点。



求解方法：1.二分法（N*logN),2.滑动窗口法(N)



# 2.括号有效配对问题

![image-20221116191818810](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116191818810-16685975003191.png)

对于问题1，可以用栈，但是没必要，只用一个变量cnt就行，遇到左括号就让cnt++，遇到右括号，就让cnt--，然后有两个原则：1）若过程中cnt<0那就直接返回false,2)遍历结束后看cnt是否等于0，若不是的话返回false.

对于问题2，用两个变量，一个cnt,一个need，当左括号就cnt++,右括号就cnt--,如果cnt==-1的话，那就说明右括号比左括号多1个，那就need++,然后从新把cnt恢复为0，最后返回cnt+next



# 3.最长的括号有效子串的长度（力扣32题）



![image-20221116192835645](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116192835645-16685981169632.png)假如子串必须以i位置的字符结尾，它最长的有效括号子串多长，那么以0,1,2,...n-1结尾都有一个答案，那么最终答案就是上面的n个答案种最大的。

​	dp就是构造辅助数组，看在求解i位置的答案时，是否i-1位置的答案有没有帮助。如果i位置是左括号，那么dp[i]=0,因为不会以左括号结尾，同时dp[0]==0。



# 3.2有效括号最大嵌套层数



很简单，遇到左括号cnt++,右括号cnt---,cnt到达的最大值，就是嵌套的最大层数

# 4.红和绿（爱奇艺笔试）





![image-20221116195859801](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116195859801-16685999407953.png)

枚举分界线。

**可以利用预处理数组的技巧来做**，准备一个辅助数字L，记录0到i位置上有几个G，再准备一个辅助数组R，记录从i到n-1的位置有几个R，然后直接在L，R数组中拿值就可以知道分界线的最好位置。



# 5.边框全为1的最大正方形

![image-20221116201513049](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116201513049-16686009154274.png)

力扣\1139. 最大的以 1 为边界的正方形



​	对于一个NxN的矩形，其中长方形的数量是O(N^ 4),正方形的数量是O（N^ 3)   ,正方形这个就是，左上角点的选取概率是O(N^ 2),那么右下角的点是O(N),N是边长，为了维持正方形嘛，但是长方形的话右下角也是N^ 2 的选择的概率。

​	对于这个大流程，就是三个for循环，for row, for col, for边长，来找正方形。如果不优化的话，里面还有一个for是看边长上的点是否为1，那么这就是一个4阶的，但是这个最里面的for是可以从O（N）优化为O（1）的。

​	**可以用预处理数组来做**，r[i] [j]是(i,j)右边有多少个连续的1，d[i] [j]是(i,j)下面有多少个连续的 1.





# 6.构造数据

力扣\1968. 构造元素不等于两相邻元素平均值的数组有点类似，但很不一样的还是。

![image-20221116204839164](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116204839164-16686029207435.png)

如果有a+c !=2*b,那么可以把a,b,c转换为对应的奇数，即(2*a-1)+(2*c-1) !=2*(2*b-1),同样的也可以给替换为偶数，也是会满足这个公式的。那么如果长度为M，只需要长度为如果M是偶数，需要M//2,否则是(M+1)//2,通过分治法来实现。

​	这个题有点黑。



# 7.二叉树三种最大路径和 



剑指 Offer II 050. 向下的路径节点之和是2）的情况

![image-20221116210451900](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221116210451900-16686038942956.png)

对于2,3题就是两种情况，1）与x有关，2）与x无关。x就是当前路径。前者有4中情况：1）x自己，2）x左边，3）x右边，4）x左右



# 8.有序矩阵找值

面试题 10.09. 排序矩阵查找是这个题；然后这个题没讲，不过看源码还挺简单的。从右上角或者左下角走都可以找到最好的答案。





# 9.机器打包问题

这个题硬记，是个很诡异的贪心，我就先跳过这个题吧。



# 10.左右子数组的最大差值

给定一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。



思路流程：**求数组中的最大值，然后减去0位置和i-1位置较小的那个一数。**；因为不管全局的max被分配到左部分还是右部分，最后的结果都是max减去左部分或者右部分的最大值。而右部分或者左部分一定或囊括0或者n-1位置





        //当最大值包含在左侧时，需要找到右侧相对较小的最大值，而右侧一定会包含arr[arr.length - 1]
        // 当右侧最后一个数为右侧最大值时，右侧怎么变化，左右两侧最大值差值也是 max - arr[arr.length - 1]
        // 当右侧最后一个数不是右侧最大值时，那么左右两个的最大差值会变小，是不会取到的
        // 同理，最大值包含在右侧，只需要找左侧相对较小的最大值，而arr[0]是一定包含的



# 11.装水问题

\42. 接雨水



![image-20221118085127928](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221118085127928-16687326891081.png)

解题思路：求第i位置上面有多少个水，为了知道i位置上面有多少个水，需要知道i位置的左侧和右侧的最大值，然后得到这两个值的最小值，再减去i位置的高度，就是这个位置能装的水。
$$
max(min(左max,右max),0)
$$
​	可以首先使用预处理数组，来把问题从N ** 2 优化到N，**当然这不是最优的。。最优的都不需要这玩意**





# 12.二维接雨水

\407. 接雨水 II

​	解题思路，首先做一个对象，存放num,row,col，表示这个num是row,col位置的数，然后做一个小根堆，把外围的数据给放到小根堆里面，然后用一个flag[ rows ][ cols \]大小标记数组，如果i,j位置的数进入了小根堆，那么就标记为True.

1. 把边沿每个数放入heap
2. heap中弹出堆顶
3. max - num > 0，那么把水量加到一个water的变量上，如果<0就不累加，然后把num所在的上下左右放到小根堆里面。（注意要查询flag,如果上下左右哪个进过小根堆了，就不要进）
4. 然后看看num是否更新max。





# 第四节6、搜索二叉树转换为有序的双向链表

剑指 Offer 36. 二叉搜索树与双向链表





# 第四节7、子矩阵的最大累加和

给定一个整形矩阵，返回子矩阵的最大累加和

力扣面试题 17.24. 最大子矩阵  类似

# 第五节2、编辑距离问题

力扣72. 编辑距离





# 第六节1、最大子数组异或和问题

一个数组的异或和是指数组中所有的数异或在一起的结果给定一个数组arr，求最大子数组异或和。







# 20221215 25经典面试九

## 题目四有序数组累加和前K个

![image-20221215115542539](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215115542539-16710765443911.png)

复杂度：O（n*logk)，利用大根堆实现的一个题。

```java
package class06;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class Code04_TopKSumCrossTwoArrays {

	// 放入大根堆中的结构
	public static class Node {
		public int index1;// arr1中的位置
		public int index2;// arr2中的位置
		public int sum;// arr1[index1] + arr2[index2]的值

		public Node(int i1, int i2, int s) {
			index1 = i1;
			index2 = i2;
			sum = s;
		}
	}

	// 生成大根堆的比较器
	public static class MaxHeapComp implements Comparator<Node> {
		@Override
		public int compare(Node o1, Node o2) {
			return o2.sum - o1.sum;
		}
	}

	public static int[] topKSum(int[] arr1, int[] arr2, int topK) {
		if (arr1 == null || arr2 == null || topK < 1) {
			return null;
		}
		// arr1 50  arr2 20   1000   topk 100万
		topK = Math.min(topK, arr1.length * arr2.length);

		int[] res = new int[topK];
		int resIndex = 0;

		PriorityQueue<Node> maxHeap = new PriorityQueue<>(new MaxHeapComp());

		// set[i][j] == false, arr1[i]  arr2[j] 之前，没进过
		// set[i][j] == true;  arr1[i]  arr2[j] 之前，进过
		boolean[][] set = new boolean[arr1.length][arr2.length];
		int i1 = arr1.length - 1;
		int i2 = arr2.length - 1;
		maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
		set[i1][i2] = true;
		while (resIndex != topK) {
			Node curNode = maxHeap.poll();
			res[resIndex++] = curNode.sum;
			i1 = curNode.index1;
			i2 = curNode.index2;
			if (i1 - 1 >= 0 && !set[i1 - 1][i2]) {
				set[i1 - 1][i2] = true;
				maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
			}
			if (i2 - 1 >= 0 && !set[i1][i2 - 1]) {
				set[i1][i2 - 1] = true;
				maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
			}
		}
		return res;
	}

	// For test, this method is inefficient but absolutely right
	public static int[] topKSumTest(int[] arr1, int[] arr2, int topK) {
		int[] all = new int[arr1.length * arr2.length];
		int index = 0;
		for (int i = 0; i != arr1.length; i++) {
			for (int j = 0; j != arr2.length; j++) {
				all[index++] = arr1[i] + arr2[j];
			}
		}
		Arrays.sort(all);
		int[] res = new int[Math.min(topK, all.length)];
		index = all.length - 1;
		for (int i = 0; i != res.length; i++) {
			res[i] = all[index--];
		}
		return res;
	}

	public static int[] generateRandomSortArray(int len) {
		int[] res = new int[len];
		for (int i = 0; i != res.length; i++) {
			res[i] = (int) (Math.random() * 50000) + 1;
		}
		Arrays.sort(res);
		return res;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static boolean isEqual(int[] arr1, int[] arr2) {
		if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i != arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		int a1Len = 5000;
		int a2Len = 4000;
		int k = 20000000;
		int[] arr1 = generateRandomSortArray(a1Len);
		int[] arr2 = generateRandomSortArray(a2Len);
		long start = System.currentTimeMillis();
		int[] res = topKSum(arr1, arr2, k);
		long end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		start = System.currentTimeMillis();
		int[] absolutelyRight = topKSumTest(arr1, arr2, k);
		end = System.currentTimeMillis();
		System.out.println(end - start + " ms");

		System.out.println(isEqual(res, absolutelyRight));

	}

}

```

## 题目五切分n分累加和相等

![image-20221215125450443](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215125450443-16710800912862.png)

算法复杂度：O(n)

这个题听讲解感觉还是很简单的重要的是思路，和敢式。

做一个map去记录位置i的前缀和，然后枚举第一刀，然后得到结果。

```

	public static boolean canSplits2(int[] arr) {
		if (arr == null || arr.length < 7) {
			return false;
		}
		// key 某一个累加和， value出现的位置
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		int sum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			map.put(sum, i);
			sum += arr[i];
		}
		int lsum = arr[0]; // 第一刀左侧的累加和
		for (int s1 = 1; s1 < arr.length - 5; s1++) { // s1是第一刀的位置
			int checkSum = lsum * 2 + arr[s1]; // 100 x 100   100*2 + x
			if (map.containsKey(checkSum)) {
				int s2 = map.get(checkSum); // j -> y
				checkSum += lsum + arr[s2];
				if (map.containsKey(checkSum)) { // 100 * 3 + x + y
					int s3 = map.get(checkSum); // k -> z
					if (checkSum + arr[s3] + lsum == sum) {
						return true;
					}
				}
			}
			lsum += arr[s1];
		}
		return false;
	}



```



## 题目六 交错组成



![image-20221215130305530](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215130305530-16710805866803.png)

这是一个动态规划的题，每个格子只依赖于其左侧和上侧的格子，并且需要用$str3[i][j]$进行判断

```
	public static boolean isCross1(String s1, String s2, String ai) {
		if (s1 == null || s2 == null || ai == null) {
			return false;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		char[] aim = ai.toCharArray();
		if (aim.length != str1.length + str2.length) {
			return false;
		}
		boolean[][] dp = new boolean[str1.length + 1][str2.length + 1];
		dp[0][0] = true;
		for (int i = 1; i <= str1.length; i++) {
			if (str1[i - 1] != aim[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		for (int j = 1; j <= str2.length; j++) {
			if (str2[j - 1] != aim[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i <= str1.length; i++) {
			for (int j = 1; j <= str2.length; j++) {
				
				if (
						
						(str1[i - 1] == aim[i + j - 1] && dp[i - 1][j])
						
						|| 
						
						(str2[j - 1] == aim[i + j - 1] && dp[i][j - 1])
						
						
				) {
					
					
					dp[i][j] = true;
					
					
				}
				
				
				
			}
		}
		return dp[str1.length][str2.length];
	}

	public static boolean isCross2(String str1, String str2, String aim) {
		if (str1 == null || str2 == null || aim == null) {
			return false;
		}
		char[] ch1 = str1.toCharArray();
		char[] ch2 = str2.toCharArray();
		char[] chaim = aim.toCharArray();
		if (chaim.length != ch1.length + ch2.length) {
			return false;
		}
		char[] longs = ch1.length >= ch2.length ? ch1 : ch2;
		char[] shorts = ch1.length < ch2.length ? ch1 : ch2;
		boolean[] dp = new boolean[shorts.length + 1];
		dp[0] = true;
		for (int i = 1; i <= shorts.length; i++) {
			if (shorts[i - 1] != chaim[i - 1]) {
				break;
			}
			dp[i] = true;
		}
		for (int i = 1; i <= longs.length; i++) {
			dp[0] = dp[0] && longs[i - 1] == chaim[i - 1];
			for (int j = 1; j <= shorts.length; j++) {
				if ((longs[i - 1] == chaim[i + j - 1] && dp[j]) || (shorts[j - 1] == chaim[i + j - 1] && dp[j - 1])) {
					dp[j] = true;
				} else {
					dp[j] = false;
				}
			}
		}
		return dp[shorts.length];
	}
```

## 题目一最短排序子数组长度

第七节

![image-20221215134838698](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215134838698-16710833198774.png)

时间复杂度O(n),空间复杂度O(1)

```
	public static int getMinLength(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int min = arr[arr.length - 1];
		int noMinIndex = -1;
		for (int i = arr.length - 2; i != -1; i--) {
			if (arr[i] > min) {
				noMinIndex = i;
			} else {
				min = Math.min(min, arr[i]);
			}
		}
		if (noMinIndex == -1) {
			return 0;
		}
		int max = arr[0];
		int noMaxIndex = -1;
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] < max) {
				noMaxIndex = i;
			} else {
				max = Math.max(max, arr[i]);
			}
		}
		return noMaxIndex - noMinIndex + 1;
	}
```

## 题目二最小不可组成和

![image-20221215135541289](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215135541289-16710837424095.png)

这个题的基础解法是，用背包问题的方法去做；然后进阶的解法是，如果arr一定有1，那么就可以做到O(nlogn)的时间复杂度。方法是首先排序，然后一定知道第一个数是1，可以准备一个range=1,表示从1-到range所有的数都可以加出来，对于arr[i]=a,有两种情况：1)a > range + 1,和2) a <=range+1,对于第二种情况，那么可以更新range = range + a;对于第一种情况，直接返回range+1就是结果。如果都没有遇到1）的情况，那就直接返回range+1就是结果。



下面代码中，前两个是背包的方法，第三个是进阶的方法。

```
public static int unformedSum1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		HashSet<Integer> set = new HashSet<Integer>();
		process(arr, 0, 0, set);
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			min = Math.min(min, arr[i]);
		}
		for (int i = min + 1; i != Integer.MIN_VALUE; i++) {
			if (!set.contains(i)) {
				return i;
			}
		}
		return 0;
	}

	public static void process(int[] arr, int i, int sum, HashSet<Integer> set) {
		if (i == arr.length) {
			set.add(sum);
			return;
		}
		process(arr, i + 1, sum, set);
		process(arr, i + 1, sum + arr[i], set);
	}

	public static int unformedSum2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		int sum = 0;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i != arr.length; i++) {
			sum += arr[i];
			min = Math.min(min, arr[i]);
		}
		// boolean[][] dp ...
		int N = arr.length;
		boolean[][] dp = new boolean[N][sum + 1];
		for (int i = 0; i < N; i++) {// arr[0..i] 0
			dp[i][0] = true;
		}
		dp[0][arr[0]] = true;
		for (int i = 1; i < N; i++) {
			for (int j = 1; j <= sum; j++) {
				dp[i][j] = dp[i - 1][j] || ((j - arr[i] >= 0) ? dp[i - 1][j - arr[i]] : false);
			}
		}
		for (int j = min; j <= sum; j++) {
			if (!dp[N - 1][j]) {
				return j;
			}
		}
		return sum + 1;
	}

	// 已知arr中肯定有1这个数
	public static int unformedSum3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		Arrays.sort(arr); // O (N * logN)
		int range = 1;
		// arr[0] == 1
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] > range + 1) {
				return range + 1;
			} else {
				range += arr[i];
			}
		}
		return range + 1;
	}
```

## 题目三 arr最少缺几个数

![image-20221215140849379](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215140849379-16710845302776.png)

这个题跟二进制很有关，如果实现了1-range的目标，但是没有达到1-aim，那么缺的永远是range+1;如果补上了range+1,那么此时的范围就会变为了1~(2*range+1)

```
// arr请保证有序，且正数
	public static int minPatches(int[] arr, int aim) {
		int patches = 0; // 缺多少个数字
		long range = 0; // 已经完成了1 ~ range的目标
		Arrays.sort(arr);
		for (int i = 0; i != arr.length; i++) {
			// 1~range
			// 1 ~ arr[i]-1
			while (arr[i] - 1 > range) { // arr[i] 1 ~ arr[i]-1
				range += range + 1; // range + 1 是缺的数字
				patches++;
				if (range >= aim) {
					return patches;
				}
			}
			range += arr[i];
			if (range >= aim) {
				return patches;
			}
		}
		while (aim >= range + 1) {
			range += range + 1;
			patches++;
		}
		return patches;
	}
```

## 题目六 没有重复字符子串的最长长度

![image-20221215142012396](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215142012396-16710852136367.png)

3. 无重复字符的最长子串(力扣)

这个题是用DP做的，不过我发现我之前是用滑动窗口做的。

```
public static int maxUnique(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		// map 替代了哈希表   假设字符的码是0~255
		int[] map = new int[256];
		for (int i = 0; i < 256; i++) {
			map[i] = -1;
		}
		int len = 0;
		int pre = -1;
		int cur = 0;
		for (int i = 0; i != chas.length; i++) {
			pre = Math.max(pre, map[chas[i]]);
			cur = i - pre;
			len = Math.max(len, cur);
			map[chas[i]] = i;
		}
		return len;
	}
```



# 20221216 26经典面试十

## 题目四 数组独立域

![image-20221215210002640](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221215210002640-16711092040131.png)

并查集的题。如果有n个数，某个数值为V，那么算法可以优化为O(n*v),n为遍历数组，V为计算V这个数值是否是质数。这个算法最高可以优化为$ O(n*sqrt(V)) $，就是把2-sqrt(V)都当做V的质数，如果可以整除的话。

力扣\952. 按公因数计算最大组件大小；方法一会超时。



```
public static int largestComponentSize1(int[] arr) {
		int N = arr.length;
		UnionFind set = new UnionFind(N);
		for (int i = 0; i < N; i++) {
			for (int j = i + 1; j < N; j++) {
				if (gcd(arr[i], arr[j]) != 1) {
					set.union(i, j);
				}
			}
		}
		return set.maxSize();
	}

	public static int largestComponentSize2(int[] arr) {
		int N = arr.length;
		UnionFind unionFind = new UnionFind(N);
		HashMap<Integer, Integer> fatorsMap = new HashMap<>();
		for (int i = 0; i < N; i++) {
			int num = arr[i];
			int limit = (int) Math.sqrt(num);
			for (int j = 1; j <= limit; j++) {
				if (num % j == 0) {
					if (j != 1) {
						if (!fatorsMap.containsKey(j)) {
							fatorsMap.put(j, i);
						} else {
							unionFind.union(fatorsMap.get(j), i);
						}
					}
					int other = num / j;
					if (other != 1) {
						if (!fatorsMap.containsKey(other)) {
							fatorsMap.put(other, i);
						} else {
							unionFind.union(fatorsMap.get(other), i);
						}
					}
				}
			}
		}
		return unionFind.maxSize();
	}

	public static int gcd(int m, int n) {
	//辗转相除法，求最大公约数
		return n == 0 ? m : gcd(n, m % n);
	}

	public static class UnionFind {
		private int[] parents;
		private int[] sizes;
		private int[] help;

		public UnionFind(int N) {
			parents = new int[N];
			sizes = new int[N];
			help = new int[N];
			for (int i = 0; i < N; i++) {
				parents[i] = i;
				sizes[i] = 1;
			}
		}

		public int maxSize() {
			int ans = 0;
			for (int size : sizes) {
				ans = Math.max(ans, size);
			}
			return ans;
		}

		private int find(int i) {
			int hi = 0;
			while (i != parents[i]) {
				help[hi++] = i;
				i = parents[i];
			}
			for (hi--; hi >= 0; hi--) {
				parents[help[hi]] = i;
			}
			return i;
		}

		public void union(int i, int j) {
			int f1 = find(i);
			int f2 = find(j);
			if (f1 != f2) {
				int big = sizes[f1] >= sizes[f2] ? f1 : f1;
				int small = big == f1 ? f2 : f1;
				parents[small] = big;
				sizes[big] = sizes[f1] + sizes[f2];
			}
		}
	}
```

## 题目五 删除多于字符使每种只保留一个且字典序最小

![image-20221216122914348](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216122914348-16711649558341.png)

​	**删除的方案和保留的方案其实是一回事；如果挑了i位置的字符，那么不能再在左侧再挑字符，只能从i右侧挑选，这种方式其实也不会错过答案的。**

​	首先先统计一下词频，

方法1是讲的。如果有K种字符，那么复杂度为O（KN）

```
// 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回
	public static String removeDuplicateLetters1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		int[] map = new int[256];
		for (int i = 0; i < str.length(); i++) {
			map[str.charAt(i)]++;
		}
		int minACSIndex = 0;
		for (int i = 0; i < str.length(); i++) {
			minACSIndex = str.charAt(minACSIndex) > str.charAt(i) ? i : minACSIndex;
			if (--map[str.charAt(i)] == 0) {
				break;
			}
		}
		return String.valueOf(str.charAt(minACSIndex)) + removeDuplicateLetters1(
				str.substring(minACSIndex + 1).replaceAll(String.valueOf(str.charAt(minACSIndex)), ""));
	}

	public static String removeDuplicateLetters2(String s) {
		char[] str = s.toCharArray();
		// 小写字母ascii码值范围[97~122]，所以用长度为26的数组做次数统计
		// 如果map[i] > -1，则代表ascii码值为i的字符的出现次数
		// 如果map[i] == -1，则代表ascii码值为i的字符不再考虑
		int[] map = new int[26];
		for (int i = 0; i < str.length; i++) {
			map[str[i] - 'a']++;
		}
		char[] res = new char[26];
		int index = 0;
		int L = 0;
		int R = 0;
		while (R != str.length) {
			// 如果当前字符是不再考虑的，直接跳过
			// 如果当前字符的出现次数减1之后，后面还能出现，直接跳过
			if (map[str[R] - 'a'] == -1 || --map[str[R] - 'a'] > 0) {
				R++;
			} else { // 当前字符需要考虑并且之后不会再出现了
				// 在str[L..R]上所有需要考虑的字符中，找到ascii码最小字符的位置
				int pick = -1;
				for (int i = L; i <= R; i++) {
					if (map[str[i] - 'a'] != -1 && (pick == -1 || str[i] < str[pick])) {
						pick = i;
					}
				}
				// 把ascii码最小的字符放到挑选结果中
				res[index++] = str[pick];
				// 在上一个的for循环中，str[L..R]范围上每种字符的出现次数都减少了
				// 需要把str[pick + 1..R]上每种字符的出现次数加回来
				for (int i = pick + 1; i <= R; i++) {
					if (map[str[i] - 'a'] != -1) { // 只增加以后需要考虑字符的次数
						map[str[i] - 'a']++;
					}
				}
				// 选出的ascii码最小的字符，以后不再考虑了
				map[str[pick] - 'a'] = -1;
				// 继续在str[pick + 1......]上重复这个过程
				L = pick + 1;
				R = L;
			}
		}
		return String.valueOf(res, 0, index);
	}
```



## 题目七 直线最多穿越多少点

![image-20221216124515155](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216124515155-16711659163882.png)

​	力扣\149. 直线上最多的点数



思路：遍历每个点(x0,y0)，查看必须通过这个点，最多会穿过多少个点。对于两个点p1,p2有四种关系:1)重合2）水平，p1p2点共Y；3）垂直，p1p2共X；4）p1p2有斜率.。（p1y-p2y)/(p1x-p2x)

​	对于p1点，统计:1)多少点与p1重合;2)在不重合的情况下有多少和p1共y,3)有多少不重合的情况下与p1是共x，4）是一个map，key为一个斜率，value为在这个斜率下有多少个点共现的。

复杂度是O（N^2)的。**这道题难点在于怎么表示斜率**,应该用最大公倍数的字符串的形式去表示，比如20/30，那么就用"2_3"来表示，或者用二维表进行表示，比如{1:{3:2,4:2,5:2}}就表示1/3有2个;1/4有2个，1/5有2个。

```
	public static class Point {
		public int x;
		public int y;

		Point() {
			x = 0;
			y = 0;
		}

		Point(int a, int b) {
			x = a;
			y = b;
		}
	}

	public static int maxPoints(Point[] points) {
		if (points == null) {
			return 0;
		}
		if (points.length <= 2) {
			return points.length;
		}
		// key : 分子  value : 分母表
		Map<Integer, Map<Integer, Integer>> map = new HashMap<Integer, Map<Integer, Integer>>();
		int result = 0;
		for (int i = 0; i < points.length; i++) {
			map.clear();
			int samePosition = 1;
			int sameX = 0;
			int sameY = 0;
			int line = 0;
			for (int j = i + 1; j < points.length; j++) {
				int x = points[j].x - points[i].x;
				int y = points[j].y - points[i].y;
				if (x == 0 && y == 0) {
					samePosition++;
				} else if (x == 0) {
					sameX++;
				} else if (y == 0) {
					sameY++;
				} else {
					int gcd = gcd(x, y);
					x /= gcd;
					y /= gcd;
					if (!map.containsKey(x)) {
						map.put(x, new HashMap<Integer, Integer>());
					}
					if (!map.get(x).containsKey(y)) {
						map.get(x).put(y, 0);
					}
					map.get(x).put(y, map.get(x).get(y) + 1);
					line = Math.max(line, map.get(x).get(y));
				}
			}
			result = Math.max(result, Math.max(Math.max(sameX, sameY), line) + samePosition);
		}
		return result;
	}

	// 保证初始调用的时候，a和b不等于0
	public static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
```



## 题目四通关怪兽最少花费（从这里开始第八节了）

![image-20221216131036894](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216131036894-16711674384413.png)

DP有两种思路，一种是$DP[N][M]$,M为怪兽能力，这种方法在当M很大时，可能会有问题；第二种方法为$DP[I][J]$想来到I号怪兽，要严格正好花够J元时，最大能力是多少。 所以具体来说还是第二种方法更好，==这个是腾讯的原题，当时N给的500，能力最多1e6,钱是200==





```
	// int[] d d[i]：i号怪兽的武力
	// int[] p p[i]：i号怪兽要求的钱
	// ability 当前你所具有的能力
	// index 来到了第index个怪兽的面前

	// 目前，你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，
	// 请返回需要花的最少钱数
	public static long process(int[] d, int[] p, int ability, int index) {
		if (index == d.length) {
			return 0;
		}
		if (ability < d[index]) {
			return p[index] + process(d, p, ability + d[index], index + 1);
		} else { // 可以贿赂，也可以不贿赂
			return 
					Math.min(
							p[index] + process(d, p, ability + d[index], index + 1),
						    process(d, p, ability, index + 1)
							);
		}
	}

	public static long func1(int[] d, int[] p) {
		return process(d, p, 0, 0);
	}

	public static long func2(int[] d, int[] p) {
		int sum = 0;
		for (int num : d) {
			sum += num;
		}
		long[][] dp = new long[d.length + 1][sum + 1];
		for (int i = 0; i <= sum; i++) {
			dp[0][i] = 0;
		}
		for (int cur = d.length - 1; cur >= 0; cur--) {
			for (int hp = 0; hp <= sum; hp++) {
				// 如果这种情况发生，那么这个hp必然是递归过程中不会出现的状态
				// 既然动态规划是尝试过程的优化，尝试过程碰不到的状态，不必计算
				if (hp + d[cur] > sum) {
					continue;
				}
				if (hp < d[cur]) {
					dp[cur][hp] = p[cur] + dp[cur + 1][hp + d[cur]];
				} else {
					dp[cur][hp] = Math.min(p[cur] + dp[cur + 1][hp + d[cur]], dp[cur + 1][hp]);
				}
			}
		}
		return dp[0][0];
	}

	public static long func3(int[] d, int[] p) {
		int sum = 0;
		for (int num : p) {
			sum += num;
		}
		// dp[i][j]含义：
		// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
		int[][] dp = new int[d.length][sum + 1];
		for (int i = 0; i < dp.length; i++) {
			for (int j = 0; j <= sum; j++) {
				dp[i][j] = -1;
			}
		}
		// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
		dp[0][p[0]] = d[0];
		for (int i = 1; i < d.length; i++) {
			for (int j = 0; j <= sum; j++) {
				// 可能性一，为当前怪兽花钱
				// 存在条件：
				// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
				if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
					dp[i][j] = dp[i - 1][j - p[i]] + d[i];
				}
				// 可能性二，不为当前怪兽花钱
				// 存在条件：
				// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
				if (dp[i - 1][j] >= d[i]) {
					// 两种可能性中，选武力值最大的
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
				}
			}
		}
		int ans = 0;
		// dp表最后一行上，dp[N-1][j]代表：
		// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
		// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
		for (int j = 0; j <= sum; j++) {
			if (dp[d.length - 1][j] != -1) {
				ans = j;
				break;
			}
		}
		return ans;
	}
```

## 题目六 最少添加使回文

![image-20221216133712272](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记3（经典题）.assets\image-20221216133712272-16711690340834.png)

这个题是可以在字符串任意位置添加的！

```
	public static String getPalindrome1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = getDP(chas);
		char[] res = new char[chas.length + dp[0][chas.length - 1]];
		int i = 0;
		int j = chas.length - 1;
		int resl = 0;
		int resr = res.length - 1;
		while (i <= j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) {
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else {
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}

	public static int[][] getDP(char[] str) {
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) {
					dp[i][j] = dp[i + 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		return dp;
	}

```

拓展：不仅要告诉有多少种，还要告诉变成怎样的回文串。

​	