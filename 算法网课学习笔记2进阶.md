# 1.滑动窗口

1. 滑动窗口是一种想象出来的数据结构
2. 滑动窗口有左边界L和右边界R
3. 在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
4. L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
5. L和R只能往右滑
6. L<=R 

## 窗口内最大值的更新结构

* R往右走，是R++，新数右侧进
* L往右走，是L++，老数左侧出
* 要保证L《=R

可以通过 **单调双端队列来实现**,我们要保证双端队列从头部到尾部是从大到小变化的（不相等）。这样的话，双端队列头部的数就是当前窗口的最大值。

对于维持窗口最小值的更新结构，只需要保持双端队列是单调递减就行。

时间复杂度O(N)

## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```
	public static int[] getMaxWindow(int[] arr, int w) {
		if (arr == null || w < 1 || arr.length < w) {
			return null;
		}
		// 其中放的是位置，头代表 （大->小）尾
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int[] res = new int[arr.length - w + 1];
		int index = 0;
		// L...R
		//     i
		for (int R = 0; R < arr.length; R++) { // 当前让 i -> [i] 进窗口 ， i 就是 r
			// R -> 值  可以放在比他大的数后，或者空
			while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[R]) {
				qmax.pollLast();
			}
			qmax.addLast(R);
			// 数进来了
			// 如果窗口没有形成W的长度之前，不弹出数字的
			if (qmax.peekFirst() == R - w) {
				qmax.pollFirst();
			}
			// 以上窗口更新做完了
			if (R >= w - 1) {
				res[index++] = arr[qmax.peekFirst()];
			}
		}
		return res;
	}
```



## 达标子数组数量

给定一个整型数组arr,和一个整数num，某个arr中的子数组sub，如果想达标，必须满足：sub中最大值-sub中最小值<=num,返回arr中达标子数组的数量

==子数组是必须连续的==

 如果，arr[L...R]是达标子数组，那么arr[L..R]的任意一个子数组也一定达标。

```
public static int getNum(int[] arr, int num) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		LinkedList<Integer> qmin = new LinkedList<Integer>();
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int L = 0;
		int R = 0;
		// [L..R) -> [0,0) 窗口内无数 [1,1),也就是说R位置是违规的位置，是本来的R的下一个的位置。
		// [0,1) -> [0~0]
		int res = 0;
		while (L < arr.length) { // L是开头位置，尝试每一个开头

			// 如果此时窗口的开头是L,下面的while工作:R向右扩到违规为止

			while (R < arr.length) { // R是最后一个达标位置的再下一个
				while (!qmin.isEmpty() && arr[qmin.peekLast()] >= arr[R]) {
					qmin.pollLast();
				}
				qmin.addLast(R);
				// R -> arr[R],
				while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[R]) {
					qmax.pollLast();
				}
				qmax.addLast(R);

				if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) {
					break;
				}
				R++;
			}

			// R是最后一个达标位置的再下一个，第一个违规的位置
			res += R - L;

			if (qmin.peekFirst() == L) {
				qmin.pollFirst();
			}
			if (qmax.peekFirst() == L) {
				qmax.pollFirst();
			}

			L++;

		}
		return res;
	}
```

遇到一个问题的时候，可以好好看看问题能不能建立单调性和范围，能建立后就可以用首尾指针法或者滑动窗口法。



# 2.单调栈

给一个数组nums=[3,2,1,7,0,4,5,6],需要得到一个map数组，他的第i位置存储的是他他左边比他小的最近的数的位置和右边比他小的最近的数的位置。如果用暴力的方法的话O（N^2),单调栈的话可以让整体O（N）。这时单调栈中栈底到栈顶存放的是从小到大的一个顺序；而如果是要左右边比他大的最近的数的位置的话，单调栈存放的应该是从大到小的一个顺序。如果当前入栈的比栈顶大，那么就开始记录栈顶值的左右离他最小的，当前入栈的值就是他右边最近最小的，栈顶下面的值就是他左边离他最小的。如果值相等，那么栈中这一层就把这个下标也给添加进去。

```
	public static int[][] getNearLessNoRepeat(int[] arr) {
		int[][] res = new int[arr.length][2];
		Stack<Integer> stack = new Stack<>();
		for (int i = 0; i < arr.length; i++) {
			while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
				int popIndex = stack.pop();
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
				res[popIndex][0] = leftLessIndex;
				res[popIndex][1] = i;
			}
			stack.push(i);
		}
		while (!stack.isEmpty()) {
			int popIndex = stack.pop();
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
			res[popIndex][0] = leftLessIndex;
			res[popIndex][1] = -1;
		}
		return res;
	}

	// arr [3, 2, 1, 4, 5]
	//      0  1  2  3  4
	
	//  [
	//    0 :  [-1,  1  ]
	//    1 :  [-1,  2  ]
	
	//  ] 
	//
	public static int[][] getNearLess(int[] arr) {
		int[][] res = new int[arr.length][2];
		
		
		// List<Integer> -> 放的是位置，同样值的东西，位置压在一起
		// 代表值    底  ->  顶   小  -> 大
		Stack<List<Integer>> stack = new Stack<>();
		for (int i = 0; i < arr.length; i++) { // i -> arr[i] 进栈
			// 底 -> 顶， 小 -> 大
			while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
				List<Integer> popIs = stack.pop();
				// 取位于下面位置的列表中，最晚加入的那个
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
				for (Integer popi : popIs) {
					res[popi][0] = leftLessIndex;
					res[popi][1] = i;
				}
			}
			// 相等的、比你小的
			if (!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]) {
				stack.peek().add(Integer.valueOf(i));
			} else {
				ArrayList<Integer> list = new ArrayList<>();
				list.add(i);
				stack.push(list);
			}
		}
		while (!stack.isEmpty()) {
			List<Integer> popIs = stack.pop();
			// 取位于下面位置的列表中，最晚加入的那个
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
			for (Integer popi : popIs) {
				res[popi][0] = leftLessIndex;
				res[popi][1] = -1;
			}
		}
		return res;
	}
```

## 子数组的累加和乘以最小值







```
```



# 类似斐波那契数列（严格的，没有条件转移的）

严格的没有条件转移的，就是没有条件，比如如果代码是如果str[i]=='1'，那么怎么转移，如果str[i] == '2',那么怎么转移，这就是有条件转移的。

## 马走日（这个不是类似斐波那契数列的题）

棋盘10*9的大小，马从(0,0)开始走，给定一个目标点（x,y)和要走的步数K，求有多少种方案可以走到

```
	public static int ways1(int x, int y, int k) {
		return f(x, y, k);
	}

	// 马从(0,0)出发，有K步要走，并且一定要走完，最终来到x，y位置的方法数是多少
	public static int f(int x, int y, int k) {
		if (k == 0) {
			return x == 0 && y == 0 ? 1 : 0;
		}
		if (x < 0 || x > 9 || y < 0 || y > 8) {
			return 0;
		}
		// 有步数要走, x，y 也是棋盘上的位置
		return f(x + 2, y - 1, k - 1) + f(x + 2, y + 1, k - 1) + f(x + 1, y + 2, k - 1) + f(x - 1, y + 2, k - 1)
				+ f(x - 2, y + 1, k - 1) + f(x - 2, y - 1, k - 1) + f(x - 1, y - 2, k - 1) + f(x + 1, y - 2, k - 1);
	}

	public static int ways2(int x, int y, int k) {
		int[][][] dp = new int[10][9][k + 1];// 0~k

		dp[0][0][0] = 1; // dp[..][..][0] = 0

		for (int level = 1; level <= k; level++) {
			// level层，x y
			for (int i = 0; i < 10; i++) { // x可能性
				for (int j = 0; j < 9; j++) { // y的可能性
					dp[i][j][level] = getValue(dp, i + 2, j - 1, level - 1) + getValue(dp, i + 2, j + 1, level - 1)
							+ getValue(dp, i + 1, j + 2, level - 1) + getValue(dp, i - 1, j + 2, level - 1)
							+ getValue(dp, i - 2, j + 1, level - 1) + getValue(dp, i - 2, j - 1, level - 1)
							+ getValue(dp, i - 1, j - 2, level - 1) + getValue(dp, i + 1, j - 2, level - 1);
				}
			}
		}

		return dp[x][y][k];
	}

	public static int getValue(int[][][] dp, int x, int y, int k) {
		if (x < 0 || x > 9 || y < 0 || y > 8) {
			return 0;
		}
		return dp[x][y][k];
	}
	
	
	public static int ways3(int x, int y, int k) {
		return p(0,0,k,x,y);
	}
	
	// 当前来到row，col位置，还剩rest步，走完rest步之后，来到x，y位置，方法数多少
	public static int p(int row, int col, int rest, int x, int y) {
		if(rest == 0) {
			return row == x && col == y ? 1 :0;
		}
		
		if (row < 0 || row > 9 || col < 0 || col > 8) {
			return 0;
		}
		
		return p(row + 2, col - 1, rest - 1, x, y) 
				+ p(row + 2, col + 1, rest - 1, x, y) 
				+ p(row + 1, col + 2, rest - 1, x, y) 
				+ p(row - 1, col + 2, rest - 1, x, y)
				+ p(row - 2, col + 1, rest - 1, x, y) 
				+ p(row - 2, col - 1, rest - 1, x, y) 
				+ p(row - 1, col - 2, rest - 1, x, y) 
				+ p(row + 1, col - 2, rest - 1, x, y);
		
	}
	
	
	
	
	
	

	public static void main(String[] args) {
		int x = 6;
		int y = 8;
		int k = 10;
		System.out.println(ways1(x, y, k));
		System.out.println(ways2(x, y, k));
		System.out.println(ways3(x, y, k));

	}
```



## 快速幂

与简单的幂相比，时间复杂度是$log_2N$

### 一个数的平方怎么算的快？

比如要算$10^{75}$,把75拆分为二进制：75=1001011，通过一个变量来记录10的1次方，2次方，4次方。。。。64次方，然后用变量res来算最终的结果，则$10=1* 10^1 * 10^2 * 10^4 * 10^8$就得到了结果，很快速。math.power中对于整数方就是这么实现的。

```
		int res = 1;

		
		// res = 矩阵中的1,p为1001011，就是幂的二进制表示
		int tmp = 10;
		for (; p != 0; p >>= 1) {
			if ((p & 1) != 0) {
				res = tmp * res;
			}
			tmp = tmp * tmp;
		}
```



### 一个矩阵怎么平方快？

和上面是一样的，下面的代码f3是累乘斐波那列数列的代码，其中就有矩阵相乘的地方。f1,f2是普通的解。

s1,s2,s3是针对推广：计算F(n) = c1F(n-1)  + c2F(n-2) +...+ czF(n-k),c1,c2,cz为常数，k也为常数，都有logN的解。

举个例子，比如农场第一年有一个母牛，母牛都不会死，并且每个母牛每年都会生1个母牛，小母牛到第三年会开始生母牛，问第N年有多少牛

对于这个问题，就是个三阶的问题：F（N） = 1*F（N-1）+0 *F（N-2） + 1 * F（N-3），因为最后减的是3，所以是三阶的问题。因为是三阶问题，所以可以得到：
$$
F(n) * F(n-1) * F(n-2) * F(n-3) = det|F3 F2 F1| * (3*3矩阵)^{n-3}
$$
注意这个公式跟c1,c2,ck的值无关的，只要是这个形式就可以这么算。



```
	public static int f1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		return f1(n - 1) + f1(n - 2);
	}

	public static int f2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		int res = 1;
		int pre = 1;
		int tmp = 0;
		for (int i = 3; i <= n; i++) {
			tmp = res;
			res = res + pre;
			pre = tmp;
		}
		return res;
	}

	public static int f3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		// [ 1 ,1 ]
		// [ 1, 0 ]
		int[][] base = { 
				{ 1, 1 }, 
				{ 1, 0 } 
				};
		int[][] res = matrixPower(base, n - 2);
		return res[0][0] + res[1][0];
	}

	public static int[][] matrixPower(int[][] m, int p) {
		int[][] res = new int[m.length][m[0].length];
		for (int i = 0; i < res.length; i++) {
			res[i][i] = 1;//制作单位矩阵
		}
		
		// res = 矩阵中的1
		int[][] tmp = m;// 矩阵1次方
		for (; p != 0; p >>= 1) {
			if ((p & 1) != 0) {
				res = muliMatrix(res, tmp);
			}
			tmp = muliMatrix(tmp, tmp);
		}
		return res;
	}

	// 两个矩阵乘完之后的结果返回
	public static int[][] muliMatrix(int[][] m1, int[][] m2) {
		int[][] res = new int[m1.length][m2[0].length];
		for (int i = 0; i < m1.length; i++) {
			for (int j = 0; j < m2[0].length; j++) {
				for (int k = 0; k < m2.length; k++) {
					res[i][j] += m1[i][k] * m2[k][j];
				}
			}
		}
		return res;
	}

	public static int s1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		return s1(n - 1) + s1(n - 2);
	}

	public static int s2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		int res = 2;
		int pre = 1;
		int tmp = 0;
		for (int i = 3; i <= n; i++) {
			tmp = res;
			res = res + pre;
			pre = tmp;
		}
		return res;
	}

	public static int s3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		int[][] base = { { 1, 1 }, { 1, 0 } };
		int[][] res = matrixPower(base, n - 2);
		return 2 * res[0][0] + res[1][0];
	}

	public static int c1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		return c1(n - 1) + c1(n - 3);
	}

	public static int c2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int res = 3;
		int pre = 2;
		int prepre = 1;
		int tmp1 = 0;
		int tmp2 = 0;
		for (int i = 4; i <= n; i++) {
			tmp1 = res;
			tmp2 = pre;
			res = res + prepre;
			pre = tmp1;
			prepre = tmp2;
		}
		return res;
	}

	public static int c3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int[][] base = { 
				{ 1, 1, 0 }, 
				{ 0, 0, 1 }, 
				{ 1, 0, 0 } };
		int[][] res = matrixPower(base, n - 3);
		return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
	}

	public static void main(String[] args) {
		int n = 19;
		System.out.println(f1(n));
		System.out.println(f2(n));
		System.out.println(f3(n));
		System.out.println("===");

		System.out.println(s1(n));
		System.out.println(s2(n));
		System.out.println(s3(n));
		System.out.println("===");

		System.out.println(c1(n));
		System.out.println(c2(n));
		System.out.println(c3(n));
		System.out.println("===");

	}
```

## 达标数列

给定一个数N，想象只由O和1两种字符，组成的所有长度为N的字符串如果某个字符串,任何O字符的左边都有1紧挨着,认为这个字符串达标返回有多少达标的字符串。

解题思路：如果N=1，那么只有“0”，“1”这两种情况，其中“1”是达标的，如果N=2，那么"10","11"是达标的。不用暴力试，因为时间复杂度O（2^N*N),太大了。做递归，f(i)表示i个长度的达标数量，**此时假设这i个长度的左边一定有一个1存在**，那么f(8)的计算要去找f(7)，因为左边有个1.如下图，如果第一个位置填1，那么要求f(i-1)的值，如果填0，那么求f(i-2)的值（因为0下面必须是1，根据我们f(i)的假设），这是属于从左到右的尝试模型。

![image-20221018181530736](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221018181530736-16660881322991.png)

## 瓷砖方案

对于2*N的墙，用1 * 2的瓷砖，请问填满有多少方案？

解题思路：F（N）表示还有N列没有填满，那么瓷砖如果竖着摆，那么就还有F（N-1）的情况；如果瓷砖横着摆，就还有F（N-2）的情况，则F（N） = F（N-1） + F（N—2）



## 机器吐球

假如有一个机器一直源源不断的吐球，1号，2号。。。n号。我只有一个能装下10个球的袋子，我可以选择入袋或者扔掉，如果扔掉那么就一定找不到了，如果机器吐出n个球，我要保证每个球被选中的概率为10/n，是均等的，如何做？

解题思路：设计一个函数f(i),可以返回等概率的，1到i的任意一个数字 ；对于1号球到10号球，没有决策过程，都入袋，但是大于10号时，每个球出来时以10/k的概率看要不要他，如果要，就一定入袋，然后球袋里的十个球等概率扔一个。



# 7 线段树（区间修改树）

线段树解决的问题是，当需要区间的修改或者更新或者查询一些东西，怎么比较快。

比如一个场景：有一个数组arr[1001] = [3,7,6,4,-2,.....]，做一个线段树，提供三个接口一个是add方法，让L到R的范围都加一个V的值；第二个方法是从L到R的方法，让所有的数字都变成V；第三个方法得到L和R的累加和。**线段树的指标是上述的三个方法的速度都达到logN的水平**。

* 如果数组的长度N不是2的幂，那么需要准备4*N的空间，不然的话2N的空间就够用了，所以综上所述，一般来说要4N的空间。 

```
	public static class SegmentTree {
		// arr[]为原序列的信息从0开始，但在arr里是从1开始的
		// sum[]模拟线段树维护区间和
		// lazy[]为累加懒惰标记
		// change[]为更新的值
		// update[]为更新慵懒标记
		private int MAXN;
		private int[] arr;
		private int[] sum;
		private int[] lazy;
		private int[] change;
		private boolean[] update;

		public SegmentTree(int[] origin) {
			MAXN = origin.length + 1;
			arr = new int[MAXN]; // arr[0] 不用  从1开始使用
			for (int i = 1; i < MAXN; i++) {
				arr[i] = origin[i - 1];
			}
			sum = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围的累加和信息
			
			lazy = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務
			change = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围有没有更新操作的任务
			update = new boolean[MAXN << 2]; // 用来支持脑补概念中，某一个范围更新任务，更新成了什么
		}

		private void pushUp(int rt) {
			sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
		}

		// 之前的，所有懒增加，和懒更新，从父范围，发给左右两个子范围
		// 分发策略是什么
		// ln表示左子树元素结点个数，rn表示右子树结点个数
		private void pushDown(int rt, int ln, int rn) {
			if (update[rt]) {
				update[rt << 1] = true;
				update[rt << 1 | 1] = true;
				change[rt << 1] = change[rt];
				change[rt << 1 | 1] = change[rt];
				lazy[rt << 1] = 0;
				lazy[rt << 1 | 1] = 0;
				sum[rt << 1] = change[rt] * ln;
				sum[rt << 1 | 1] = change[rt] * rn;
				update[rt] = false;
			}
			if (lazy[rt] != 0) {
				lazy[rt << 1] += lazy[rt];
				sum[rt << 1] += lazy[rt] * ln;
				lazy[rt << 1 | 1] += lazy[rt];
				sum[rt << 1 | 1] += lazy[rt] * rn;
				lazy[rt] = 0;
			}
		}

		// 在初始化阶段，先把sum数组，填好
		// 在arr[l~r]范围上，去build，1~N，
		// rt :  这个范围在sum中的下标
		public void build(int l, int r, int rt) {
			if (l == r) {
				sum[rt] = arr[l];
				return;
			}
			int mid = (l + r) >> 1;
			build(l, mid, rt << 1);
			build(mid + 1, r, rt << 1 | 1);
			pushUp(rt);
		}

		public void update(int L, int R, int C, int l, int r, int rt) {
			if (L <= l && r <= R) {
				update[rt] = true;
				change[rt] = C;
				sum[rt] = C * (r - l + 1);
				lazy[rt] = 0;
				return;
			}
			// 当前任务躲不掉，无法懒更新，要往下发
			int mid = (l + r) >> 1;
			pushDown(rt, mid - l + 1, r - mid);
			if (L <= mid) {
				update(L, R, C, l, mid, rt << 1);
			}
			if (R > mid) {
				update(L, R, C, mid + 1, r, rt << 1 | 1);
			}
			pushUp(rt);
		}

		// L..R -> 任务范围 ,所有的值累加上C
		// l,r -> 表达的范围
		// rt  去哪找l，r范围上的信息
		public void add(
				int L, int R, int C,
				int l, int r, 
				int rt) {
			// 任务的范围彻底覆盖了，当前表达的范围
			if (L <= l && r <= R) {
				sum[rt] += C * (r - l + 1);
				lazy[rt] += C;
				return;
			}
			// 任务并没有把l...r全包住
			// 要把当前任务往下发
			// 任务  L, R  没有把本身表达范围 l,r 彻底包住
			int mid = (l + r) >> 1; // l..mid  (rt << 1)   mid+1...r(rt << 1 | 1)
			// 下发之前所有攒的懒任务
			pushDown(rt, mid - l + 1, r - mid);
			// 左孩子是否需要接到任务
			if (L <= mid) {
				add(L, R, C, l, mid, rt << 1);
			}
			// 右孩子是否需要接到任务
			if (R > mid) {
				add(L, R, C, mid + 1, r, rt << 1 | 1);
			}
			// 左右孩子做完任务后，我更新我的sum信息
			pushUp(rt);
		}

		//   1~6 累加和是多少？ 1~8   rt
		public long query(int L, int R, int l, int r, int rt) {
			if (L <= l && r <= R) {
				return sum[rt];
			}
			int mid = (l + r) >> 1;
			pushDown(rt, mid - l + 1, r - mid);
			long ans = 0;
			if (L <= mid) {
				ans += query(L, R, l, mid, rt << 1);
			}
			if (R > mid) {
				ans += query(L, R, mid + 1, r, rt << 1 | 1);
			}
			return ans;
		}

	}

	public static class Right {
		public int[] arr;

		public Right(int[] origin) {
			arr = new int[origin.length + 1];
			for (int i = 0; i < origin.length; i++) {
				arr[i + 1] = origin[i];
			}
		}

		public void update(int L, int R, int C) {
			for (int i = L; i <= R; i++) {
				arr[i] = C;
			}
		}

		public void add(int L, int R, int C) {
			for (int i = L; i <= R; i++) {
				arr[i] += C;
			}
		}

		public long query(int L, int R) {
			long ans = 0;
			for (int i = L; i <= R; i++) {
				ans += arr[i];
			}
			return ans;
		}

	}
```

## 相关问题



![image-20221227174706848](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221227174706848-16721344277582.png)

这个题只用add和query操作就行了。这里的代码做了一个离散化，实现了空间的压缩。

力扣

699. 掉落的方块



```
	public static class SegmentTree {
		private int[] max;
		private int[] change;
		private boolean[] update;

		public SegmentTree(int size) {
			int N = size + 1;
			max = new int[N << 2];
			
			change = new int[N << 2];
			update = new boolean[N << 2];
		}

		private void pushUp(int rt) {
			max[rt] = Math.max(max[rt << 1], max[rt << 1 | 1]);
		}

		// ln表示左子树元素结点个数，rn表示右子树结点个数
		private void pushDown(int rt, int ln, int rn) {
			if (update[rt]) {
				update[rt << 1] = true;
				update[rt << 1 | 1] = true;
				change[rt << 1] = change[rt];
				change[rt << 1 | 1] = change[rt];
				max[rt << 1] = change[rt];
				max[rt << 1 | 1] = change[rt];
				update[rt] = false;
			}
		}

		public void update(int L, int R, int C, int l, int r, int rt) {
			if (L <= l && r <= R) {
				update[rt] = true;
				change[rt] = C;
				max[rt] = C;
				return;
			}
			int mid = (l + r) >> 1;
			pushDown(rt, mid - l + 1, r - mid);
			if (L <= mid) {
				update(L, R, C, l, mid, rt << 1);
			}
			if (R > mid) {
				update(L, R, C, mid + 1, r, rt << 1 | 1);
			}
			pushUp(rt);
		}

		public int query(int L, int R, int l, int r, int rt) {
			if (L <= l && r <= R) {
				return max[rt];
			}
			int mid = (l + r) >> 1;
			pushDown(rt, mid - l + 1, r - mid);
			int left = 0;
			int right = 0;
			if (L <= mid) {
				left = query(L, R, l, mid, rt << 1);
			}
			if (R > mid) {
				right = query(L, R, mid + 1, r, rt << 1 | 1);
			}
			return Math.max(left, right);
		}

	}

	// positions
	// [2,7] -> 2 , 8
	// [3, 10] -> 3, 12
	//
	//
	public HashMap<Integer, Integer> index(int[][] positions) {
		TreeSet<Integer> pos = new TreeSet<>();
		for (int[] arr : positions) {
			pos.add(arr[0]);
			pos.add(arr[0] + arr[1] - 1);
		}
		HashMap<Integer, Integer> map = new HashMap<>();
		int count = 0;
		for (Integer index : pos) {
			map.put(index, ++count);
		}
		return map;
	}

	public List<Integer> fallingSquares(int[][] positions) {
		HashMap<Integer, Integer> map = index(positions);
		// 100   -> 1    306 ->   2   403 -> 3
		// [100,403]   1~3 
		int N = map.size(); // 1 ~ 	N
		SegmentTree segmentTree = new SegmentTree(N);
		int max = 0;
		List<Integer> res = new ArrayList<>();
		// 每落一个正方形，收集一下，所有东西组成的图像，最高高度是什么
		for (int[] arr : positions) {
			int L = map.get(arr[0]);
			int R = map.get(arr[0] + arr[1] - 1);
			int height = segmentTree.query(L, R, 1, N, 1) + arr[1];
			max = Math.max(max, height);
			res.add(max);
			segmentTree.update(L, R, height, 1, N, 1);
		}
		return res;
	}
```

线段树的应用场景中，比如要找L...R里面出现最多的次数的数，是不能用线段树去解决的。想用线段树，需要符合只考虑左边或者右边的状况，而不用整合。



1-N个房子，有17种颜色，想让L...R范围统一刷成一种颜色，有这么一个操作，还想查询L...R颜色有多少种？



线段最大重合问题，也可以用线段树做，不过不是最优的，用小根堆去做。这个题还可以拓展，拓展为给一些矩形，找最大的公共区域。

```
	public static int maxCover1(int[][] lines) {
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < lines.length; i++) {
			min = Math.min(min, lines[i][0]);
			max = Math.max(max, lines[i][1]);
		}
		int cover = 0;
		for (double p = min + 0.5; p < max; p += 1) {
			int cur = 0;
			for (int i = 0; i < lines.length; i++) {
				if (lines[i][0] < p && lines[i][1] > p) {
					cur++;
				}
			}
			cover = Math.max(cover, cur);
		}
		return cover;
	}

	public static int maxCover2(int[][] m) {
		Line[] lines = new Line[m.length];
		for (int i = 0; i < m.length; i++) {
			lines[i] = new Line(m[i][0], m[i][1]);
		}
		Arrays.sort(lines, new StartComparator());
		PriorityQueue<Line> heap = new PriorityQueue<>(new EndComparator());
		int max = 0;
		for (int i = 0; i < lines.length; i++) {
			while (!heap.isEmpty() && heap.peek().end <= lines[i].start) {
				heap.poll();
			}
			heap.add(lines[i]);
			max = Math.max(max, heap.size());
		}
		return max;
	}

	public static class Line {
		public int start;
		public int end;

		public Line(int s, int e) {
			start = s;
			end = e;
		}
	}

	public static class StartComparator implements Comparator<Line> {

		@Override
		public int compare(Line o1, Line o2) {
			return o1.start - o2.start;
		}

	}

	public static class EndComparator implements Comparator<Line> {

		@Override
		public int compare(Line o1, Line o2) {
			return o1.end - o2.end;
		}

	}

	// for test
	public static int[][] generateLines(int N, int L, int R) {
		int size = (int) (Math.random() * N) + 1;
		int[][] ans = new int[size][2];
		for (int i = 0; i < size; i++) {
			int a = L + (int) (Math.random() * (R - L + 1));
			int b = L + (int) (Math.random() * (R - L + 1));
			if (a == b) {
				b = a + 1;
			}
			ans[i][0] = Math.min(a, b);
			ans[i][1] = Math.max(a, b);
		}
		return ans;
	}
```



下面是矩形的代码

```
	public static class Rectangle {
		public int up;
		public int down;
		public int left;
		public int right;

		public Rectangle(int up, int down, int left, int right) {
			this.up = up;
			this.down = down;
			this.left = left;
			this.right = right;
		}

	}

	public static class DownComparator implements Comparator<Rectangle> {
		@Override
		public int compare(Rectangle o1, Rectangle o2) {
			return o1.down != o2.down ? (o1.down - o2.down) : o1.toString().compareTo(o2.toString());
		}
	}

	public static class LeftComparator implements Comparator<Rectangle> {
		@Override
		public int compare(Rectangle o1, Rectangle o2) {
			return o1.left != o2.left ? (o1.left - o2.left) : o1.toString().compareTo(o2.toString());
		}
	}

	public static class RightComparator implements Comparator<Rectangle> {
		@Override
		public int compare(Rectangle o1, Rectangle o2) {
			return o1.right != o2.right ? (o1.right - o2.right) : o1.toString().compareTo(o2.toString());
		}
	}

	// 矩形数量是N
	// O(N*LogN)
	// +
	// O(N) * [ O(N) + O(N *LogN) ]
	public static int maxCover(Rectangle[] recs) {
		if (recs == null || recs.length == 0) {
			return 0;
		}
		// 根据down（底）排序
		Arrays.sort(recs, new DownComparator());
		// 可能会对当前底边的公共局域，产生影响的矩形
		// list -> treeSet(有序表表达)
		TreeSet<Rectangle> leftOrdered = new TreeSet<>(new LeftComparator());
		int ans = 0;
		// O(N)
		for (int i = 0; i < recs.length;) { // 依次考察每一个矩形的底边
			// 同样底边的矩形一批处理
			do {
				leftOrdered.add(recs[i++]);
			} while (i < recs.length && recs[i].down == recs[i - 1].down);
			// 清除顶<=当前底的矩形
			removeLowerOnCurDown(leftOrdered, recs[i - 1].down);
			// 维持了右边界排序的容器
			TreeSet<Rectangle> rightOrdered = new TreeSet<>(new RightComparator());
			for (Rectangle rec : leftOrdered) { // O(N)
				removeLeftOnCurLeft(rightOrdered, rec.left);
				rightOrdered.add(rec);// O(logN)
				ans = Math.max(ans, rightOrdered.size());
			}
		}
		return ans;
	}

	public static void removeLowerOnCurDown(TreeSet<Rectangle> set, int curDown) {
		List<Rectangle> removes = new ArrayList<>();
		for (Rectangle rec : set) {
			if (rec.up <= curDown) {
				removes.add(rec);
			}
		}
		for (Rectangle rec : removes) {
			set.remove(rec);
		}
	}

	public static void removeLeftOnCurLeft(TreeSet<Rectangle> rightOrdered, int curLeft) {
		List<Rectangle> removes = new ArrayList<>();
		for (Rectangle rec : rightOrdered) {
			if (rec.right > curLeft) {
				break;
			}
			removes.add(rec);
		}
		for (Rectangle rec : removes) {
			rightOrdered.remove(rec);
		}
	}
```









# 卡特兰数



![image-20221223103717546](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221223103717546-16717630392611.png)

假如说二叉树有N个节点，是无差别的，那么他有卡特兰数规律的结构变化。这个二叉树的这个例子，他就是可以用第一个范式。

​	然后假如说有N个0和N个1，然后要求前缀上0 的数要不比1少，这个问题就可以用第二个范式。这个需要点启发性的思想。在数学上，整数和偶数的数量是一样多的，**因为总能找个映射，让整数映射到偶数，并且偶数也能映射到整数**。同样的，对于这个题，可以建立两个集合，集合A中有N个0，N个1组出来的所有非法元素，B集合是N+1个1和N-1个0所组成的所有元素，可以证明他俩都是一样的。对于每个非法元素，都能找到他的一个最早的非法前缀（比如011100,你们011就是最早的非法前缀，），对于非法前缀，他总是 **1比0多一个**，在非法前缀后面的部分，肯定是0比1多一个。那么如果把非法前缀后面的部分0变1,1变0，那么就可以让非法前缀后面的部分给他变的1比0多一个，比如上面的例子，100给变成011.这其实就是一种变化，就是一种映射。那么这样我们就知道非法的数量，和这个N+1个1与N-1个0组成的集合的数量是一样的，那么合法的数量=总的排列数量-非法的数量，也就是N+1个1与N-1个0组成的集合的数量，就是卡特兰数的范式2了。

  再举个例子，栈，栈是出的数量肯定不大于入的数量的吧，其实就是卡特兰数。

​	如果两个集合，能够找到一一映射，那么就说明他们是数量相等的，如果不能找到，不一定他们数量不相等，也可能是自己找不到。





# 20221225 KMP算法

训练营1的class4——code1

这个是比较难的题，每个公司每个部门都会考

在讲KMP问题之前，先说暴力解，暴力解的复杂度是O（NM）的，而对于KMP算法，他是可以在O（N）拿下的，当N》M的时候。KMP算法其实和暴力解的流程一样的，只不过有加速。

```
 // O(N)
	public static int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] str = s.toCharArray();
		char[] match = m.toCharArray();
		int x = 0; // str中当前比对到的位置
		int y = 0; // match中当前比对到的位置
		// M  M <= N   O(M)
		int[] next = getNextArray(match); // next[i]  match中i之前的字符串match[0..i-1]
		// O(N)
		while (x < str.length && y < match.length) {
			if (str[x] == match[y]) {
				x++;
				y++;
			} else if (next[y] == -1) { // y == 0
				x++;
			} else {
				y = next[y];
			}
		}
		return y == match.length ? x - y : -1;
	}

	// M   O(M)
	public static int[] getNextArray(char[] match) {
		if (match.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[match.length];
		next[0] = -1;
		next[1] = 0;
		int i = 2;
		// cn代表，cn位置的字符，是当前和i-1位置比较的字符
		int cn = 0;
		while (i < next.length) {
			if (match[i - 1] == match[cn]) { // 跳出来的时候
				next[i++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[i++] = 0;
			}
		}
		return next;
	}
```



# 20221225 KMP算法及其拓展和bfprt算法





1.对于str1 = "123456",他有很多的旋转词，"234561","123456","345612","456123","561234","612345"等等。。给两个字符串，如果A是B的旋转词，那么就返回True，否则返回False.

可以把BB这么拼接起来，然后就是一个字符串匹配嘛。



2.给两棵树，一课是二叉树T1，另外一个是T2也是二叉树，问是否T1有一个子树，和T2的结构一样。这个是TreeEqual.java对应的代码。



bfprt算法是用来在面试的时候聊，装逼的，提身价的。

3. 无序数组中找第K小的事，如何O（N）实现？（不用排序的方法，不用快排）；不过这里用到了快排的思路。class3的FindMinKh.java对应的代码。训练营1.



bfprt的时间复杂度也是O（N），他和快排的不同，就是，快排的O（N）是根据概率求期望出的，bfprt算法是五友算法，这个算法是可以根据严格的看出来的。bfprt算法的改进之处就是在于选一个数M是怎么选的，他不是随机选的。



这个bfprt算法说实话我听的不太懂，可能也不太专心吧。



# 20221225 Manacher算法及其拓展

​                      想让一个字符串str变为回文，只能在str的后面加，最短加多少能让str变为回文。这个题的意思其实就是，必须包含str原来的最后一个字符的情况下，回文串有多长，延续到左边不是的位置，给他镜像到后面就是了。









# 20221227 Morris遍历及其相关扩展

不管是递归方法还是非递归方法遍历树，我们都需要时间复杂度O(N),空间复杂度O(h),Morris遍历可以实现先序和中序遍历，他可以把空间复杂度优化为O(1),是一个优秀的遍历。

1) 当前节点cur,一开始cur来到整树的头。

   1) cur无左树，cur = cur.right
   2) cur有左树，找到左树最右节点mostright如下图图示(就是一直找cur.right直到非空的最后一个）：

   ![image-20221227082310867](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221227082310867-16721005920131.png)

   ​		2.1 mostright的右指针指向null的，mostright.right = cur,cur = left

   ​		2.2 mostright的右指针指向cur(因为2.1的修改),那么mostright.right=null,cur = cur.right

   ​        2.3 除了以上两种情况，没有别的情况。



这个遍历生成的序叫做Morris序，有一个特点，有左树的节点，他会出现两次。那么前序，其实就是不打印Morris序的第二次出现的，中序，就是出现两次的不打印第一次出现的。

Morris可以实现判断是否是搜索二叉树，其实就是一个中序遍历嘛，看isBST函数，就是把打印的时机改为了比较的时机。 

```
	public static class Node {
		public int value;
		Node left;
		Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void morris(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			// cur有没有左树
			mostRight = cur.left;
			if (mostRight != null) { // 有左树的情况下
				// 找到cur左树上，真实的最右
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				// 从while中出来，mostRight一定是cur左树上的最右节点
				// mostRight
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // mostRight.right != null -> mostRight.right == cur
					mostRight.right = null;
				}
			}
			cur = cur.right;
		}
	}

	public static void morrisIn(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			System.out.print(cur.value + " ");
			cur = cur.right;
		}
		System.out.println();
	}

	public static void morrisPre(Node head) {
		if (head == null) {
			return;
		}
		Node cur1 = head;
		Node cur2 = null;
		while (cur1 != null) {
			cur2 = cur1.left;
			if (cur2 != null) {
				while (cur2.right != null && cur2.right != cur1) {
					cur2 = cur2.right;
				}
				if (cur2.right == null) {
					cur2.right = cur1;
					System.out.print(cur1.value + " ");
					cur1 = cur1.left;
					continue;
				} else {
					cur2.right = null;
				}
			} else {
				System.out.print(cur1.value + " ");
			}
			cur1 = cur1.right;
		}
		System.out.println();
	}

	public static void morrisPos(Node head) {
		if (head == null) {
			return;
		}
		Node cur = head;
		Node mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
					printEdge(cur.left);
				}
			}
			cur = cur.right;
		}
		printEdge(head);
		System.out.println();
	}

	public static void printEdge(Node head) {
		Node tail = reverseEdge(head);
		Node cur = tail;
		while (cur != null) {
			System.out.print(cur.value + " ");
			cur = cur.right;
		}
		reverseEdge(tail);
	}

	public static Node reverseEdge(Node from) {
		Node pre = null;
		Node next = null;
		while (from != null) {
			next = from.right;
			from.right = pre;
			pre = from;
			from = next;
		}
		return pre;
	}

	// for test -- print tree
	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}

	public static boolean isBST(Node head) {
		if (head == null) {
			return true;
		}
		Node cur = head;
		Node mostRight = null;
		Integer pre = null;
		boolean ans = true;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			if (pre != null && pre >= cur.value) {
				ans = false;
			}
			pre = cur.value;
			cur = cur.right;
		}
		return ans;
	}
```



Morris可以做求二叉树的最小高度。



```
	public static class Node {
		public int val;
		public Node left;
		public Node right;

		public Node(int x) {
			val = x;
		}
	}

	public static int minHeight1(Node head) {
		if (head == null) {
			return 0;
		}
		return p(head);
	}

	public static int p(Node x) {
		if (x.left == null && x.right == null) {
			return 1;
		}
		// 左右子树起码有一个不为空
		int leftH = Integer.MAX_VALUE;
		if (x.left != null) {
			leftH = p(x.left);
		}
		int rightH = Integer.MAX_VALUE;
		if (x.right != null) {
			rightH = p(x.right);
		}
		return 1 + Math.min(leftH, rightH);
	}

	// 根据morris遍历改写
	public static int minHeight2(Node head) {
		if (head == null) {
			return 0;
		}
		Node cur = head;
		Node mostRight = null;
		int curLevel = 0;
		int minHeight = Integer.MAX_VALUE;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				int rightBoardSize = 1;
				while (mostRight.right != null && mostRight.right != cur) {
					rightBoardSize++;
					mostRight = mostRight.right;
				}
				if (mostRight.right == null) { // 第一次到达
					curLevel++;
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // 第二次到达
					if (mostRight.left == null) {
						minHeight = Math.min(minHeight, curLevel);
					}
					curLevel -= rightBoardSize;
					mostRight.right = null;
				}
			} else { // 只有一次到达
				curLevel++;
			}
			cur = cur.right;
		}
		int finalRight = 1;
		cur = head;
		while (cur.right != null) {
			finalRight++;
			cur = cur.right;
		}
		if (cur.left == null && cur.right == null) {
			minHeight = Math.min(minHeight, finalRight);
		}
		return minHeight;
	}
```

 什么时候最优解是Morris遍历？如果在来到cur的时候，需要左右子树都给我答案，那么不能用Morris遍历，这个时候用二叉树的递归套路，如果只用左树的信息，并不需要继续保留这个信息，那么需要Morris遍历，比如搜索二叉树中序遍历是递增的，那么这就能Morris遍历。



用数组可以替代哈希表，这样可以提高常数项。











# 20221228 打表的方法和矩阵处理方法

打表不同与预处理结构， 然后这个可以省常数时间，比如一个大问题牵涉到小问题总，那就打表技巧很好使。

![image-20221228092730096](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228092730096-16721908515031.png)

![image-20221228093030759](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228093030759-16721910316773.png)



这里主要说打表找规律。

![image-20221228092833591](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228092833591-16721909153022.png)

这个题就是输入简单，输出也简单，那就首先暴力方法做出了看看哪里能优化，然后再用打表的方法优化优化。暴力法的话，就是从8号袋最多的时候去试，比如说100个苹果，用12个8号袋，如果不行的话，就用11个8号，2两个6号看行不行。这里如果N是奇数的话，就直接返回-1就行了，还有就是如果用了x个8号，还剩y个苹果没有装，若y>=24那就不用试了，一定有问题让装不下的（因为不然的话8号袋早就装好了）。

下面这个代码是根据暴力的结果定制的，当苹果树小于18，就定制业务，否则就根据数学规律返回。

```
	public static int minBagAwesome(int apple) {
		if ((apple & 1) != 0) { // 如果是奇数，返回-1
			return -1;
		}
		if (apple < 18) {
			return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1
					: (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
		}
		return (apple - 18) / 8 + 3;
	}
```

下面是题目二

![image-20221228093819890](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228093819890-16721915011544.png)

首先用暴力尝试，先看看答案：

```
	// n份青草放在一堆
	// 先手后手都绝顶聪明
	// string "先手" "后手"
	public static String winner1(int n) {
		// 0  1  2  3 4
		// 后 先 后 先 先
		if (n < 5) { // base case
			return (n == 0 || n == 2) ? "后手" : "先手";
		}
		// n >= 5 时
		int base = 1; // 当前先手决定吃的草数
		// 当前是先手在选
		while (base <= n) {
			// 当前一共n份草，先手吃掉的是base份，n - base 是留给后手的草
			// 母过程 先手 在子过程里是 后手
			if (winner1(n - base).equals("后手")) {
				return "先手";
			}
			if (base > n / 4) { // 防止base*4之后溢出
				break;
			}
			base *= 4;
		}
		return "后手";
	}
```

然后根据上面的答案，就可以打表了:

```
	public static String winner2(int n) {
		if (n % 5 == 0 || n % 5 == 2) {
			return "后手";
		} else {
			return "先手";
		}
	}
```

题目三：

![image-20221228094741656](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228094741656-16721920629225.png)

首先暴力解：

```
	public static boolean isMSum1(int num) {
		for (int i = 1; i <= num; i++) {
			int sum = i;
			for (int j = i + 1; j <= num; j++) {
				if (sum + j > num) {
					break;
				}
				if (sum + j == num) {
					return true;
				}
				sum += j;
			}
		}
		return false;
	}
```

然后找到了规律：

```
	public static boolean isMSum2(int num) {
		if (num < 3) {
			return false;
		}
		return (num & (num - 1)) != 0;%判断是不是2的某次方
	}
```

但是呢，如果笔试遇到，那就看过不过就行，过了就说明米规律是对的。面试的时候面试官让证明这个规律，那就要说黑话，就说这个东西输入参数简单，输出也简单，我就先弄了一个暴力解，然后找到了规律直接用，至于他背后的数学原理，我再去想，但是不会耽误工作，面试官就会眼泪流啊哈哈，同事很靠谱。这种题很少见的，因为考察数学的，其实也不用想。在工作过程中遇到，那就自测一遍。



## 矩阵处理技巧（矩阵的某种规律问题）

![image-20221228095800170](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228095800170-16721926811696.png)

**做这种题，不要限制到局部位置变化上，会很难写，这种问题绝大多数会有很宏观的去做的。**



对于第一个zigzag矩阵的代码：

```
	public static void printMatrixZigZag(int[][] matrix) {
		int tR = 0;
		int tC = 0;
		int dR = 0;
		int dC = 0;
		int endR = matrix.length - 1;
		int endC = matrix[0].length - 1;
		boolean fromUp = false;
		while (tR != endR + 1) {
		   //printLevel告诉他斜线的两端A和B，方向也告诉，去打印。
			printLevel(matrix, tR, tC, dR, dC, fromUp);
			//下面的顺序是不能调换的，调换会有问题。
			tR = tC == endC ? tR + 1 : tR;
			tC = tC == endC ? tC : tC + 1;
			//下面的顺序是不能调换的，调换会有问题。
			dC = dR == endR ? dC + 1 : dC;
			dR = dR == endR ? dR : dR + 1;
			fromUp = !fromUp;
		}
		System.out.println();
	}

	public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
			boolean f) {
		if (f) {
			while (tR != dR + 1) {
				System.out.print(m[tR++][tC--] + " ");
			}
		} else {
			while (dR != tR - 1) {
				System.out.print(m[dR--][dC++] + " ");
			}
		}
	}
```

2）转圈矩阵，有这么一个规律，就说外圈的结束点和内圈的起始点是有关系的。可以通过a,b,c,d来分解掉这个转圈的事。



```
	public static void spiralOrderPrint(int[][] matrix) {
		int tR = 0;
		int tC = 0;
		int dR = matrix.length - 1;
		int dC = matrix[0].length - 1;
		while (tR <= dR && tC <= dC) {
			printEdge(matrix, tR++, tC++, dR--, dC--);
		}
	}

	public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
		if (tR == dR) {
			//框只剩横线
			for (int i = tC; i <= dC; i++) {
				System.out.print(m[tR][i] + " ");
			}
		} else if (tC == dC) {
		// 框只剩竖线
			for (int i = tR; i <= dR; i++) {
				System.out.print(m[i][tC] + " ");
			}
		} else {
			int curC = tC;
			int curR = tR;
			while (curC != dC) {
				System.out.print(m[tR][curC] + " ");
				curC++;
			}
			while (curR != dR) {
				System.out.print(m[curR][dC] + " ");
				curR++;
			}
			while (curC != tC) {
				System.out.print(m[dR][curC] + " ");
				curC--;
			}
			while (curR != tR) {
				System.out.print(m[curR][tC] + " ");
				curR--;
			}
		}
	}
```

3)原地旋转正方形矩阵，这个题只用几个有限的变量就可以实现了，就说每个数转90°的一个问题。这个题和上面的题类似。

```
	public static void rotate(int[][] matrix) {
		int a = 0;
		int b = 0;
		int c = matrix.length - 1;
		int d = matrix[0].length - 1;
		while (a < c) {
			rotateEdge(matrix, a++, b++, c--, d--);
		}
	}

	public static void rotateEdge(int[][] m, int a, int b, int c, int d) {
		int tmp = 0;
		for (int i = 0; i < d - b; i++) {
			tmp = m[a][b + i];
			m[a][b + i] = m[c - i][b];
			m[c - i][b] = m[c][d - i];
			m[c][d - i] = m[a + i][d];
			m[a + i][d] = tmp;
		}
	}

	public static void printMatrix(int[][] matrix) {
		for (int i = 0; i != matrix.length; i++) {
			for (int j = 0; j != matrix[0].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
	}
```



# 20221228数组累加和三连问题



在面试中最好准备的就是资源限制问题，就那几个，然后这里给列全了。

## 数组一连：最长子数组累加和问题

时间复杂度O(N),空间复杂度O(1)就行了，滑动窗口去做。

数组只有正，问哪个最长子数组正好为K

```
	public static int getMaxLength(int[] arr, int K) {
		if (arr == null || arr.length == 0 || K <= 0) {
			return 0;
		}
		int left = 0;
		int right = 0;
		int sum = arr[0];
		int len = 0;
		while (right < arr.length) {
			if (sum == K) {
				len = Math.max(len, right - left + 1);
				sum -= arr[left++];
			} else if (sum < K) {
				right++;
				if (right == arr.length) {
					break;
				}
				sum += arr[right];
			} else {
				sum -= arr[left++];
			}
		}
		return len;
	}
```



## 数组二连问题，arr有正，有负，有0，问哪个最长子数组正好等于K

解决子数组问题有两个常见的思路，

1. 以i位置结尾时答案是啥
2. 以i位置开头时答案是啥

对于1）的情况，假如说K=200，如果我知道[0...i]=1000，那么其实是想知道在哪有[0....j] = 800的，这个也是累加和为800最早出现的。那么直接$i-j$ 一减就有答案了。



这个题有个变种：

组有正负0，子数组只有在1和2含有的数量一样多时，才是达标的，在打表的里面找最长的。

做这个题，把非1 2的都变为0，然后把2变为-1，求最长的累加和为0的，就是了。

```
	public static int maxLength(int[] arr, int k) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		map.put(0, -1); // important
		int len = 0;
		int sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			if (map.containsKey(sum - k)) {
				len = Math.max(i - map.get(sum - k), len);
			}
			if (!map.containsKey(sum)) {
				map.put(sum, i);
			}
		}
		return len;
	}
```

## 数组三连问题 数组有正负0，所有小于等于k的累加和都是达标的子数组，求最长长度

之前老左以为这个最优解是O(NlogN)，然后有人想到了O(N)的方法。  这个题应该是superhard的难度，这个题可以通过优化可能性，来优化到O(n)的，凡是涉及到优化可能性的，都是超级难的。可能性舍弃其实也是来自单调性，比如我找到长答案了，短答案就可以舍弃到。 

```
	public static int maxLengthAwesome(int[] arr, int k) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] minSums = new int[arr.length];
		int[] minSumEnds = new int[arr.length];
		minSums[arr.length - 1] = arr[arr.length - 1];
		minSumEnds[arr.length - 1] = arr.length - 1;
		for (int i = arr.length - 2; i >= 0; i--) {
			if (minSums[i + 1] < 0) {
				minSums[i] = arr[i] + minSums[i + 1];
				minSumEnds[i] = minSumEnds[i + 1];
			} else {
				minSums[i] = arr[i];
				minSumEnds[i] = i;
			}
		}
		int end = 0;
		int sum = 0;
		int res = 0;
		// i是窗口的最左的位置，end扩出来的最右有效块儿的最后一个位置的，再下一个位置
		// end也是下一块儿的开始位置
		// 窗口：[i~end)
		for (int i = 0; i < arr.length; i++) {
			// while循环结束之后：
			// 1) 如果以i开头的情况下，累加和<=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；
			// 2) 如果以i开头的情况下，累加和<=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；
			while (end < arr.length && sum + minSums[end] <= k) {
				sum += minSums[end];
				end = minSumEnds[end] + 1;
			}
			res = Math.max(res, end - i);
			if (end > i) { // 窗口内还有数 [i~end) [4,4)
				sum -= arr[i];
			} else { // 窗口内已经没有数了，说明从i开头的所有子数组累加和都不可能<=k
				end = i + 1;
			}
		}
		return res;
	}
```



# 20221228 哈希函数有关的结构和岛问题



## 认识哈希函数

![image-20221228133650164](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228133650164-16722058115967.png)

4）是很难碰到的，极少碰到。5）的意思就说，如下图，如果说S是哈希函数输出的区域，然后方形是随便找的一个方形，这个方形随便去放，它里面的密度是一样的，就说均匀。这样的话有个推论，比如说In1经过哈希函数输出了out1，那么out1 % m,会变为0到M-1的一个数，然后如果其他的out2,out3他们也模m，那么这个结果会在0到m-1里面均匀分布.

![image-20221228134449868](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228134449868-16722062909928.png)

哈希碰撞：假如说对于n个不同的输入，S的返回值都是一样的，out1，那么我们就说这个out1的厚度是n;然后，**如果输入有无穷个，每个点的厚度，也是会均匀变高的。哈希没有一点的随机性。**

​	哈希表在使用时可以认为他的增删改查是O(1)的。哈希表开辟的空间会有扩容的操作，他扩容会从1到2到4到8.。。。等，N的数据量会扩容$log_2N$次，那么每次扩容的就是$1+2+4+....+\frac N4 + \frac N2$，这是一个能收敛到O（N）的等比数列，那么均摊下来的就是$O(N) / N = O(1)$的。



## 布隆过滤器

![image-20221228142014663](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228142014663-16722084155979.png)

类似于没有删除的黑名单系统。比如说，要实现一个100亿url，一个64字节，按理说得640G的内存，但是用布隆过滤器的话不到30G就能实现。  

​	关键的是选多少个哈希函数，以及位图的大小。K与样本数有关，而与单样本的大小无关，同时还需要知道一个预期失误率。如果面试问的话，自己可以问这么一句，预期失误率多少，他就知道你上道了，你就说这是布隆过滤器。预期失误率与m成反比，当N确定的时候。

![image-20221228150807596](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228150807596-167221128853410.png)

上面就是比较重要的公式。第二个公式是说，P和k有这样的一个关系：

![image-20221228151029731](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228151029731-167221143067311.png)

因为K太多的话，就会导致M被迅速描黑很多，这样就又有问题了。第三个公式是个真实的失误率，因为公式2需要取整，同时呢，真实的N和理论的N也有差距，所以有误差，要修正。

​	最后，还剩一个问题，怎么得到K个哈希函数？还要彼此独立的。其实只需要找两个哈希函数f g就行了，f + 1 * g,是一个哈希函数，然后f + 2 * g又是一个哈希函数。。。等等，直到f + k * g。

## 一致性哈希

![image-20221228165851030](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228165851030-167221793193812.png)

这个是google论文影响业内的3篇之一，影响服务器存储。一致性哈希可以做到系统迁移代价很低，并且也能做到负载均衡。系统迁移代价低的意思是，比如过年可能流量涨很多，但是不过年的话可能流量就低。

​	把哈希函数的返回值，比如说是是MDK5，想象为环，但是这个环的话他就不会是很均分的了。 如下图所示，如果说这个m1,m2,m3他们每个人管的一段上面是均分的，那么m1,m2,m3这三台机器就是负载均衡的。如果要把m1下线，只需要把m1的程序给M2,就是把自己的数据给到自己顺时针的下一个，那数据迁移就完成了，相同的道理，添加一个mk,也是只需要把顺时针的属于自己的域拿过来就行了。



![image-20221228172637077](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228172637077-167221959817413.png)



上面讲的这个东西，主要是业务用的吧。













# 20221228 解决资源限制类问题

==资源限制问题就这几个。==

![image-20221228194240163](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228194240163-167222776169415.png)

## 并行算法——岛问题

![image-20221228191336973](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228191336973-167222601796114.png)

如果是单CPU，单内核，做这个题,如果整个矩阵N*M的话，那countIslands1L其实一点复杂度都不高的，就是O(NM)，但是单核的话太慢了，如果MN太大的话。 countIslands2其实是并i行的算法，用并查集结合上面的过程，因为可能会出现连通性被打断的情况，所以要union。

```
	public static int countIslands1(int[][] m) {
		if (m == null || m[0] == null) {
			return 0;
		}
		int N = m.length;
		int M = m[0].length;
		int res = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (m[i][j] == 1) {
					res++;
					infect(m, i, j, N, M);
				}
			}
		}
		return res;
	}

	public static void infect(int[][] m, int i, int j, int N, int M) {
		if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
			return;
		}
		m[i][j] = 2;
		infect(m, i + 1, j, N, M);
		infect(m, i - 1, j, N, M);
		infect(m, i, j + 1, N, M);
		infect(m, i, j - 1, N, M);
	}

	public static class Element<V> {
		public V value;

		public Element(V value) {
			this.value = value;
		}

	}

	public static class UnionFindSet<V> {
		// a -> a 生成的点
		public HashMap<V, Element<V>> elementMap;
		public HashMap<Element<V>, Element<V>> fatherMap;
		// sizeMap中的key，每一个key都一定是集合的头节点（代表节点）
		public HashMap<Element<V>, Integer> sizeMap;

		public UnionFindSet(List<V> list) {
			elementMap = new HashMap<>();
			fatherMap = new HashMap<>();
			sizeMap = new HashMap<>();
			for (V value : list) {
				Element<V> element = new Element<V>(value);
				elementMap.put(value, element);
				fatherMap.put(element, element);
				sizeMap.put(element, 1);
			}
		}

		// 从输入参数element出发，往上一直找，找到不能再往上的头节点，返回
		private Element<V> findHead(Element<V> element) {
			// 把往上找的过程中，沿途的点都记录在path里
			Stack<Element<V>> path = new Stack<>();
			while (element != fatherMap.get(element)) {
				path.push(element);
				element = fatherMap.get(element);
			}
			while (!path.isEmpty()) {
				fatherMap.put(path.pop(), element);
			}
			return element;
		}

		public boolean isSameSet(V a, V b) {
			if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
				return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
			}
			return false;
		}

		public void union(V a, V b) {
			if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
				Element<V> aF = findHead(elementMap.get(a));
				Element<V> bF = findHead(elementMap.get(b));
				if (aF != bF) {
					Element<V> big = sizeMap.get(aF) >= sizeMap.get(bF) ? aF : bF;
					Element<V> small = big == aF ? bF : aF;
					fatherMap.put(small, big);
					sizeMap.put(big, sizeMap.get(aF) + sizeMap.get(bF));
					sizeMap.remove(small);
				}
			}
		}

		public int getSetNum() {
			return sizeMap.size();
		}

	}

	public static int countIslands2(int[][] m) {
		List<String> list = new ArrayList<>();
		for (int row = 0; row < m.length; row++) {
			for (int col = 0; col < m[0].length; col++) {
				if (m[row][col] == 1) {
					String position = String.valueOf(row) + "_" + String.valueOf(col);
					list.add(position);
				}
			}
		}
		UnionFindSet<String> unionSet = new UnionFindSet<>(list);
		for (int row = 0; row < m.length; row++) {
			for (int col = 0; col < m[0].length; col++) {
				if (m[row][col] == 1) {
					// row,col 5, 3 -> 5_3
					String position = String.valueOf(row) + "_" + String.valueOf(col);
					if (row - 1 >= 0 && m[row - 1][col] == 1) {
						String up = String.valueOf(row - 1) + "_" + String.valueOf(col);
						unionSet.union(up, position);
					}
					if (col - 1 >= 0 && m[row][col - 1] == 1) {
						String left = String.valueOf(row) + "_" + String.valueOf(col - 1);
						unionSet.union(left, position);
					}
				}
			}
		}
		return unionSet.getSetNum();
	}
```



## 资源限制——找到未出现过的数

![image-20221228194337113](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228194337113-167222781793016.png)

位图去做。用一个bit去表示数字出现过还是没出现过，这就可以完成1G的情况。

​	对于10MB和3KB的情况，因为只用找到一个没有出现过的数，比如说3KB吧，可以算出来他能做一个int[750]的数组，然后找离750最近的2的某次方，就是9，如果把数组定为int[512]也是不超过资源限制的，并且我也知道2^32次方一定能被512，也就是被2的某次方均分，也就是$ 2^32 / 512 = 8388608$,那么每一个int[i]就表示$8388608(i-1) ~ i * 8388608$这个范围出现了几个，必然会找到至少一个是不满的，就是$int[i] !=8388608$,那就再对它进行细分512分，一直这么分，就能找的到。

​	三个变量的话，就是二分。其实需要四个变量，L,M,R，还有一个词频统计的变量。

## 资源限制——找到所有出现了两次的数

![image-20221228195013616](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221228195013616-167222821499417.png)

还是位图去做，用两个bit去表示，这就多了一个次数信息了可以,00表示出现0次，01表示1次，10表示2次，11表示三次及以上

## 资源限制——所有重复URL和TOP100词汇

![image-20221229081906326](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229081906326-16722731475231.png)



**这个题故意说的不清楚，所以要问问面试官，就是考察declear问题的能力**。然后会需要多线程多核去做，会效果好点。第一次用一个哈希函数分机器，第二次用另外一个哈希函数分文件。

​	对于这个补充问题，就是先分机器，然后再分小文件，然后统计小文件里面的top100，最后再这个每个小文件的top100PK出最终的top100，然后再pk所有机器的top100，就是用外派的方法，然后就是可以用的是二维堆的方式，会快点。比如说文件一用大根堆存放，文件二、三。。。都是大根堆存放，然后再用这每个堆顶，再去组大根堆，如图，因为这个zt92是最大的，所以他会被选出来，然后60就会进去，一进去，因为他不是最大的，他就会和fct交换位置。



![image-20221229101317987](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229101317987-16722799990842.png)



## 资源限制——找中位数

![image-20221229101626944](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229101626944-16722801877853.png)

这个题和上面的 找到未出现过的数 类似。



## 资源限制——数字排序的结果

![image-20221229102945044](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229102945044-16722809858655.png)



内存用小根堆组织，如图，假如只有两条记录。进过这么一个遍历后，小根堆会放最大的两个数，以及他出现的次数，然后重复这个行为，但是记录一下上次的第二大的，那么在这次做的时候就不考虑比上次第二大的还要大的并且等于的。做词频统计，会有压缩的效果。不过这个题给了5G的空间，还是很快的。然后读文件这个内存占用其实很少的，只需要维持一个偏移量就好了。

​	估算空间：小根堆是个数组，一个记录8字节，map的话一个key-value是8字节，那么就是16字节，看5G / 16就差不多了，再保守一点还可以再除一个10.

![image-20221229103422809](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229103422809-16722812640676.png)



# 20221229 有序表问题1

## 搜索二叉树

定义：任何一个节点，头大于左节点，小于右节点，可以再在节点加上一个项，来统计重复次。

![image-20221229105037246](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221229105037246-16722822381537.png)





经典搜索二叉树是没有重复值的叠加，因为会影响平衡性，如果要给他变平衡的话。搜索二叉树的增删改查都不太容易，其实主要是增删查吧。查的话，就是小的往左滑，大的话往右子树上滑，如果滑到空就是没有。增的话，就是也是一直滑，滑到空了那就加上。删就不一样了，首先要找到，如果没找到就不用删，对吧。如果找到了，有几种情况，1）这个节点没有左右孩子，那就直接删就行。2）有左孩子没有右孩子，把左孩子拔上来，把这个删了。3）有右孩子没有左孩子，那就把右孩子拔上来，然后把这个删了。4）如果既有左又有右，那就有点复杂，需要用后继节点去替换这个节点，后继节点是他右孩子的最左节点，用他替换这个节点，如果这个后继节点有右孩子（肯定是没左孩子，不然他就不是最左节点了），那就把这个后继节点的右孩子替换掉他现在的位置，就是做他父节点的左孩子。

​	这个代码有几行还是比较麻烦的。他的这个node多了一个指向父节点的指针，在上移的过程会有帮助。delete会比较复杂，考虑了两个情况。

```
/**
 * Not implemented by zuochengyun
 * 
 * Abstract binary search tree implementation. Its basically fully implemented
 * binary search tree, just template method is provided for creating Node (other
 * trees can have slightly different nodes with more info). This way some code
 * from standart binary search tree can be reused for other kinds of binary
 * trees.
 * 
 * @author Ignas Lelys
 * @created Jun 29, 2011
 * 
 */
public class AbstractBinarySearchTree {

	/** Root node where whole tree starts. */
	public Node root;

	/** Tree size. */
	protected int size;

	/**
	 * Because this is abstract class and various trees have different
	 * additional information on different nodes subclasses uses this abstract
	 * method to create nodes (maybe of class {@link Node} or maybe some
	 * different node sub class).
	 * 
	 * @param value
	 *            Value that node will have.
	 * @param parent
	 *            Node's parent.
	 * @param left
	 *            Node's left child.
	 * @param right
	 *            Node's right child.
	 * @return Created node instance.
	 */
	protected Node createNode(int value, Node parent, Node left, Node right) {
		return new Node(value, parent, left, right);
	}

	/**
	 * Finds a node with concrete value. If it is not found then null is
	 * returned.
	 * 
	 * @param element
	 *            Element value.
	 * @return Node with value provided, or null if not found.
	 */
	public Node search(int element) {
		Node node = root;
		while (node != null && node.value != null && node.value != element) {
			if (element < node.value) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return node;
	}

	/**
	 * Insert new element to tree.
	 * 
	 * @param element
	 *            Element to insert.
	 */
	public Node insert(int element) {
		if (root == null) {
			root = createNode(element, null, null, null);
			size++;
			return root;
		}

		Node insertParentNode = null;
		Node searchTempNode = root;
		while (searchTempNode != null && searchTempNode.value != null) {
			insertParentNode = searchTempNode;
			if (element < searchTempNode.value) {
				searchTempNode = searchTempNode.left;
			} else {
				searchTempNode = searchTempNode.right;
			}
		}

		Node newNode = createNode(element, insertParentNode, null, null);
		if (insertParentNode.value > newNode.value) {
			insertParentNode.left = newNode;
		} else {
			insertParentNode.right = newNode;
		}

		size++;
		return newNode;
	}

	/**
	 * Removes element if node with such value exists.
	 * 
	 * @param element
	 *            Element value to remove.
	 * 
	 * @return New node that is in place of deleted node. Or null if element for
	 *         delete was not found.
	 */
	public Node delete(int element) {
		Node deleteNode = search(element);
		if (deleteNode != null) {
			return delete(deleteNode);
		} else {
			return null;
		}
	}

	/**
	 * Delete logic when node is already found.
	 * 
	 * @param deleteNode
	 *            Node that needs to be deleted.
	 * 
	 * @return New node that is in place of deleted node. Or null if element for
	 *         delete was not found.
	 */
	protected Node delete(Node deleteNode) {
		if (deleteNode != null) {
			Node nodeToReturn = null;
			if (deleteNode != null) {
				if (deleteNode.left == null) {
					// transplant(a,b)  b去替换a的环境，a断连掉，把b返回
					nodeToReturn = transplant(deleteNode, deleteNode.right);
				} else if (deleteNode.right == null) {
					nodeToReturn = transplant(deleteNode, deleteNode.left);
				} else {
					Node successorNode = getMinimum(deleteNode.right);
					if (successorNode.parent != deleteNode) {
						transplant(successorNode, successorNode.right);
						successorNode.right = deleteNode.right;
						successorNode.right.parent = successorNode;
					}
					transplant(deleteNode, successorNode);
					successorNode.left = deleteNode.left;
					successorNode.left.parent = successorNode;
					nodeToReturn = successorNode;
				}
				size--;
			}
			return nodeToReturn;
		}
		return null;
	}

	/**
	 * Put one node from tree (newNode) to the place of another (nodeToReplace).
	 * 
	 * @param nodeToReplace
	 *            Node which is replaced by newNode and removed from tree.
	 * @param newNode
	 *            New node.
	 * 
	 * @return New replaced node.
	 */
	private Node transplant(Node nodeToReplace, Node newNode) {
		if (nodeToReplace.parent == null) {
			this.root = newNode;
		} else if (nodeToReplace == nodeToReplace.parent.left) {
			nodeToReplace.parent.left = newNode;
		} else {
			nodeToReplace.parent.right = newNode;
		}
		if (newNode != null) {
			newNode.parent = nodeToReplace.parent;
		}
		return newNode;
	}

	/**
	 * @param element
	 * @return true if tree contains element.
	 */
	public boolean contains(int element) {
		return search(element) != null;
	}

	/**
	 * @return Minimum element in tree.
	 */
	public int getMinimum() {
		return getMinimum(root).value;
	}

	/**
	 * @return Maximum element in tree.
	 */
	public int getMaximum() {
		return getMaximum(root).value;
	}

	/**
	 * Get next element element who is bigger than provided element.
	 * 
	 * @param element
	 *            Element for whom descendand element is searched
	 * @return Successor value.
	 */
	// TODO Predecessor
	public int getSuccessor(int element) {
		return getSuccessor(search(element)).value;
	}

	/**
	 * @return Number of elements in the tree.
	 */
	public int getSize() {
		return size;
	}

	/**
	 * Tree traversal with printing element values. In order method.
	 */
	public void printTreeInOrder() {
		printTreeInOrder(root);
	}

	/**
	 * Tree traversal with printing element values. Pre order method.
	 */
	public void printTreePreOrder() {
		printTreePreOrder(root);
	}

	/**
	 * Tree traversal with printing element values. Post order method.
	 */
	public void printTreePostOrder() {
		printTreePostOrder(root);
	}

	/*-------------------PRIVATE HELPER METHODS-------------------*/

	private void printTreeInOrder(Node entry) {
		if (entry != null) {
			printTreeInOrder(entry.left);
			if (entry.value != null) {
				System.out.println(entry.value);
			}
			printTreeInOrder(entry.right);
		}
	}

	private void printTreePreOrder(Node entry) {
		if (entry != null) {
			if (entry.value != null) {
				System.out.println(entry.value);
			}
			printTreeInOrder(entry.left);
			printTreeInOrder(entry.right);
		}
	}

	private void printTreePostOrder(Node entry) {
		if (entry != null) {
			printTreeInOrder(entry.left);
			printTreeInOrder(entry.right);
			if (entry.value != null) {
				System.out.println(entry.value);
			}
		}
	}

	protected Node getMinimum(Node node) {
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}

	protected Node getMaximum(Node node) {
		while (node.right != null) {
			node = node.right;
		}
		return node;
	}

	protected Node getSuccessor(Node node) {
		// if there is right branch, then successor is leftmost node of that
		// subtree
		if (node.right != null) {
			return getMinimum(node.right);
		} else { // otherwise it is a lowest ancestor whose left child is also
			// ancestor of node
			Node currentNode = node;
			Node parentNode = node.parent;
			while (parentNode != null && currentNode == parentNode.right) {
				// go up until we find parent that currentNode is not in right
				// subtree.
				currentNode = parentNode;
				parentNode = parentNode.parent;
			}
			return parentNode;
		}
	}

	// -------------------------------- TREE PRINTING
	// ------------------------------------

	public void printTree() {
		printSubtree(root);
	}

	public void printSubtree(Node node) {
		if (node.right != null) {
			printTree(node.right, true, "");
		}
		printNodeValue(node);
		if (node.left != null) {
			printTree(node.left, false, "");
		}
	}

	private void printNodeValue(Node node) {
		if (node.value == null) {
			System.out.print("<null>");
		} else {
			System.out.print(node.value.toString());
		}
		System.out.println();
	}

	private void printTree(Node node, boolean isRight, String indent) {
		if (node.right != null) {
			printTree(node.right, true, indent + (isRight ? "        " : " |      "));
		}
		System.out.print(indent);
		if (isRight) {
			System.out.print(" /");
		} else {
			System.out.print(" \\");
		}
		System.out.print("----- ");
		printNodeValue(node);
		if (node.left != null) {
			printTree(node.left, false, indent + (isRight ? " |      " : "        "));
		}
	}

	public static class Node {
		public Node(Integer value, Node parent, Node left, Node right) {
			super();
			this.value = value;
			this.parent = parent;
			this.left = left;
			this.right = right;
		}

		public Integer value;
		public Node parent;
		public Node left;
		public Node right;

		public boolean isLeaf() {
			return left == null && right == null;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Node other = (Node) obj;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}

	}
}
```

## 平衡二叉树

​	裸的搜索二叉树有一个最大的问题，就是输入的状况决定性能，就是说，如果输入的数据很好，那么搜索二叉树就会平衡性，**所以我们会加入一个自平衡的机制，他就是O(logN)的做自平衡的时候，接下来会就讲其中一个，因为AVL树有很多**，还有一个问题就是，裸的搜索二叉树他的添加、删除的时候不照顾平衡性。



### 1）左旋

对谁左旋，就是往左边倒，那就是右孩子会上来。





### 2）右旋

​	对谁右旋，就是往右边倒，那就是左孩子会上来。右旋有个好处，就是可以给左边弄的有点平衡。



有序表的所有操作，都是O(logN)的性能。 用AVL,SB树，红黑树实现有序表几乎没有差别，只有常数上的差别。

​	AVL任何有个头，左树高度减去右树高度的绝对值，小于2  .SB树的话，是叔叔节点都要保证他的子节点节点数不小于他的侄子节点的节点数，也是具有平衡性的。



​	红黑树的话，1）节点不是红就是黑，2）头结点是黑，叶节点也是黑，3）红节点的子一定是黑节点，这一点很关键，会保证平衡性（说明红节点不会相邻）。4）从任何一个节点到他的每一个子，所有路径上黑节点的数量一样多。

​	AVL,SB,红黑树都是用左旋和右旋实现的有序表，不过就是实现的细节有不同。

​	**AVL,SB,红黑树查哪些节点需要调平衡，一回事，只是具体到某个节点发现不平的动作不一样，但受影响的节点有哪些他们都是一样的。**

​	AVL,SB,红黑树都是从加节点那个位置往上撸一条链，删除的时候他们没有区别，只是具体到一个节点的时候动作不一样

​	首先考虑AVL树的情况，从受影响节点开始，走过一条链，走到具体某个节点的时候，怎么查平衡性，只有左右旋这两个动作，他有4种违规情况，LL,LR,RL,RR，有一个结论就是他只会出现一种违规的情况在插入过程的时候（不过删除可能会出现同时违规，不过也是只做一次就行了）。如果一个节点 左树的高度 - 右树的高度的绝对值，没有超过2，那就是不违规；如果这个高度差，是大于1的，就说明左右子树不平衡，就会中LR性或者RL性，（左树高的话，那他就是LR性的，右树高的话，就是RL型。因为左边的左边不平的，就是LL型，因为左边的右边不平的，就是LR型。  如果是LL型，那就做一个右旋；如果是RR型，那就是做一个左旋。LR,RL的话他俩是一对，对于这两种情况的话，就是把底下的孙节点上到顶部来，就是对他做一个左旋+右旋，或者是右旋+左旋的操作，做一次旋转的话可能平不了，旋转两次怎么旋，主要是怎么让孙子上到顶就怎么旋。另外一点，就是在删除的时候，有可能会有LL,LR区分不了，那么做那个都行

​	对于LL,LR,RL,RR调整平衡性，每个节点都只是O（1）的代价，即便从这个节点到上面的每个节点都需要调整，那么也只是O(logN)的。这个代码的实现上有点意思。AbstractBinarySearchTree.java的代码，是训练营2的class6里，不过好像也不是。。应该不是这个，这个代码好像没提供讲的。

​	对于SB树，如果节点X的左孩子不如右节点的子节点个数多，那就是RL型。如果X的左孩子不如右孩子的右节点个数多，那就是RR型，同理LL,LR。如下图，比如第一行的意思就是，X的右节点的左孩子大于X的左孩子，是RL型。

![image-20221230163729395](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221230163729395-16723894505241.png)

 	然后，比如说LL的情况，那就右旋X， 还有其他的操作吧。这个过程是O（1）的，不证明了。   

​	比赛的时候，很多人喜欢用SB去改有序表，因为他的递归行为。高手在删除的时候不做平衡性调整，只在add调整，这样的话均摊下来一定很快，O（logN).

​	任何一个递归行为，都可以改为迭代，迭代最优与递归相比。



## 跳表

跳表可以实现有序表的功能，并且他的性能也是O(logN)，他不是用的树去做的。跳表最左端的节点是弃而不用的。一开始这个节点只有一条往外指的指针，然后来了一个key-val比如说是"3,abc",那么他有多少个指针，完全靠扔骰子决定 ，然后这是经典的实现的方法，现在的产品的话会固定死。  

​	跳表如下图， 一般的，会有N个节点有1层，N/2个节点有两层，N/3个节点有3层。。。这个O(logN)是完全跟输入没有关系的。有点像快排，虽然是随机出来的数，但是期望是这个。跳表的代码在训练营2期class06的skipListMap的代码。

![image-20221230191218031](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221230191218031-16723987395562.png)



​	==在面试的时候真的会让写跳表这个结构的代码==

​	lastKey的是logN.

​	SB树实现的有序表可以找第500小比如，需要自己改一下结构，不能去直接用系统提供的。



## 红黑树

​	红黑树的话，1）节点不是红就是黑，2）头结点是黑，叶节点也是黑，3）红节点的子一定是黑节点，这一点很关键，会保证平衡性（说明红节点不会相邻）。4）从任何一个节点到他的每一个子，所有路径上黑节点的数量一样多。5）在最悬殊的情况下，从一个节点出发，最长的链和最短的链他们的黑节点也是一样多的，比如长的是XOXOXO,短的是XXX，就是这种最特殊的情况，长的链也不会是最短链的两倍以上。

​	红黑树本质上还是搜索二叉树，