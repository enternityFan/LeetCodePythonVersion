# 1.滑动窗口

1. 滑动窗口是一种想象出来的数据结构
2. 滑动窗口有左边界L和右边界R
3. 在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
4. L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
5. L和R只能往右滑
6. L<=R 

## 窗口内最大值的更新结构

* R往右走，是R++，新数右侧进
* L往右走，是L++，老数左侧出
* 要保证L《=R

可以通过 **单调双端队列来实现**,我们要保证双端队列从头部到尾部是从大到小变化的（不相等）。这样的话，双端队列头部的数就是当前窗口的最大值。

对于维持窗口最小值的更新结构，只需要保持双端队列是单调递减就行。

时间复杂度O(N)

## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```
	public static int[] getMaxWindow(int[] arr, int w) {
		if (arr == null || w < 1 || arr.length < w) {
			return null;
		}
		// 其中放的是位置，头代表 （大->小）尾
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int[] res = new int[arr.length - w + 1];
		int index = 0;
		// L...R
		//     i
		for (int R = 0; R < arr.length; R++) { // 当前让 i -> [i] 进窗口 ， i 就是 r
			// R -> 值  可以放在比他大的数后，或者空
			while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[R]) {
				qmax.pollLast();
			}
			qmax.addLast(R);
			// 数进来了
			// 如果窗口没有形成W的长度之前，不弹出数字的
			if (qmax.peekFirst() == R - w) {
				qmax.pollFirst();
			}
			// 以上窗口更新做完了
			if (R >= w - 1) {
				res[index++] = arr[qmax.peekFirst()];
			}
		}
		return res;
	}
```



## 达标子数组数量

给定一个整型数组arr,和一个整数num，某个arr中的子数组sub，如果想达标，必须满足：sub中最大值-sub中最小值<=num,返回arr中达标子数组的数量

==子数组是必须连续的==

 如果，arr[L...R]是达标子数组，那么arr[L..R]的任意一个子数组也一定达标。

```
public static int getNum(int[] arr, int num) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		LinkedList<Integer> qmin = new LinkedList<Integer>();
		LinkedList<Integer> qmax = new LinkedList<Integer>();
		int L = 0;
		int R = 0;
		// [L..R) -> [0,0) 窗口内无数 [1,1),也就是说R位置是违规的位置，是本来的R的下一个的位置。
		// [0,1) -> [0~0]
		int res = 0;
		while (L < arr.length) { // L是开头位置，尝试每一个开头

			// 如果此时窗口的开头是L,下面的while工作:R向右扩到违规为止

			while (R < arr.length) { // R是最后一个达标位置的再下一个
				while (!qmin.isEmpty() && arr[qmin.peekLast()] >= arr[R]) {
					qmin.pollLast();
				}
				qmin.addLast(R);
				// R -> arr[R],
				while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[R]) {
					qmax.pollLast();
				}
				qmax.addLast(R);

				if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) {
					break;
				}
				R++;
			}

			// R是最后一个达标位置的再下一个，第一个违规的位置
			res += R - L;

			if (qmin.peekFirst() == L) {
				qmin.pollFirst();
			}
			if (qmax.peekFirst() == L) {
				qmax.pollFirst();
			}

			L++;

		}
		return res;
	}
```

遇到一个问题的时候，可以好好看看问题能不能建立单调性和范围，能建立后就可以用首尾指针法或者滑动窗口法。



# 2.单调栈

给一个数组nums=[3,2,1,7,0,4,5,6],需要得到一个map数组，他的第i位置存储的是他他左边比他小的最近的数的位置和右边比他小的最近的数的位置。如果用暴力的方法的话O（N^2),单调栈的话可以让整体O（N）。这时单调栈中栈底到栈顶存放的是从小到大的一个顺序；而如果是要左右边比他大的最近的数的位置的话，单调栈存放的应该是从大到小的一个顺序。如果当前入栈的比栈顶大，那么就开始记录栈顶值的左右离他最小的，当前入栈的值就是他右边最近最小的，栈顶下面的值就是他左边离他最小的。如果值相等，那么栈中这一层就把这个下标也给添加进去。

```
	public static int[][] getNearLessNoRepeat(int[] arr) {
		int[][] res = new int[arr.length][2];
		Stack<Integer> stack = new Stack<>();
		for (int i = 0; i < arr.length; i++) {
			while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
				int popIndex = stack.pop();
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
				res[popIndex][0] = leftLessIndex;
				res[popIndex][1] = i;
			}
			stack.push(i);
		}
		while (!stack.isEmpty()) {
			int popIndex = stack.pop();
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
			res[popIndex][0] = leftLessIndex;
			res[popIndex][1] = -1;
		}
		return res;
	}

	// arr [3, 2, 1, 4, 5]
	//      0  1  2  3  4
	
	//  [
	//    0 :  [-1,  1  ]
	//    1 :  [-1,  2  ]
	
	//  ] 
	//
	public static int[][] getNearLess(int[] arr) {
		int[][] res = new int[arr.length][2];
		
		
		// List<Integer> -> 放的是位置，同样值的东西，位置压在一起
		// 代表值    底  ->  顶   小  -> 大
		Stack<List<Integer>> stack = new Stack<>();
		for (int i = 0; i < arr.length; i++) { // i -> arr[i] 进栈
			// 底 -> 顶， 小 -> 大
			while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
				List<Integer> popIs = stack.pop();
				// 取位于下面位置的列表中，最晚加入的那个
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
				for (Integer popi : popIs) {
					res[popi][0] = leftLessIndex;
					res[popi][1] = i;
				}
			}
			// 相等的、比你小的
			if (!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]) {
				stack.peek().add(Integer.valueOf(i));
			} else {
				ArrayList<Integer> list = new ArrayList<>();
				list.add(i);
				stack.push(list);
			}
		}
		while (!stack.isEmpty()) {
			List<Integer> popIs = stack.pop();
			// 取位于下面位置的列表中，最晚加入的那个
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
			for (Integer popi : popIs) {
				res[popi][0] = leftLessIndex;
				res[popi][1] = -1;
			}
		}
		return res;
	}
```

## 子数组的累加和乘以最小值







```
```



# 类似斐波那契数列（严格的，没有条件转移的）

严格的没有条件转移的，就是没有条件，比如如果代码是如果str[i]=='1'，那么怎么转移，如果str[i] == '2',那么怎么转移，这就是有条件转移的。

## 马走日（这个不是类似斐波那契数列的题）

棋盘10*9的大小，马从(0,0)开始走，给定一个目标点（x,y)和要走的步数K，求有多少种方案可以走到

```
	public static int ways1(int x, int y, int k) {
		return f(x, y, k);
	}

	// 马从(0,0)出发，有K步要走，并且一定要走完，最终来到x，y位置的方法数是多少
	public static int f(int x, int y, int k) {
		if (k == 0) {
			return x == 0 && y == 0 ? 1 : 0;
		}
		if (x < 0 || x > 9 || y < 0 || y > 8) {
			return 0;
		}
		// 有步数要走, x，y 也是棋盘上的位置
		return f(x + 2, y - 1, k - 1) + f(x + 2, y + 1, k - 1) + f(x + 1, y + 2, k - 1) + f(x - 1, y + 2, k - 1)
				+ f(x - 2, y + 1, k - 1) + f(x - 2, y - 1, k - 1) + f(x - 1, y - 2, k - 1) + f(x + 1, y - 2, k - 1);
	}

	public static int ways2(int x, int y, int k) {
		int[][][] dp = new int[10][9][k + 1];// 0~k

		dp[0][0][0] = 1; // dp[..][..][0] = 0

		for (int level = 1; level <= k; level++) {
			// level层，x y
			for (int i = 0; i < 10; i++) { // x可能性
				for (int j = 0; j < 9; j++) { // y的可能性
					dp[i][j][level] = getValue(dp, i + 2, j - 1, level - 1) + getValue(dp, i + 2, j + 1, level - 1)
							+ getValue(dp, i + 1, j + 2, level - 1) + getValue(dp, i - 1, j + 2, level - 1)
							+ getValue(dp, i - 2, j + 1, level - 1) + getValue(dp, i - 2, j - 1, level - 1)
							+ getValue(dp, i - 1, j - 2, level - 1) + getValue(dp, i + 1, j - 2, level - 1);
				}
			}
		}

		return dp[x][y][k];
	}

	public static int getValue(int[][][] dp, int x, int y, int k) {
		if (x < 0 || x > 9 || y < 0 || y > 8) {
			return 0;
		}
		return dp[x][y][k];
	}
	
	
	public static int ways3(int x, int y, int k) {
		return p(0,0,k,x,y);
	}
	
	// 当前来到row，col位置，还剩rest步，走完rest步之后，来到x，y位置，方法数多少
	public static int p(int row, int col, int rest, int x, int y) {
		if(rest == 0) {
			return row == x && col == y ? 1 :0;
		}
		
		if (row < 0 || row > 9 || col < 0 || col > 8) {
			return 0;
		}
		
		return p(row + 2, col - 1, rest - 1, x, y) 
				+ p(row + 2, col + 1, rest - 1, x, y) 
				+ p(row + 1, col + 2, rest - 1, x, y) 
				+ p(row - 1, col + 2, rest - 1, x, y)
				+ p(row - 2, col + 1, rest - 1, x, y) 
				+ p(row - 2, col - 1, rest - 1, x, y) 
				+ p(row - 1, col - 2, rest - 1, x, y) 
				+ p(row + 1, col - 2, rest - 1, x, y);
		
	}
	
	
	
	
	
	

	public static void main(String[] args) {
		int x = 6;
		int y = 8;
		int k = 10;
		System.out.println(ways1(x, y, k));
		System.out.println(ways2(x, y, k));
		System.out.println(ways3(x, y, k));

	}
```



## 快速幂

与简单的幂相比，时间复杂度是$log_2N$

### 一个数的平方怎么算的快？

比如要算$10^{75}$,把75拆分为二进制：75=1001011，通过一个变量来记录10的1次方，2次方，4次方。。。。64次方，然后用变量res来算最终的结果，则$10=1* 10^1 * 10^2 * 10^4 * 10^8$就得到了结果，很快速。math.power中对于整数方就是这么实现的。

```
		int res = 1;

		
		// res = 矩阵中的1,p为1001011，就是幂的二进制表示
		int tmp = 10;
		for (; p != 0; p >>= 1) {
			if ((p & 1) != 0) {
				res = tmp * res;
			}
			tmp = tmp * tmp;
		}
```



### 一个矩阵怎么平方快？

和上面是一样的，下面的代码f3是累乘斐波那列数列的代码，其中就有矩阵相乘的地方。f1,f2是普通的解。

s1,s2,s3是针对推广：计算F(n) = c1F(n-1)  + c2F(n-2) +...+ czF(n-k),c1,c2,cz为常数，k也为常数，都有logN的解。

举个例子，比如农场第一年有一个母牛，母牛都不会死，并且每个母牛每年都会生1个母牛，小母牛到第三年会开始生母牛，问第N年有多少牛

对于这个问题，就是个三阶的问题：F（N） = 1*F（N-1）+0 *F（N-2） + 1 * F（N-3），因为最后减的是3，所以是三阶的问题。因为是三阶问题，所以可以得到：
$$
F(n) * F(n-1) * F(n-2) * F(n-3) = det|F3 F2 F1| * (3*3矩阵)^{n-3}
$$
注意这个公式跟c1,c2,ck的值无关的，只要是这个形式就可以这么算。



```
	public static int f1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		return f1(n - 1) + f1(n - 2);
	}

	public static int f2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		int res = 1;
		int pre = 1;
		int tmp = 0;
		for (int i = 3; i <= n; i++) {
			tmp = res;
			res = res + pre;
			pre = tmp;
		}
		return res;
	}

	public static int f3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		// [ 1 ,1 ]
		// [ 1, 0 ]
		int[][] base = { 
				{ 1, 1 }, 
				{ 1, 0 } 
				};
		int[][] res = matrixPower(base, n - 2);
		return res[0][0] + res[1][0];
	}

	public static int[][] matrixPower(int[][] m, int p) {
		int[][] res = new int[m.length][m[0].length];
		for (int i = 0; i < res.length; i++) {
			res[i][i] = 1;//制作单位矩阵
		}
		
		// res = 矩阵中的1
		int[][] tmp = m;// 矩阵1次方
		for (; p != 0; p >>= 1) {
			if ((p & 1) != 0) {
				res = muliMatrix(res, tmp);
			}
			tmp = muliMatrix(tmp, tmp);
		}
		return res;
	}

	// 两个矩阵乘完之后的结果返回
	public static int[][] muliMatrix(int[][] m1, int[][] m2) {
		int[][] res = new int[m1.length][m2[0].length];
		for (int i = 0; i < m1.length; i++) {
			for (int j = 0; j < m2[0].length; j++) {
				for (int k = 0; k < m2.length; k++) {
					res[i][j] += m1[i][k] * m2[k][j];
				}
			}
		}
		return res;
	}

	public static int s1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		return s1(n - 1) + s1(n - 2);
	}

	public static int s2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		int res = 2;
		int pre = 1;
		int tmp = 0;
		for (int i = 3; i <= n; i++) {
			tmp = res;
			res = res + pre;
			pre = tmp;
		}
		return res;
	}

	public static int s3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return n;
		}
		int[][] base = { { 1, 1 }, { 1, 0 } };
		int[][] res = matrixPower(base, n - 2);
		return 2 * res[0][0] + res[1][0];
	}

	public static int c1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		return c1(n - 1) + c1(n - 3);
	}

	public static int c2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int res = 3;
		int pre = 2;
		int prepre = 1;
		int tmp1 = 0;
		int tmp2 = 0;
		for (int i = 4; i <= n; i++) {
			tmp1 = res;
			tmp2 = pre;
			res = res + prepre;
			pre = tmp1;
			prepre = tmp2;
		}
		return res;
	}

	public static int c3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int[][] base = { 
				{ 1, 1, 0 }, 
				{ 0, 0, 1 }, 
				{ 1, 0, 0 } };
		int[][] res = matrixPower(base, n - 3);
		return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
	}

	public static void main(String[] args) {
		int n = 19;
		System.out.println(f1(n));
		System.out.println(f2(n));
		System.out.println(f3(n));
		System.out.println("===");

		System.out.println(s1(n));
		System.out.println(s2(n));
		System.out.println(s3(n));
		System.out.println("===");

		System.out.println(c1(n));
		System.out.println(c2(n));
		System.out.println(c3(n));
		System.out.println("===");

	}
```

## 达标数列

给定一个数N，想象只由O和1两种字符，组成的所有长度为N的字符串如果某个字符串,任何O字符的左边都有1紧挨着,认为这个字符串达标返回有多少达标的字符串。

解题思路：如果N=1，那么只有“0”，“1”这两种情况，其中“1”是达标的，如果N=2，那么"10","11"是达标的。不用暴力试，因为时间复杂度O（2^N*N),太大了。做递归，f(i)表示i个长度的达标数量，**此时假设这i个长度的左边一定有一个1存在**，那么f(8)的计算要去找f(7)，因为左边有个1.如下图，如果第一个位置填1，那么要求f(i-1)的值，如果填0，那么求f(i-2)的值（因为0下面必须是1，根据我们f(i)的假设），这是属于从左到右的尝试模型。

![image-20221018181530736](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221018181530736-16660881322991.png)

## 瓷砖方案

对于2*N的墙，用1 * 2的瓷砖，请问填满有多少方案？

解题思路：F（N）表示还有N列没有填满，那么瓷砖如果竖着摆，那么就还有F（N-1）的情况；如果瓷砖横着摆，就还有F（N-2）的情况，则F（N） = F（N-1） + F（N—2）



## 机器吐球

假如有一个机器一直源源不断的吐球，1号，2号。。。n号。我只有一个能装下10个球的袋子，我可以选择入袋或者扔掉，如果扔掉那么就一定找不到了，如果机器吐出n个球，我要保证每个球被选中的概率为10/n，是均等的，如何做？

解题思路：设计一个函数f(i),可以返回等概率的，1到i的任意一个数字 ；对于1号球到10号球，没有决策过程，都入袋，但是大于10号时，每个球出来时以10/k的概率看要不要他，如果要，就一定入袋，然后球袋里的十个球等概率扔一个。



# 7 线段树（区间修改树）

线段树解决的问题是，当需要区间的修改或者更新或者查询一些东西，怎么比较快。

比如一个场景：有一个数组arr[1001] = [3,7,6,4,-2,.....]，做一个线段树，提供三个接口一个是add方法，让L到R的范围都加一个V的值；第二个方法是从L到R的方法，让所有的数字都变成V；第三个方法得到L和R的累加和。**线段树的指标是上述的三个方法的速度都达到logN的水平**。

* 如果数组的长度N不是2的幂，那么需要准备4*N的空间，不然的话2N的空间就够用了，所以综上所述，一般来说要4N的空间。







# 卡特兰数



![image-20221223103717546](F:\Study\Code\LeetCodePthonVersion\算法网课学习笔记2进阶.assets\image-20221223103717546-16717630392611.png)

假如说二叉树有N个节点，是无差别的，那么他有卡特兰数规律的结构变化。这个二叉树的这个例子，他就是可以用第一个范式。

​	然后假如说有N个0和N个1，然后要求前缀上0 的数要不比1少，这个问题就可以用第二个范式。这个需要点启发性的思想。在数学上，整数和偶数的数量是一样多的，**因为总能找个映射，让整数映射到偶数，并且偶数也能映射到整数**。同样的，对于这个题，可以建立两个集合，集合A中有N个0，N个1组出来的所有非法元素，B集合是N+1个1和N-1个0所组成的所有元素，可以证明他俩都是一样的。对于每个非法元素，都能找到他的一个最早的非法前缀（比如011100,你们011就是最早的非法前缀，），对于非法前缀，他总是 **1比0多一个**，在非法前缀后面的部分，肯定是0比1多一个。那么如果把非法前缀后面的部分0变1,1变0，那么就可以让非法前缀后面的部分给他变的1比0多一个，比如上面的例子，100给变成011.这其实就是一种变化，就是一种映射。那么这样我们就知道非法的数量，和这个N+1个1与N-1个0组成的集合的数量是一样的，那么合法的数量=总的排列数量-非法的数量，也就是N+1个1与N-1个0组成的集合的数量，就是卡特兰数的范式2了。

  再举个例子，栈，栈是出的数量肯定不大于入的数量的吧，其实就是卡特兰数。

​	如果两个集合，能够找到一一映射，那么就说明他们是数量相等的，如果不能找到，不一定他们数量不相等，也可能是自己找不到。





# 20221225 KMP算法

训练营1的class4——code1

这个是比较难的题，每个公司每个部门都会考

在讲KMP问题之前，先说暴力解，暴力解的复杂度是O（NM）的，而对于KMP算法，他是可以在O（N）拿下的，当N》M的时候。KMP算法其实和暴力解的流程一样的，只不过有加速。

```
 // O(N)
	public static int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] str = s.toCharArray();
		char[] match = m.toCharArray();
		int x = 0; // str中当前比对到的位置
		int y = 0; // match中当前比对到的位置
		// M  M <= N   O(M)
		int[] next = getNextArray(match); // next[i]  match中i之前的字符串match[0..i-1]
		// O(N)
		while (x < str.length && y < match.length) {
			if (str[x] == match[y]) {
				x++;
				y++;
			} else if (next[y] == -1) { // y == 0
				x++;
			} else {
				y = next[y];
			}
		}
		return y == match.length ? x - y : -1;
	}

	// M   O(M)
	public static int[] getNextArray(char[] match) {
		if (match.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[match.length];
		next[0] = -1;
		next[1] = 0;
		int i = 2;
		// cn代表，cn位置的字符，是当前和i-1位置比较的字符
		int cn = 0;
		while (i < next.length) {
			if (match[i - 1] == match[cn]) { // 跳出来的时候
				next[i++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[i++] = 0;
			}
		}
		return next;
	}
```



# 20221225 KMP算法及其拓展和bfprt算法





1.对于str1 = "123456",他有很多的旋转词，"234561","123456","345612","456123","561234","612345"等等。。给两个字符串，如果A是B的旋转词，那么就返回True，否则返回False.

可以把BB这么拼接起来，然后就是一个字符串匹配嘛。



2.给两棵树，一课是二叉树T1，另外一个是T2也是二叉树，问是否T1有一个子树，和T2的结构一样。这个是TreeEqual.java对应的代码。



bfprt算法是用来在面试的时候聊，装逼的，提身价的。

3. 无序数组中找第K小的事，如何O（N）实现？（不用排序的方法，不用快排）；不过这里用到了快排的思路。class3的FindMinKh.java对应的代码。训练营1.



bfprt的时间复杂度也是O（N），他和快排的不同，就是，快排的O（N）是根据概率求期望出的，bfprt算法是五友算法，这个算法是可以根据严格的看出来的。bfprt算法的改进之处就是在于选一个数M是怎么选的，他不是随机选的。



这个bfprt算法说实话我听的不太懂，可能也不太专心吧。



# 20221225 Manacher算法及其拓展

​                      想让一个字符串str变为回文，只能在str的后面加，最短加多少能让str变为回文。这个题的意思其实就是，必须包含str原来的最后一个字符的情况下，回文串有多长，延续到左边不是的位置，给他镜像到后面就是了。









# 20221227 Morris遍历及其相关扩展

